<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gawainx&#39; Blog</title>
  
  <subtitle>Antarx is the heart of Scorpio</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gawainx.github.io/"/>
  <updated>2018-05-24T08:59:19.408Z</updated>
  <id>https://gawainx.github.io/</id>
  
  <author>
    <name>Gawain Antarx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LaTeX排版学术论文工具链</title>
    <link href="https://gawainx.github.io/2018/05/21/latex-toolchain/"/>
    <id>https://gawainx.github.io/2018/05/21/latex-toolchain/</id>
    <published>2018-05-21T02:48:35.000Z</published>
    <updated>2018-05-24T08:59:19.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LaTeX-排版工具链"><a href="#LaTeX-排版工具链" class="headerlink" title="LaTeX 排版工具链"></a>LaTeX 排版工具链</h1><p> 这里整理了 $\LaTeX$ 排版学术论文的工具链。根据自己的实践和大家的留言补充定期更新。<br><a id="more"></a></p><h2 id="操作系统，软件等"><a href="#操作系统，软件等" class="headerlink" title="操作系统，软件等"></a>操作系统，软件等</h2><p>$\LaTeX$ 可以在 Windows、Linux 和 macOS 平台上运行。Windows 上可以安装 MikTex，Linux 上有 TeX Live，考虑美观度和排版过程的愉悦度，本人使用的 LaTeX 排版环境大致如下：</p><ul><li>OS : macOS(Darwin)</li><li>编辑器：<a href="https://code.visualstudio.com" target="_blank" rel="external">Microsoft VSCode</a></li><li>插件：LaTeX Workshop</li><li>$\LaTeX$ 软件：MacTeX 工具包</li><li>PDF 阅读工具：skim</li></ul><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p><a href="https://github.com/uefs/ieee-template-latex/blob/master/bare_jrnl.tex" target="_blank" rel="external">IEEE tran</a><br><code>bare_jrnl.tex</code>最新版本应该是 v1.7，但在网上好像找不到这个最新的版本，准备整理一个多文件编译的版本放到 GitHub 上。</p><p>欢迎留言补充其它模板。:)</p><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><p><a href="http://mohu.org/info/symbols/symbols.htm" target="_blank" rel="external">数学符号集</a></p><h2 id="插入伪代码（算法宏包的相关使用）"><a href="#插入伪代码（算法宏包的相关使用）" class="headerlink" title="插入伪代码（算法宏包的相关使用）"></a>插入伪代码（算法宏包的相关使用）</h2><p><a href="https://www.zybuluo.com/jfruan/note/720298" target="_blank" rel="external">LaTeX算法排版</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>使用<code>listings</code>宏包。<a href="https://en.wikibooks.org/wiki/LaTeX/Source_Code_Listings" target="_blank" rel="external">LaTeX/Source Code Listings</a><br>但这个宏包没有 golang 语法高亮支持的！要使 golang 语法高亮，可添加宏包<a href="https://github.com/julienc91/listings-golang" target="_blank" rel="external">listings-golang</a></p><h2 id="图片与表格"><a href="#图片与表格" class="headerlink" title="图片与表格"></a>图片与表格</h2><p>首先要理解浮动体的概念，<a href="https://liam0205.me/2017/04/30/floats-in-LaTeX-the-positioning-algorithm/" target="_blank" rel="external">LaTeX 中的浮动体：浮动算法</a></p><h2 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h2><p><a href="http://www.latexstudio.net" target="_blank" rel="external">LaTeX 开源小屋</a><br><a href="https://github.com/luongvo209/Begin-Latex-in-minutes" target="_blank" rel="external">Begin LaTeX in minutes</a><br><a href="https://book.douban.com/subject/24703731/" target="_blank" rel="external">LaTeX 入门</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LaTeX-排版工具链&quot;&gt;&lt;a href=&quot;#LaTeX-排版工具链&quot; class=&quot;headerlink&quot; title=&quot;LaTeX 排版工具链&quot;&gt;&lt;/a&gt;LaTeX 排版工具链&lt;/h1&gt;&lt;p&gt; 这里整理了 $\LaTeX$ 排版学术论文的工具链。根据自己的实践和大家的留言补充定期更新。&lt;br&gt;
    
    </summary>
    
    
      <category term="LaTeX" scheme="https://gawainx.github.io/tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>gorequest中文文档(非官方)</title>
    <link href="https://gawainx.github.io/2018/05/05/gorequest-doc/"/>
    <id>https://gawainx.github.io/2018/05/05/gorequest-doc/</id>
    <published>2018-05-05T11:19:43.000Z</published>
    <updated>2018-05-24T08:59:19.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gorequest指南"><a href="#Gorequest指南" class="headerlink" title="Gorequest指南"></a>Gorequest指南</h1><p><a href="https://github.com/parnurzeal/gorequest" target="_blank" rel="external">gorequest</a>为 golang 程序提供了极为简便的方式发起 HTTP 请求。网上关于这个库的中文教程不多，因此把官方的 README 文件翻译过来，结合自己的一些使用经验，希望能为各位 Gopher 提供一些帮助。<br><a id="more"></a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/parnurzeal/gorequest/gh-pages/images/Gopher_GoRequest_400x300.jpg" alt="GopherGoRequest" title="">                </div>                <div class="image-caption">GopherGoRequest</div>            </figure><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>支持发送Get/Post/Put/Head/Delete/Patch/Options 请求</li><li>建议的请求头设置</li><li>JSON 支持：以 JSON 格式字符串作为函数参数的方式简化传输 JSON 的步骤。</li><li>分段支持：分段请求（Multipart Request）的方式发送数据或传输文件</li><li>代理：支援通过代理的方式发送请求。</li><li>Timeout：为请求设置时间限制</li><li>TLS(传输层安全协议)相关设定。<blockquote><p>TLSClientConfig - taking control over tls where at least you can disable security check for https</p></blockquote></li><li>重定向策略</li><li>Cookie：为请求添加 cookie</li><li>CookieJar - automatic in-memory cookiejar</li><li>基本的权限认证。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go get github.com/parnurzeal/gorequest</div></pre></td></tr></table></figure><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>参阅<a href="http://godoc.org/github.com/parnurzeal/gorequest" target="_blank" rel="external">Go Doc</a><br>后续我会根据自己在开发中使用经验将文档翻译过来。</p><h2 id="使用-GoRequest-的一万个理由？"><a href="#使用-GoRequest-的一万个理由？" class="headerlink" title="使用 GoRequest 的一万个理由？"></a>使用 GoRequest 的一万个理由？</h2><p>通过 GoRequest 可以使工作变得更简单，使可以发起 HTTP 请求这件事更加优雅而充满乐趣。</p><p>不使用本库发起简单 GET 请求：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">resp, err := http.Get(<span class="string">"http://example.com/"</span>)</div></pre></td></tr></table></figure><p>使用 GoRequest</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">request := gorequest.New()</div><div class="line">resp, body, errs := request.Get(<span class="string">"http://example.com/"</span>).End()</div></pre></td></tr></table></figure><p>如果你不想重用<code>request</code>，也可以写成下面这样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">resp, body, errs := gorequest.New().Get(<span class="string">"http://example.com/"</span>).End()</div></pre></td></tr></table></figure><p>如果你需要设定 HTTP 头，设定重定向策略等，使用标准库会瞬间使事情变得异常复杂，在发起仅仅一个 <strong>GET</strong> 请求的过程，你就需要一个 <code>Client</code>，通过一系列不同的命令来设定 HTTP 头（<code>HTTP Headers</code>）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">client := &amp;http.Client&#123;</div><div class="line">  CheckRedirect: redirectPolicyFunc,</div><div class="line">&#125;</div><div class="line"></div><div class="line">req, err := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"http://example.com"</span>, <span class="literal">nil</span>)</div><div class="line"></div><div class="line">req.Header.Add(<span class="string">"If-None-Match"</span>, <span class="string">`W/"wyzzy"`</span>)</div><div class="line">resp, err := client.Do(req)</div></pre></td></tr></table></figure><p>现在，你有更加美妙的方式来完成这件事</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">request := gorequest.New()</div><div class="line">resp, body, errs := request.Get(<span class="string">"http://example.com"</span>).</div><div class="line">  RedirectPolicy(redirectPolicyFunc).</div><div class="line">  Set(<span class="string">"If-None-Match"</span>, <span class="string">`W/"wyzzy"`</span>).</div><div class="line">  End()</div></pre></td></tr></table></figure><p>发起 <strong>DELETE</strong>, <strong>HEAD</strong>, <strong>POST</strong>, <strong>PUT</strong>, <strong>PATCH</strong> 请求的过程和发起 <strong>GET</strong> 请求类似。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">request := gorequest.New()</div><div class="line">resp, body, errs := request.Post(<span class="string">"http://example.com"</span>).End()</div><div class="line"><span class="comment">// PUT -&gt; request.Put("http://example.com").End()</span></div><div class="line"><span class="comment">// DELETE -&gt; request.Delete("http://example.com").End()</span></div><div class="line"><span class="comment">// HEAD -&gt; request.Head("http://example.com").End()</span></div><div class="line"><span class="comment">// ANYTHING -&gt; request.CustomMethod("TRACE", "http://example.com").End()</span></div></pre></td></tr></table></figure><h3 id="处理-JSON"><a href="#处理-JSON" class="headerlink" title="处理 JSON"></a>处理 JSON</h3><p>用标准库发起 <strong>JSON POST</strong> ，你需要先将 <code>map</code> 或者 <code>struct</code>格式的数据包装（<strong>Marshal</strong>）成 JSON 格式的数据，将头参数设定为’application/json’（必要时还要设定其他头），然后要新建一个<code>http.CLient</code>变量。经过这一系列的步骤，你的代码变得冗长而难以维护</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"backy"</span>,</div><div class="line">  <span class="string">"species"</span>: <span class="string">"dog"</span>,</div><div class="line">&#125;</div><div class="line">mJson, _ := json.Marshal(m)</div><div class="line">contentReader := bytes.NewReader(mJson)</div><div class="line">req, _ := http.NewRequest(<span class="string">"POST"</span>, <span class="string">"http://example.com"</span>, contentReader)</div><div class="line">req.Header.Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</div><div class="line">req.Header.Set(<span class="string">"Notes"</span>,<span class="string">"GoRequest is coming!"</span>)</div><div class="line">client := &amp;http.Client&#123;&#125;</div><div class="line">resp, _ := client.Do(req)</div></pre></td></tr></table></figure><p>至于 GoRequest， JSON 支持是必须的，所以，用这个库你只需要一行代码完成所有工作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">request := gorequest.New()</div><div class="line">resp, body, errs := request.Post(<span class="string">"http://example.com"</span>).</div><div class="line">  Set(<span class="string">"Notes"</span>,<span class="string">"gorequst is coming!"</span>).</div><div class="line">  Send(<span class="string">`&#123;"name":"backy", "species":"dog"&#125;`</span>).</div><div class="line">  End()</div></pre></td></tr></table></figure><p>另外，它同样支持结构体类型。所以，你可以在你的请求中发送不同的数据类型（So, you can have a fun <strong>Mix &amp; Match</strong> sending the different data types for your request）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> BrowserVersionSupport <span class="keyword">struct</span> &#123;</div><div class="line">  Chrome <span class="keyword">string</span></div><div class="line">  Firefox <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line">ver := BrowserVersionSupport&#123; Chrome: <span class="string">"37.0.2041.6"</span>, Firefox: <span class="string">"30.0"</span> &#125;</div><div class="line">request := gorequest.New()</div><div class="line">resp, body, errs := request.Post(<span class="string">"http://version.com/update"</span>).</div><div class="line">  Send(ver).</div><div class="line">  Send(<span class="string">`&#123;"Safari":"5.1.10"&#125;`</span>).</div><div class="line">  End()</div></pre></td></tr></table></figure><p>Not only for <code>Send()</code> but <code>Query()</code> is also supported. Just give it a try! :)</p><h2 id="回调（Callback）"><a href="#回调（Callback）" class="headerlink" title="回调（Callback）"></a>回调（Callback）</h2><p>此外，GoRequest 支持回调函数，这让你可以更加灵活的使用这个库。<br>下面是回调函数的一个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">printStatus</span><span class="params">(resp gorequest.Response, body <span class="keyword">string</span>, errs []error)</span></span>&#123;</div><div class="line">  fmt.Println(resp.Status)</div><div class="line">&#125;</div><div class="line">gorequest.New().Get(<span class="string">"http://example.com"</span>).End(printStatus)</div></pre></td></tr></table></figure><h2 id="Multipart-Form-Data"><a href="#Multipart-Form-Data" class="headerlink" title="Multipart/Form-Data"></a>Multipart/Form-Data</h2><p>你可以将请求的内容类型设定为<code>multipart</code>来以<code>multipart/form-data</code>的方式发送所有数据。这个特性可以帮助你发送多个文件。<br>下面是一个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">gorequest.New().Post(<span class="string">"http://example.com/"</span>).</div><div class="line">  Type(<span class="string">"multipart"</span>).</div><div class="line">  Send(<span class="string">`&#123;"query1":"test"&#125;`</span>).</div><div class="line">  End()</div></pre></td></tr></table></figure><p>如果感兴趣可以在文档中查看<code>SendFile</code>函数部分获取更多。</p><h2 id="代理（Proxy）"><a href="#代理（Proxy）" class="headerlink" title="代理（Proxy）"></a>代理（Proxy）</h2><p>需要使用代理的时候，可以用 GoRequest Proxy Func 很好的处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">request := gorequest.New().Proxy(<span class="string">"http://proxy:999"</span>)</div><div class="line">resp, body, errs := request.Get(<span class="string">"http://example-proxy.com"</span>).End()</div><div class="line"><span class="comment">// To reuse same client with no_proxy, use empty string:</span></div><div class="line">resp, body, errs = request.Proxy(<span class="string">""</span>).Get(<span class="string">"http://example-no-proxy.com"</span>).End()</div></pre></td></tr></table></figure><h2 id="基本认证"><a href="#基本认证" class="headerlink" title="基本认证"></a>基本认证</h2><p>添加基本的认证头信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">request := gorequest.New().SetBasicAuth(<span class="string">"username"</span>, <span class="string">"password"</span>)</div><div class="line">resp, body, errs := request.Get(<span class="string">"http://example-proxy.com"</span>).End()</div></pre></td></tr></table></figure><h2 id="超时处理（Timeout）"><a href="#超时处理（Timeout）" class="headerlink" title="超时处理（Timeout）"></a>超时处理（Timeout）</h2><p>与 <code>time</code> 库结合可以设置成任何的时间限制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">request := gorequest.New().Timeout(<span class="number">2</span>*time.Millisecond)</div><div class="line">resp, body, errs:= request.Get(<span class="string">"http://example.com"</span>).End()</div></pre></td></tr></table></figure><p><code>Timeout</code> 函数同时设定了连接和 IO 的时间限制。</p><h2 id="以字节方式处理返回体（EndBytes）"><a href="#以字节方式处理返回体（EndBytes）" class="headerlink" title="以字节方式处理返回体（EndBytes）"></a>以字节方式处理返回体（EndBytes）</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">resp, bodyBytes, errs := gorequest.New().Get(<span class="string">"http://example.com/"</span>).EndBytes()</div></pre></td></tr></table></figure><h2 id="以结构体的方式处理返回体"><a href="#以结构体的方式处理返回体" class="headerlink" title="以结构体的方式处理返回体"></a>以结构体的方式处理返回体</h2><p>假设 URL <strong><a href="http://example.com/" target="_blank" rel="external">http://example.com/</a></strong> 的返回体<code>{&quot;hey&quot;:&quot;you&quot;}</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">heyYou <span class="keyword">struct</span> &#123;</div><div class="line">  Hey <span class="keyword">string</span> <span class="string">`json:"hey"`</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> heyYou heyYou</div><div class="line"></div><div class="line">resp, _, errs := gorequest.New().Get(<span class="string">"http://example.com/"</span>).EndStruct(&amp;heyYou)</div></pre></td></tr></table></figure><h2 id="连续重复请求（Retry）"><a href="#连续重复请求（Retry）" class="headerlink" title="连续重复请求（Retry）"></a>连续重复请求（Retry）</h2><p>假设你在得到 BadRequest 或服务器内部错误（InternalServerError）时进行连续三次，间隔五秒的连接尝试</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">request := gorequest.New()</div><div class="line">resp, body, errs := request.Get(<span class="string">"http://example.com/"</span>).</div><div class="line">                    Retry(<span class="number">3</span>, <span class="number">5</span> * time.Second, http.StatusBadRequest, http.StatusInternalServerError).</div><div class="line">                    End()</div></pre></td></tr></table></figure><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><blockquote><p>Redirects can be handled with RedirectPolicy which behaves similarly to net/http Client’s <a href="https://golang.org/pkg/net/http#Client" target="_blank" rel="external">CheckRedirect function</a>. Simply specify a function which takes the Request about to be made and a slice of previous Requests in order of oldest first. When this function returns an error, the Request is not made.</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">request := gorequest.New()</div><div class="line">resp, body, errs := request.Get(<span class="string">"http://example.com/"</span>).</div><div class="line">                    RedirectPolicy(<span class="function"><span class="keyword">func</span><span class="params">(req Request, via []*Request)</span> <span class="title">error</span></span> &#123;</div><div class="line">                      <span class="keyword">if</span> req.URL.Scheme != <span class="string">"https"</span> &#123;</div><div class="line">                        <span class="keyword">return</span> http.ErrUseLastResponse</div><div class="line">                      &#125;</div><div class="line">                    &#125;).</div><div class="line">                    End()</div></pre></td></tr></table></figure><h2 id="Debug-模式"><a href="#Debug-模式" class="headerlink" title="Debug 模式"></a>Debug 模式</h2><blockquote><p>For debugging, GoRequest leverages <code>httputil</code> to dump details of every request/response. (Thanks to @dafang).You can just use <code>SetDebug</code> or environment variable <code>GOREQUEST_DEBUG=0|1</code> to enable/disable debug mode and <code>SetLogger</code> to set your own choice of logger.Thanks to @QuentinPerez, we can see even how gorequest is compared to CURL by using <code>SetCurlCommand</code>.</p></blockquote><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p><code>gorequest.New()</code>函数应该一次调用，对返回的实例尽可能多次使用。</p><h2 id="Credits"><a href="#Credits" class="headerlink" title="Credits"></a>Credits</h2><ul><li>Renee French - the creator of Gopher mascot</li><li><a href="https://www.facebook.com/puairw" target="_blank" rel="external">Wisi Mongkhonsrisawat</a> for providing an awesome GoRequest’s Gopher image :)</li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>GoRequest is MIT License.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Gorequest指南&quot;&gt;&lt;a href=&quot;#Gorequest指南&quot; class=&quot;headerlink&quot; title=&quot;Gorequest指南&quot;&gt;&lt;/a&gt;Gorequest指南&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/parnurzeal/gorequest&quot;&gt;gorequest&lt;/a&gt;为 golang 程序提供了极为简便的方式发起 HTTP 请求。网上关于这个库的中文教程不多，因此把官方的 README 文件翻译过来，结合自己的一些使用经验，希望能为各位 Gopher 提供一些帮助。&lt;br&gt;
    
    </summary>
    
    
      <category term="go" scheme="https://gawainx.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>使用mage实现交叉编译</title>
    <link href="https://gawainx.github.io/2018/04/23/mage2/"/>
    <id>https://gawainx.github.io/2018/04/23/mage2/</id>
    <published>2018-04-23T03:17:36.000Z</published>
    <updated>2018-05-24T08:59:19.427Z</updated>
    
    <content type="html"><![CDATA[<p>golang 为微服务的开发带来了无可比拟的便利。使用的时候也自然而言发现一些问题，因为 golang 不像 Java 有 Maven 这样的打包工具，而是直接编译成二进制可执行文件，所以在开发机（macOS）上编译出来的可执行文件是无法在服务器或者 docker 容器里运行的，如果把源代码提交上去服务器编译，又会带来重新下载依赖包的麻烦（golang 的包依赖关系管理方面的缺失是我认为 golang 为数不多的缺点之一）。最近一直在思考有没有类似 Makefile 的方式来解决这件事（如果只想交叉编译的话直接用 go build或者借助 <a href="https://github.com/mitchellh/gox" target="_blank" rel="external">gox</a> 等工具也不是不可以，可还是，不够方便）。直到之前 ing 大神给我推荐了 Hugo 这个静态博客框架，虽然目前因为找不到合适的博客主题没有从 hexo 迁移过去，但看源代码的时候有了一个重要的收获，就是<a href="https://magefile.org" target="_blank" rel="external">mage</a><br>关于 mage 的基本安装和使用详见<a href="">mage 使用教程(一)</a><br><a id="more"></a></p><h2 id="golang-交叉编译的基本原理"><a href="#golang-交叉编译的基本原理" class="headerlink" title="golang 交叉编译的基本原理"></a>golang 交叉编译的基本原理</h2><p>交叉编译的实现主要是依靠三个参数，<code>CGO_ENABLE</code>,<code>GOOS</code>,<code>GOARCH</code><br><code>CGO_ENABLE</code>在源代码中使用 C/C++时必须开启，这样就无法实现交叉编译了，这部分代码还是得具体平台生成特定的代码。因此，交叉编译是在没有混编代码的前提下的。将<code>CGO_ENABLE</code>设为0，表示关闭。<br><code>GOOS</code>是目标操作系统，macOS 对应的是<code>darwin</code>，Linux 平台对应的是<code>linux</code>。<br><code>GOARCH</code>是目标架构，一般设为<code>amd64</code><br>按照如上所述设定要编译参数之后再执行<code>go build</code>即可生成目标平台的代码。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// +build mega</span></div><div class="line"><span class="comment">// magefile.go</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Linux</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="comment">//设置环境变量</span></div><div class="line">    <span class="keyword">var</span> e= <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</div><div class="line">e[<span class="string">"CGO_ENABLE"</span>] = <span class="string">"0"</span></div><div class="line">e[<span class="string">"GOOS"</span>] = <span class="string">"linux"</span></div><div class="line">e[<span class="string">"GOARCH"</span>] = <span class="string">"amd64"</span></div><div class="line">name := fmt.Sprintf(<span class="string">"%s-linux-%s"</span>,prefix,VERSION)</div><div class="line"><span class="comment">//创建 bin 文件夹</span></div><div class="line"><span class="keyword">if</span> err := os.Mkdir(<span class="string">"bin"</span>, <span class="number">0700</span>); err != <span class="literal">nil</span> &amp;&amp; !os.IsExist(err) &#123;</div><div class="line">fmt.Errorf(<span class="string">"failed to create %s: %v"</span>, <span class="string">"bin"</span>, err)</div><div class="line">os.Exit(<span class="number">1</span>)</div><div class="line">&#125;</div><div class="line">path := filepath.Join(<span class="string">"bin"</span>,name)</div><div class="line">fmt.Println(<span class="string">"Building app for linux..."</span>)</div><div class="line"><span class="comment">//运行构建命令</span></div><div class="line">err := sh.RunWith(e,<span class="string">"go"</span>,<span class="string">"build"</span>,<span class="string">"-o"</span>,path,<span class="string">"main.go"</span>,<span class="string">"utils.go"</span>,<span class="string">"RESTHandler.go"</span>,<span class="string">"module.go"</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</div><div class="line">fmt.Println(err)</div><div class="line"><span class="keyword">return</span></div><div class="line">&#125;</div><div class="line">fmt.Printf(<span class="string">"Sucessfully Built.Output File: %s\n"</span>,path)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在magefile所在文件夹输入 <code>mage linux</code> 即可编译生成适用于 Linux 的运行文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;golang 为微服务的开发带来了无可比拟的便利。使用的时候也自然而言发现一些问题，因为 golang 不像 Java 有 Maven 这样的打包工具，而是直接编译成二进制可执行文件，所以在开发机（macOS）上编译出来的可执行文件是无法在服务器或者 docker 容器里运行的，如果把源代码提交上去服务器编译，又会带来重新下载依赖包的麻烦（golang 的包依赖关系管理方面的缺失是我认为 golang 为数不多的缺点之一）。最近一直在思考有没有类似 Makefile 的方式来解决这件事（如果只想交叉编译的话直接用 go build或者借助 &lt;a href=&quot;https://github.com/mitchellh/gox&quot;&gt;gox&lt;/a&gt; 等工具也不是不可以，可还是，不够方便）。直到之前 ing 大神给我推荐了 Hugo 这个静态博客框架，虽然目前因为找不到合适的博客主题没有从 hexo 迁移过去，但看源代码的时候有了一个重要的收获，就是&lt;a href=&quot;https://magefile.org&quot;&gt;mage&lt;/a&gt;&lt;br&gt;关于 mage 的基本安装和使用详见&lt;a href=&quot;&quot;&gt;mage 使用教程(一)&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://gawainx.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>mage 使用教程(一)</title>
    <link href="https://gawainx.github.io/2018/04/23/mage1/"/>
    <id>https://gawainx.github.io/2018/04/23/mage1/</id>
    <published>2018-04-23T02:24:36.000Z</published>
    <updated>2018-05-24T08:59:19.426Z</updated>
    
    <content type="html"><![CDATA[<p>Mage 是使用 golang 开发的类 Make的软件构建工具。借助这个工具只需要编写符合 golang 语言规范的代码就可以实现比较复杂的源代码编译。<br><a id="more"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装 mage 之前首先要安装 golang1.7或以上版本。安装好之后，执行以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">go get -u -d github.com/magefile/mage</div><div class="line">cd $GOPATH/src/github.com/magefile/mage</div><div class="line">go run bootstrap.go</div></pre></td></tr></table></figure><p>编译完成之后，名为 mage 的可执行文件放在<code>$GOPATH/bin</code>目录下，将<code>$GOPATH/bin</code>加入到系统路径即可在终端中直接输入<code>mage</code>运行软件。</p><h2 id="第一个-Magefile"><a href="#第一个-Magefile" class="headerlink" title="第一个 Magefile"></a>第一个 Magefile</h2><p>Magefile 实质是符合 golang 语法的源代码，并且加入了特定的注记，规则如下：</p><ol><li>在包名之前加入一行，<code>// +build mage</code></li><li>包名必须为 <code>main</code></li><li>每个可导出函数会变成可被 mage 执行的选项（类似 Makefile 的每一个 tag）</li><li>每个可导出函数前的注释会被转换成帮助文档</li><li>文件名可以但不一定必须是 Magefile.go</li></ol><p>在任意目录输入<code>mage -init</code>可以生成Magefile.go 模板代码。<br>可以输入以下代码实验以上规则</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// +build mage</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"><span class="keyword">import</span>(</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"log"</span></div><div class="line">)</div><div class="line"><span class="comment">//Build</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Build</span><span class="params">()</span></span>&#123;</div><div class="line">    fmt.Println(<span class="string">"Building..."</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">//Install</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Install</span><span class="params">()</span></span>&#123;</div><div class="line">    log.Println(<span class="string">"Installing..."</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="预备，构建"><a href="#预备，构建" class="headerlink" title="预备，构建"></a>预备，构建</h2><p>构建只需要一行代码<code>mage build</code>，程序就会自动执行 <code>Build</code> 函数，完成整个构建过程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mage 是使用 golang 开发的类 Make的软件构建工具。借助这个工具只需要编写符合 golang 语言规范的代码就可以实现比较复杂的源代码编译。&lt;br&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://gawainx.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang 处理 yaml 格式数据</title>
    <link href="https://gawainx.github.io/2018/04/11/goyaml/"/>
    <id>https://gawainx.github.io/2018/04/11/goyaml/</id>
    <published>2018-04-11T09:18:58.000Z</published>
    <updated>2018-05-24T08:59:19.428Z</updated>
    
    <content type="html"><![CDATA[<p>YAML 格式的数据常用来作为配置文件使用, 因此相对来说字段比较固定, 在 golang 中进行解析时跟上一篇提到的解析 json 数据有所区别</p><p>## </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;YAML 格式的数据常用来作为配置文件使用, 因此相对来说字段比较固定, 在 golang 中进行解析时跟上一篇提到的解析 json 数据有所区别&lt;/p&gt;
&lt;p&gt;## &lt;/p&gt;

      
    
    </summary>
    
    
      <category term="golang" scheme="https://gawainx.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>go 语言中 JSON 数据的处理</title>
    <link href="https://gawainx.github.io/2018/03/30/gojson/"/>
    <id>https://gawainx.github.io/2018/03/30/gojson/</id>
    <published>2018-03-30T07:20:31.000Z</published>
    <updated>2018-05-24T08:59:19.440Z</updated>
    
    <content type="html"><![CDATA[<p>Golang 中处理 JSON 格式数据主要依赖<code>encoding/json</code>这个库，很多教程（包括 Go 语言圣经）讲 JSON 数据处理时都会定义一个结构体对应于 JSON 数据的各个字段，这种处理方法在 JSON 中字段相对固定时非常实用。但对于字段可能不断变化或者只有一两个字段是固定的时候，如何处理这个问题往往令很多人感到困惑。最近研究 gin 这个库的时候发现一个思路非常值得学习借鉴。<br><a id="more"></a></p><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>说了这么多，其实并不神秘，就是来自 gin 框架源码中的一句关键定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// H is a shortcup for map[string]interface&#123;&#125;</span></div><div class="line"><span class="keyword">type</span> H <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</div></pre></td></tr></table></figure><p>定义了这个数据结构之后，gin 框架就可以处理几乎所有的 JSON 数据。</p><p>同理，我们在自己的代码中想不受结构体限制灵活处理 JSON 数据时，也可以在程序代码中添加类似的定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> message <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</div></pre></td></tr></table></figure><p>从字符串解析 JSON 数据时，只需要</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//body is string message</span></div><div class="line"><span class="keyword">var</span> result mss</div><div class="line">json.Unmarshal([]<span class="keyword">byte</span>(body),&amp;result)</div></pre></td></tr></table></figure><p>包装 JSON 也类似</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//mes is message type</span></div><div class="line">bty,err := json.Marshal(mes)</div></pre></td></tr></table></figure><p>值得一说的是平时处理 JSON 数据经常出现的反斜杠双引号问题，用这种方法处理时并没有出现。</p><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>背后原理分析。</p><p>这一行代码之所以这么实用是因为<code>interface{}</code>这个 golang 中的“万金油”。Golang 中不存在类和对象的概念，因此空接口就成了所有变量的“超类”一样的存在，可以承载一切的变量。</p><h2 id="潜在问题-and-Further-More"><a href="#潜在问题-and-Further-More" class="headerlink" title="潜在问题 and Further More"></a>潜在问题 and Further More</h2><p>处理 JSON Array 时会出现问题，就是明知它是数组却不能直接用下标进行操作（会提示<code>{}interface</code> 不支持下标，导致编译失败），实际运行时用反射包的<code>reflect.TypeOf</code>查看JSON 数组解析出来的类型明明是<code>[]interface{}</code>，是接口slice，是支持下标操作的。</p><p>原因是 Golang 是静态语言，代码中所有变量的类型都是在编译期确定的，我们所定义的类型中 map 的 value 部分是<code>{}interface</code>，在 运行时接收到需要解析的 JSON 数据之前编译器和我们都不知道它“事实上”是一个 slice。</p><p>这个在项目应用中实际存在的矛盾也解决我学 OOP 语言一直以来的困惑，就是反射是什么？为什么现代编程语言都选择加入反射作为基本特性（Java，C#，还有本文中的 Golang），就是因为我们有在运行时获取某个对象/变量的实际类型的需要。</p><p>由于目前学习还不够深入，不能对反射机制展开深入的探讨，在这里讲一下如何利用类型断言机制解决上面说到的问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cs,ok := result[<span class="string">"containers"</span>].([]<span class="keyword">interface</span>&#123;&#125;)</div><div class="line"><span class="keyword">if</span> ok&#123;</div><div class="line"><span class="keyword">for</span> i,item := <span class="keyword">range</span> cs&#123;</div><div class="line"><span class="comment">//do something</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>cs,ok := result[&quot;containers&quot;].([]interface{})</code>这一句就是解决问题的关键所在，也就是称为运行时类型断言的机制。<code>a.(Type)</code>是尝试对a进行类型转换的操作，如果转换成功则返回一个转换成 Type 类型的变量和<code>true</code>指示转换成功，失败则返回<code>false</code>。</p><p>值得一提的是，断言失败不会导致编译失败（要是会导致编译失败也就不能解决上面这个问题了），所以为了代码健壮性需要对转换结果进行判断比较好。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Golang 中处理 JSON 格式数据主要依赖&lt;code&gt;encoding/json&lt;/code&gt;这个库，很多教程（包括 Go 语言圣经）讲 JSON 数据处理时都会定义一个结构体对应于 JSON 数据的各个字段，这种处理方法在 JSON 中字段相对固定时非常实用。但对于字段可能不断变化或者只有一两个字段是固定的时候，如何处理这个问题往往令很多人感到困惑。最近研究 gin 这个库的时候发现一个思路非常值得学习借鉴。&lt;br&gt;
    
    </summary>
    
    
      <category term="go" scheme="https://gawainx.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>redis的杂七杂八</title>
    <link href="https://gawainx.github.io/2018/02/25/redis/"/>
    <id>https://gawainx.github.io/2018/02/25/redis/</id>
    <published>2018-02-25T15:09:10.000Z</published>
    <updated>2018-05-24T08:59:19.421Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 是目前应用比较广泛的数据库。最近的实验室项目中用到它作为实时数据库。把这个过程中学到的一些东西记录下来，权且作为小白的入门参考吧<br><a id="more"></a></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Redis 是一种基于内存的数据库，这意味着在使用过程中的所有数据都是存放在内存当中的，省去硬盘读写的过程使得对数据库的操作会非常的快，很适合并发。</p><p>Redis 的基本储存单位是<code>key-value</code>，比 mongodb 中的“文档”的概念有着更细的粒度。<code>key</code>部分一般是字符串类型，<code>value</code>部分可以有以下五种类型：</p><ol><li>string。字符串类型</li><li>hash。一系列<code>k-v</code>的集合，适合用来储存对象实例或者 JSON</li><li>list。简单的字符串列表，也就是说可以通过 list 数据结构在一个<code>key</code>对应的<code>value</code>字段储存多个字符串。这多个字符串是有序排列的。“序”指的是插入的顺序（可以选从头部或者尾部插入）</li><li>set。String 类型的无序集合。满足唯一性。</li><li>有序集合。set 的有序版本</li></ol><h2 id="命令行操作"><a href="#命令行操作" class="headerlink" title="命令行操作"></a>命令行操作</h2><h3 id="服务器（server-端）"><a href="#服务器（server-端）" class="headerlink" title="服务器（server 端）"></a>服务器（server 端）</h3><p>安装 Redis 之后，在命令行窗口输入<code>redis-server</code>即可在本机运行一个radis 的 server 端，默认的端口是6379.</p><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>Redis 服务器端和其他主流数据库一样可以很方便的放到 Docker 容器里运行。</p><p>下载 Redis 镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo docker pull redis</div></pre></td></tr></table></figure><p>基于 redis 镜像运行容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo docker run --name redis-server -p 6379:6379 -d redis</div></pre></td></tr></table></figure><p>镜像内部已经设置了运行<code>redis-server</code>和监听6379端口，所以不需要额外的设置项，只需要在运行容器时将端口暴露出来（与宿主机的6379端口或者自己指定的端口绑定）就可以了</p><h3 id="client-端"><a href="#client-端" class="headerlink" title="client 端"></a>client 端</h3><p>shell 界面下输入<code>redis-cli -h 127.0.0.1 -p 6379</code>启动 redis-client。其中，<code>-h</code>指定服务器的地址，<code>-p</code>指定服务器的端口。</p><h4 id="基本操作命令"><a href="#基本操作命令" class="headerlink" title="基本操作命令"></a>基本操作命令</h4><p>注意到，命令的操作字段是不区分大小写的。</p><ol><li>value 为 String 类型时。<code>set key value</code>用于为 key 设置值为 value。 <code>get key</code>用于获取键为 key 的值。</li><li>value 为 list类型时。<code>lpush key value1 [value2]…</code>用于将一个或者多个值。 <code>LPOP key</code>可以移出并获取列表的第一个元素。这两个操作换成<code>rpush</code>和<code>rpop</code>可以向列表尾部插入元素。<code>LLEN key</code>可以获取 key 对应的列表的长度。<code>LRANGE key start stop</code>用于获取特定key 的指定范围的元素，特别地，<code>LRANGE key 0 -1</code>可以用来遍历列表。</li></ol><p>更加详细的命令教程可以参考<a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="external">Redis教程-菜鸟教程</a></p><h2 id="编程语言支持"><a href="#编程语言支持" class="headerlink" title="编程语言支持"></a>编程语言支持</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>在 Java 中主要通过 jedis 数据库驱动实现对 Redis 数据库的操作。</p><p>安装依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><h4 id="JedisPool和-JedisClient"><a href="#JedisPool和-JedisClient" class="headerlink" title="JedisPool和 JedisClient"></a>JedisPool和 JedisClient</h4><p>jedis 使用 JedisPool 作为一个Redis连接池，用于解决对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题。</p><p>连接池初始化代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JedisPool <span class="title">getPool</span><span class="params">(String host, <span class="keyword">int</span> port)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(pool == <span class="keyword">null</span>)&#123;</div><div class="line">            JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</div><div class="line">            </div><div class="line"><span class="comment">//设置最大连接数</span></div><div class="line">            config.setMaxTotal(<span class="number">100</span>);</div><div class="line"></div><div class="line">            config.setMaxIdle(<span class="number">5</span>);</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(host == <span class="keyword">null</span>)&#123;</div><div class="line">                pool = <span class="keyword">new</span> JedisPool(config, <span class="string">"127.0.0.1"</span>, port);</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                pool = <span class="keyword">new</span> JedisPool(config, host, port);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> pool;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>要使用Client 时，使用<code>pool.getResource()</code>方法获取单个JedisClient实例，在此基础上对 Redis 数据库进行操作。</p><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><p>Go 语言中用来连接 Redis 数据库的库五花八门，主要分两个派系，将对 Redis 的操作封装成方法的，开发者通过调用库的方法实现对 Redis 数据库的操作；另一派是直接将 Redis 命令作为字符串提供给库来实现各种操作的。</p><p>这里以<code>&quot;github.com/garyburd/redigo/redis&quot;</code>为例。</p><p>安装依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go get github.com/garyburd/redigo/redis</div></pre></td></tr></table></figure><p>获取 redis pool实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">redis.Pool&#123;</div><div class="line">MaxIdle:<span class="number">10</span>,</div><div class="line">MaxActive:<span class="number">15</span>,</div><div class="line">IdleTimeout:<span class="number">240</span>*time.Second,</div><div class="line">Dial: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(redis.Conn, error)</span></span> &#123;</div><div class="line">c, err := redis.Dial(<span class="string">"tcp"</span>, redisURL)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> c, err</div><div class="line">&#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从 pool 中获取 Client 实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rClient := redisPool.Get()</div></pre></td></tr></table></figure><p>执行操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rClient.Do(<span class="string">"LPUSH"</span>,<span class="string">"key"</span>, <span class="string">"value"</span>)</div></pre></td></tr></table></figure><p>Do 方法用于执行对 Redis 数据库的操作命令。方法的第一个参数字符串命令（就是在 shell 交互时的各种命令。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 是目前应用比较广泛的数据库。最近的实验室项目中用到它作为实时数据库。把这个过程中学到的一些东西记录下来，权且作为小白的入门参考吧&lt;br&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://gawainx.github.io/tags/golang/"/>
    
      <category term="Java" scheme="https://gawainx.github.io/tags/Java/"/>
    
      <category term="Redis" scheme="https://gawainx.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>go-websocket</title>
    <link href="https://gawainx.github.io/2018/01/23/go-websocket/"/>
    <id>https://gawainx.github.io/2018/01/23/go-websocket/</id>
    <published>2018-01-23T11:06:17.000Z</published>
    <updated>2018-05-24T08:59:19.422Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Keras 手写数字识别</title>
    <link href="https://gawainx.github.io/2018/01/23/aml/"/>
    <id>https://gawainx.github.io/2018/01/23/aml/</id>
    <published>2018-01-23T10:42:42.000Z</published>
    <updated>2018-05-24T08:59:19.432Z</updated>
    
    <content type="html"><![CDATA[<hr><p>之前机器学习课程布置的大作业是用尽可能多的模型来探索经典的手写数字识别问题。这里分享一下Keras的基本使用<br><a id="more"></a></p><h1 id="Keras简介"><a href="#Keras简介" class="headerlink" title="Keras简介"></a>Keras简介</h1><p>Keras 是由纯 Python 写成的，调用 TensorFlow 或者 Theano（最新版本还支持 CNTK）进行运算的类库。相比于 TensorFlow，Keras 使用起来更加简洁方便，便于调参，非常适合初学者进行机器学习探索。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>在安装好 anaconda 的前提下，输入<code>conda install keras</code>即可进行安装。</p><p>注意到，安装过程会自动判断机器是否已经安装好了TensorFlow，如果没有的话会自动进行安装。所以，如果想安装 TensorFlow GPU 版本加速计算过程的话，要先手动安装好 TensorFlow 的 GPU 版本，然后再安装 Keras。</p><h1 id="实现单层感知机"><a href="#实现单层感知机" class="headerlink" title="实现单层感知机"></a>实现单层感知机</h1><p>核心代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">batch_size = <span class="number">128</span></div><div class="line">classes = <span class="number">10</span></div><div class="line">epoch = <span class="number">10</span></div><div class="line">img_size = <span class="number">28</span> * <span class="number">28</span></div><div class="line"></div><div class="line">print(<span class="string">'Loading Data...'</span>)</div><div class="line">(X_train, y_train),(X_test,y_test) = mnist.load_data()</div><div class="line"></div><div class="line">X_train = X_train.reshape(y_train.shape[<span class="number">0</span>], img_size).astype(<span class="string">'float32'</span>) / <span class="number">255</span></div><div class="line">X_test = X_test.reshape(y_test.shape[<span class="number">0</span>], img_size).astype(<span class="string">'float32'</span>) / <span class="number">255</span></div><div class="line"></div><div class="line"><span class="comment">#encode labels</span></div><div class="line">Y_train = np_utils.to_categorical(y_train,classes)</div><div class="line">Y_test = np_utils.to_categorical(y_test,classes)</div><div class="line"></div><div class="line"></div><div class="line">model = Sequential([Dense(<span class="number">10</span>, input_shape=(img_size,), activation=<span class="string">'softmax'</span>),])</div><div class="line">model.compile(optimizer=<span class="string">'rmsprop'</span>, loss=<span class="string">'mean_absolute_error'</span>, metrics=[<span class="string">'accuracy'</span>])</div><div class="line"></div><div class="line">print(<span class="string">"Training..."</span>)</div><div class="line">model.fit(X_train, Y_train,batch_size=batch_size, epochs=epoch, verbose=<span class="number">1</span>, validation_data=(X_test,Y_test))</div><div class="line"></div><div class="line">score = model.evaluate(X_test,Y_test,verbose=<span class="number">0</span>)</div><div class="line"></div><div class="line">print(<span class="string">'accuracy: &#123;&#125;'</span>.format(score[<span class="number">1</span>]))</div></pre></td></tr></table></figure><p>前面很大一部分都是进行数据加载和处理，与模型有关的代码只有三行</p><p><code>model = Sequential([Dense(10, input_shape=(img_size,), activation=&#39;softmax&#39;),])</code>这一行是模型基本形态的定义，以图像的 size 作为输入，激活函数采用 softmax。</p><p><code>model.compile(optimizer=&#39;rmsprop&#39;, loss=&#39;mean_absolute_error&#39;, metrics=[&#39;accuracy&#39;])</code>这一行则是对模型的微观参数进行客制化。<code>optimizer</code>指定的是优化策略，<code>rmsprop</code>是一种改进的随机梯度下降策略。<code>loss</code>指的是损失函数。<code>metrics</code>是评估方法，这里用准确率进行评估。</p><p><code>model.fit(X_train, Y_train,batch_size=batch_size, epochs=epoch, verbose=1, validation_data=(X_test,Y_test))</code>这一句是训练过程，指定训练数据，训练轮次（迭代次数），是否输出训练过程，验证数据。</p><h1 id="多层全连接网络"><a href="#多层全连接网络" class="headerlink" title="多层全连接网络"></a>多层全连接网络</h1><p>核心代码部分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">model = Sequential([Dense(<span class="number">512</span>,input_shape=(img_size,)),</div><div class="line">                    Activation(<span class="string">'relu'</span>),</div><div class="line">                    Dropout(<span class="number">0.2</span>),</div><div class="line">                    Dense(<span class="number">512</span>, input_shape=(<span class="number">512</span>,)),</div><div class="line">                    Activation(<span class="string">'relu'</span>),</div><div class="line">                    Dropout(<span class="number">0.2</span>),</div><div class="line">                    Dense(<span class="number">10</span>,input_shape=(<span class="number">512</span>,),activation=<span class="string">'softmax'</span>)</div><div class="line">                    ])</div></pre></td></tr></table></figure><p>每一个 Dense 都是一个神经元训练层。训练层输出接 ReLU 激活函数层。如此类推。最后一层接单层感知机获取结果。值得注意的是两个 Dropout 层，用于应付过拟合问题，经过 Dropout 层会随机丢弃数据集中一定比率的激活值，同时将剩余的神经元的输出进行放大。</p><h1 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">model = Sequential()</div><div class="line">model.add(Conv2D(<span class="number">32</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>),</div><div class="line">                 activation=<span class="string">'relu'</span>,</div><div class="line">                 input_shape=input_shape))</div><div class="line">model.add(Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>))</div><div class="line">model.add(MaxPooling2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>)))</div><div class="line">model.add(Dropout(<span class="number">0.25</span>))</div><div class="line">model.add(Flatten())</div><div class="line">model.add(Dense(<span class="number">128</span>, activation=<span class="string">'relu'</span>))</div><div class="line">model.add(Dropout(<span class="number">0.5</span>))</div><div class="line">model.add(Dense(num_classes, activation=<span class="string">'softmax'</span>))</div></pre></td></tr></table></figure><p>卷积神经网络中主角变成了 Conv2D （卷积层）和 Pooling 层（池化）。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;之前机器学习课程布置的大作业是用尽可能多的模型来探索经典的手写数字识别问题。这里分享一下Keras的基本使用&lt;br&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://gawainx.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>网研机试101</title>
    <link href="https://gawainx.github.io/2018/01/08/buptoj/"/>
    <id>https://gawainx.github.io/2018/01/08/buptoj/</id>
    <published>2018-01-08T10:13:08.000Z</published>
    <updated>2018-05-24T08:59:19.417Z</updated>
    
    <content type="html"><![CDATA[<p>2018考研的初试已经结束了，平时看考研群里已经有很多人在讨论在焦虑机试应该怎么复习，作为过来人在这里就随便说说自己的一些经验吧。</p><p>实现说明一下，这篇文章基本就是个扫盲，不能保证你看完文章就能从 A0变 AK，但帮助你脱离新手区，扫除对机试的恐惧，保个底让机试不会成为复试阶段的软肋还是可以的。<br><a id="more"></a></p><h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>首先得先了解机试的基本情况。按照去年的考试风格，是两个小时四道题的 OJ（Online Judge）形式，也就是在线提交，在线判题返回程序在测试结果集的运行结果。AC（accept）代表正确解题，WA（Wrong Answer）表示错误答案，另外还有超时、超出内存空间等等结果。所有考试前准备的目的，就是为了更多的 AC，或者保底情况，避免 A0。</p><h1 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h1><h2 id="该用什么语言"><a href="#该用什么语言" class="headerlink" title="该用什么语言"></a>该用什么语言</h2><p>北邮 OJ 平台可以用的编程语言有三种，C（gcc4.8），C++（g++ 4.8）和 Java（注意：没有 Python，没有 JavaScript）。另外，C++是<strong>不支持 c++11的</strong>，Java 只支持到 Java6。</p><p>在这个天煞的背景下，考虑到程序时间限制（1ms）和开发速度（避免无谓的造轮子），用 C + STL 是最理想的选择。</p><p>展开来说，就是用 C 的那一套输入输出（scanf 和 printf），C 与 C++通用的循环控制、选择结构、数组等，在加上 C++独特的“宝具”——STL 标准库，来进行解题。提交的时候编译器选 g++即可。</p><p>STL 标准库内容非常多，只需要了解 Map，stack，list，queue就够了。</p><h2 id="IDE？不存在的"><a href="#IDE？不存在的" class="headerlink" title="IDE？不存在的"></a>IDE？不存在的</h2><p>两个小时做四道题对大脑转数的要求还是挺高的，更何况在那种紧张的气氛和不熟悉的开发环境之下。要保证解题能够快狠准，就需要从现在开始培养一定的针对考试的编程习惯，包括 编辑器和编译器、调试器的使用等等。</p><p>首先，抛弃手上所有的 IDE，包括但不限于 Visual Studio和 Clion，DevC++，或者只在疑难杂症的时候拿它们当单步调试的工具（但也不能依赖）。考试环境只提供了（没有智能提示的）devcpp，（长得贼丑的）CFree两种最“原始”的开发工具，也就拿来当代码高亮，保证括号补全没有基本的语法问题差不多了，很多现代 IDE、开发工具可以做的事它们一概做不了。</p><p>要适应这种艰苦恶劣的考试环境，就得从准备机试的时候开始，把开发工具换成 VScode and g++。VScode 是微软提供的跨平台编辑器，有着漂亮的界面和基本的语法高亮功能，在配置各种插件之前基本可以拿来模拟考场的开发环境，用来编辑代码，而且还能保证练习的时候是比较舒服的。</p><p>编译过程全部转到命令行用 g++完成。</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>两个最基本额调试手段：打印大法和单步调试大法。个人推荐第一种。单步调试大法需要掌握 gdb这个 g++配套的调试工具，相对来说比较费时间（无论上手还是在考场上使用），而且比较容易出一些奇奇怪怪的问题。想成为 AK 达人的话，倒是必须掌握的。</p><p>打印大法就是在关键步骤将关键变量输出的方法，简单易行，只要注意提交之前注释掉代码就OK。</p><h2 id="参考教材"><a href="#参考教材" class="headerlink" title="参考教材"></a>参考教材</h2><p>注意到，机试是可以带任何纸质打印资料的，一本简介明了的语言参考指南显得非常重要。</p><p>抛弃所有国内教科书，包括但不限于谭浩强，除非你想拿成绩开玩笑在考试的时候验证一下<code>int a++++</code>会不会报错。</p><p>在这里，只推荐<a href="https://item.jd.com/10057446.html" target="_blank" rel="external">K&amp;R The C Programming Language</a>小薄本。将 ANSI C 的所有内容都讲得很透彻而简洁，里面的习题也可以作为入门练手。</p><h1 id="能力层级"><a href="#能力层级" class="headerlink" title="能力层级"></a>能力层级</h1><p>这一部分提供平时训练刷题的参考方向。列举我在去年准备的时候看过的一些题型，具体知识和代码在<a href="https://item.jd.com/11399054.html" target="_blank" rel="external">王道机试指南</a>和<a href="https://item.jd.com/11469701.html" target="_blank" rel="external">算法竞赛入门经典</a>介绍的比较详尽。</p><h2 id="基本输入输出"><a href="#基本输入输出" class="headerlink" title="基本输入输出"></a>基本输入输出</h2><p>OJ 的输入输出风格可是能玩死不少人的，怎么保证循环接收输入，接收特定符号能退出，每一轮输入怎么界定，怎么输出小数点后三位浮点数，输出的时候删掉无谓信息（比如句子最后的致命空格），等等等等，都是值得关注的内容，也是首先要练习的。所幸 scanf 和 printf 函数在 KR 里面已经介绍得非常详尽，对照着看和练习就行。</p><h2 id="数字和数组处理"><a href="#数字和数组处理" class="headerlink" title="数字和数组处理"></a>数字和数组处理</h2><p>数字部分有点像小学数学的找规律填数，也会夹带私货弄些奇形怪状的浮点数处理，数组处理方面典型例子就是找最大最小数，找次小数，奇偶数分离这些。一般都在签到题出现。</p><h2 id="日期问题"><a href="#日期问题" class="headerlink" title="日期问题"></a>日期问题</h2><p>闰年问题，星期几问题等等。</p><h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><p>翻转字符串，回文字符串判断，甚至字符串匹配、简易正则表达式识别、字符串搜索都是有可能出现的，活用 std::string 和 char 数组的下标嗯。</p><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><p>图论的 D 算法 F 算法，深度优先搜索，矩阵乘法等等。这种基本都是最终 boss 级别，因为很多 ACM 资料都会有典型的算法题目，代码可以直接套用，改改关键变量就可以，所以称为模板题。</p><h2 id="特别提名：模拟题"><a href="#特别提名：模拟题" class="headerlink" title="特别提名：模拟题"></a>特别提名：模拟题</h2><p>模拟题，可不是模拟卷子，而是一类型模拟计算机内部操作比如进程调度，死锁识别等的题目，印象最深刻就是去年最后一题算进程完成时间的。</p><h1 id="思维方法"><a href="#思维方法" class="headerlink" title="思维方法"></a>思维方法</h1><p>这里介绍一些玄学的东西，也是机试对以后的开发生涯最有帮助的东西</p><h3 id="边界值控制和处理"><a href="#边界值控制和处理" class="headerlink" title="边界值控制和处理"></a>边界值控制和处理</h3><p>刚开始接触 OJ 的时候很容易会遇到本地编译没问题，提供的测试数据也能获得预期结果可是提交之后就是 WA 这种百思不得其解的问题，根源便在于边界值考虑不周全，比如整数0，范围的边界，字符串中的空串等等，解决之道便是通过大量的练习，对每个算法题首先花上几秒考虑可能的边界情况和特殊情况，久而久之形成严密的思维。</p><h3 id="时间性能"><a href="#时间性能" class="headerlink" title="时间性能"></a>时间性能</h3><p>1ms 的时间限制，看起来非常的充分，那只是还没遇到大规模输入。在那种几万甚至十万级别的数据（OJ 上真的会有），就算是$O(n^3)$的算法，翻车也是随时随地的。</p><p>应对这个问题，得对计算机内部执行过程有最基本的认识，更好一点的得对算法的时间复杂度有认识，优化起来才不会像无头苍蝇一样。</p><p>还是祭出<a href="https://item.jd.com/12006637.html" target="_blank" rel="external">CSAPP</a>，里面对程序优化的介绍比较详细，充分利用 Cache 可以编写更高效程序。</p><h4 id="奇技淫巧"><a href="#奇技淫巧" class="headerlink" title="奇技淫巧"></a>奇技淫巧</h4><p>这里特别提名位运算，关键时刻可以省下大量的时间。</p><p>安利<a href="https://item.jd.com/1092950325.html" target="_blank" rel="external">Hackers’ Delight</a></p><h2 id="基本的算法设计思想"><a href="#基本的算法设计思想" class="headerlink" title="基本的算法设计思想"></a>基本的算法设计思想</h2><p>递归，动态规划，不一而足，还是那句话，需要不断的刷题积累经验。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018考研的初试已经结束了，平时看考研群里已经有很多人在讨论在焦虑机试应该怎么复习，作为过来人在这里就随便说说自己的一些经验吧。&lt;/p&gt;
&lt;p&gt;实现说明一下，这篇文章基本就是个扫盲，不能保证你看完文章就能从 A0变 AK，但帮助你脱离新手区，扫除对机试的恐惧，保个底让机试不会成为复试阶段的软肋还是可以的。&lt;br&gt;
    
    </summary>
    
    
      <category term="BOJ" scheme="https://gawainx.github.io/tags/BOJ/"/>
    
  </entry>
  
  <entry>
    <title>linuxnv</title>
    <link href="https://gawainx.github.io/2017/12/06/linuxnv/"/>
    <id>https://gawainx.github.io/2017/12/06/linuxnv/</id>
    <published>2017-12-06T13:30:36.000Z</published>
    <updated>2018-05-24T08:59:19.424Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TensorFlow For Docker 初体验</title>
    <link href="https://gawainx.github.io/2017/12/06/dockertf/"/>
    <id>https://gawainx.github.io/2017/12/06/dockertf/</id>
    <published>2017-12-06T13:30:22.000Z</published>
    <updated>2018-05-24T08:59:19.436Z</updated>
    
    <content type="html"><![CDATA[<hr><p>TensorFlow 是一套开源的机器学习工具。一般来说只用 TensorFlow 的话配置运行环境什么的并没有特别坑的地方，但如果想用到 GPU 加速计算的话配置起来就要费好大一番力气了，还经常遇到各种版本不兼容、找不到依赖关系等问题，让人头疼。而 Docker 刚好是解决开源软件各种依赖关系的神物，NVIDIA 刚好又有工具能让容器用上 GPU 进行计算。</p><p>下面分享配置过程。</p><p>测试环境是 GTX850M+Ubuntu16.04.3+CUDA9.0+GeForce 384.00</p><p>驱动及 CUDA 安装过程参考即将到来的另一篇文章。</p><a id="more"></a><h1 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h1><p>可以用<code>curl -sSL https://get.daocloud.io/docker | sh</code>这条命令快速安装 Docker，不过，这个安装脚本默认会安装最新版本的 Docker（当前是17.11.0 docker-ce），而 NVIDIA Docker 并不支持这个新版本（跪</p><p>所以要进行一下卸载再降级操作…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># uninstall docker</div><div class="line">sudo apt-get purge docker-ce</div><div class="line"># 查看软件库中可用的历史版本</div><div class="line">sudo apt-cache policy docker-ce</div><div class="line"># install docker-ce 17.09</div><div class="line">sudo apt-get install -y docker-ce=17.09.0~ce-0~ubuntu</div></pre></td></tr></table></figure><p>值得一提的是17年的某个版本开始，docker 的软件包统一到 docker-ce（社区）和 docker-ee（付费企业版）上面来了，开发使用的主要以 docker-ce 为主，网上很多教程（尤其是2016年、2016年的）说到安装 docker 的软件包名叫例如 lxc-docker docker.io 等的都是老旧版本的。</p><h1 id="安装-NVIDIA-docker"><a href="#安装-NVIDIA-docker" class="headerlink" title="安装 NVIDIA-docker"></a>安装 NVIDIA-docker</h1><p><a href="https://github.com/NVIDIA/nvidia-docker" target="_blank" rel="external">Nvidia-Docker</a>是老黄提供的一套在 Docker 上制造跑核弹的工具（。</p><p>简单来说，这套工具提供了一个运行时，用来连接 Docker 容器和物理设备的 GPU 资源，使得 Docker 容器可以直接访问、调用物理机的 GPU 资源进行密集型计算操作。</p><p>安装步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># Add the package repositories 添加软件仓库</div><div class="line">curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | \</div><div class="line">  sudo apt-key add -</div><div class="line">curl -s -L https://nvidia.github.io/nvidia-docker/ubuntu16.04/amd64/nvidia-docker.list | \</div><div class="line">  sudo tee /etc/apt/sources.list.d/nvidia-docker.list</div><div class="line">sudo apt-get update</div><div class="line"></div><div class="line"># Install nvidia-docker2 and reload the Docker daemon configuration</div><div class="line">sudo apt-get install -y nvidia-docker2</div><div class="line">sudo pkill -SIGHUP dockerd</div><div class="line"></div><div class="line"># Test nvidia-smi with the latest official CUDA image</div><div class="line">docker run --runtime=nvidia --rm nvidia/cuda nvidia-smi</div></pre></td></tr></table></figure><p>在 Ubuntu16.04测试通过。</p><h1 id="安装-TensorFlow-的-Docker-镜像"><a href="#安装-TensorFlow-的-Docker-镜像" class="headerlink" title="安装 TensorFlow 的 Docker 镜像"></a>安装 TensorFlow 的 Docker 镜像</h1><p>TensorFlow 官方提供了 for Docker 的镜像，里面集成了完整的依赖关系，免去了用<code>pip</code>安装各种包的烦恼。</p><p>镜像包含很多 tag，常用的有下面几个：</p><ul><li>tensorflow/tensorflow:latest，运行环境是 python2.7，仅支持 CPU</li><li>tensorflow/tensorflow:latest-gpu，运行环境是 python2.7，支持 GPU 计算</li><li>tensorflow/tensorflow:latest-py3，运行环境是 python3.5，仅支持 CPU</li><li>tensorflow/tensorflow:latest-gpu-py3，运行环境是 python2.7，支持 调用GPU</li></ul><p>我自己用的是最后一个。</p><p>首先下载镜像下来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull tensorflow/tensorflow:latest-gpu-py3</div></pre></td></tr></table></figure><p>然后跑个 python3交互环境试试水</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --runtime=nvidia --rm -it tensorflow/tensorflow:latest-gpu-py3 python3</div></pre></td></tr></table></figure><p>在交互环境下输入<code>import tensorflow as tf</code>，如果没提示依赖库错误则说明安装成功。</p><p>上面的<code>—runtime=nvidia</code>为调用 nvidia-docker 工具包（运行时）而不是标准运行时来运行镜像，只有加了这个选项才能调用 GPU。</p><p>最后跑一下多重感知机训练手写数字识别，效果图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7xpabg.com1.z0.glb.clouddn.com/20171206222913_Q4dNYH_Snip20171206_3.jpeg" alt="多重感知机训练手写数字识别模型" title="">                </div>                <div class="image-caption">多重感知机训练手写数字识别模型</div>            </figure><p>输出显示调用 GPU:0进行计算，说明配置一路顺风了。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;TensorFlow 是一套开源的机器学习工具。一般来说只用 TensorFlow 的话配置运行环境什么的并没有特别坑的地方，但如果想用到 GPU 加速计算的话配置起来就要费好大一番力气了，还经常遇到各种版本不兼容、找不到依赖关系等问题，让人头疼。而 Docker 刚好是解决开源软件各种依赖关系的神物，NVIDIA 刚好又有工具能让容器用上 GPU 进行计算。&lt;/p&gt;
&lt;p&gt;下面分享配置过程。&lt;/p&gt;
&lt;p&gt;测试环境是 GTX850M+Ubuntu16.04.3+CUDA9.0+GeForce 384.00&lt;/p&gt;
&lt;p&gt;驱动及 CUDA 安装过程参考即将到来的另一篇文章。&lt;/p&gt;
    
    </summary>
    
    
      <category term="TensorFlow" scheme="https://gawainx.github.io/tags/TensorFlow/"/>
    
      <category term="Docker" scheme="https://gawainx.github.io/tags/Docker/"/>
    
      <category term="ML" scheme="https://gawainx.github.io/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>最大概率汉语切分算法研究-(0)-概览</title>
    <link href="https://gawainx.github.io/2017/11/27/mpseg0/"/>
    <id>https://gawainx.github.io/2017/11/27/mpseg0/</id>
    <published>2017-11-27T13:48:13.000Z</published>
    <updated>2018-05-24T08:59:19.437Z</updated>
    
    <content type="html"><![CDATA[<p>最近忙活了将近一个多月总算把计算语言学布置的最大概率汉语切分作业写完了，虽然中途一波三折，还发生了很多五光十色奇形怪状让人难忘的事情，所幸最后还是比较完整的写了出来，也学到了不少的知识。因此便有了这个系列的文章。</p><p>在这篇给出这系列文章的导航帖汇总。<br><a id="more"></a></p><p>至于代码嘛，等交完实验报告再说嗯。。</p><p><a href="http://antarx.com/2017/11/25/mpseg1/">最大概率汉语切分算法研究（一）词典构建</a></p><p><a href="http://antarx.com/2017/11/25/mpseg2/">最大概率汉语切分算法研究（二）BiGram语言模型</a></p><p><a href="http://antarx.com/2017/11/25/mpseg3/">最大概率汉语切分算法研究（三）有向无环图（DAG）与最优左近邻词</a></p><p><a href="http://antarx.com/2017/11/25/mpseg4/">最大概率汉语切分算法研究(四）FMM 与 BMM 在分词中的应用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近忙活了将近一个多月总算把计算语言学布置的最大概率汉语切分作业写完了，虽然中途一波三折，还发生了很多五光十色奇形怪状让人难忘的事情，所幸最后还是比较完整的写了出来，也学到了不少的知识。因此便有了这个系列的文章。&lt;/p&gt;
&lt;p&gt;在这篇给出这系列文章的导航帖汇总。&lt;br&gt;
    
    </summary>
    
    
      <category term="NLP" scheme="https://gawainx.github.io/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>最大概率汉语切分算法研究(四）FMM 与 BMM 在分词中的应用</title>
    <link href="https://gawainx.github.io/2017/11/25/mpseg4/"/>
    <id>https://gawainx.github.io/2017/11/25/mpseg4/</id>
    <published>2017-11-25T10:04:43.000Z</published>
    <updated>2018-05-24T08:59:19.435Z</updated>
    
    <content type="html"><![CDATA[<p>本篇继续讨论对输入句子的处理问题。FMM 和 BMM 是指对输入句子分别找前向最长词和后向最长词，某种程度上来说属于贪心算法的一种，比较惊喜的地方是两者结合常常能获得比较不错的分词效果。<br><a id="more"></a></p><h1 id="FMM"><a href="#FMM" class="headerlink" title="FMM"></a>FMM</h1><p>FMM，可以理解成前向（Forward）最长词，就是对一个句子，每次切分找词的时候，都是从前往后“切出”最长的词和剩下的子句，例如：</p><p>“<strong>有意见分歧</strong>”这句话，用 FMM 进行切分找第一个词的时候就会切分成：</p><p><strong>有意/见分歧</strong></p><p>只利用 FMM 进行分词时，对每次切分后的子句都反复寻找最长前缀词，直到子句为空。注意到，FMM 得到的切分序列是唯一的。</p><h1 id="BMM"><a href="#BMM" class="headerlink" title="BMM"></a>BMM</h1><p>BMM，可以理解成后向（Backward）最长词，就是对一个句子进行切分的时候，都是从后往前“切出”最长词和剩下的子句，例如</p><p>“有意见分歧”这句话，用 BMM 切分的时候会分成：</p><p><strong>有意见/分歧</strong></p><p>其中，“分歧”是寻找到的“第一个词”，“有意见”是待切分的子句。</p><p>用 BMM 分词的时候，对每次切分后的子句都反复寻找最长后缀词，直到句子为空。</p><h1 id="FMM-与-BMM-组合分词"><a href="#FMM-与-BMM-组合分词" class="headerlink" title="FMM 与 BMM 组合分词"></a>FMM 与 BMM 组合分词</h1><p>只用 FMM 或 BMM 进行分词的话，由于算法本身“贪心”的属性，往往得不到最理想的切分结果。所以在进行汉语切分的时候，可以将两个算法结合使用，用于发现歧义（因为对于没有歧义的句子，FMM 和 BMM 得到的切分结果一定是一致的），也可以将两个算法得到的序列计算整句话的概率（利用 BiGram 模型），选取概率较大者作为最终的切分结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇继续讨论对输入句子的处理问题。FMM 和 BMM 是指对输入句子分别找前向最长词和后向最长词，某种程度上来说属于贪心算法的一种，比较惊喜的地方是两者结合常常能获得比较不错的分词效果。&lt;br&gt;
    
    </summary>
    
    
      <category term="NLP" scheme="https://gawainx.github.io/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>最大概率汉语切分算法研究（三）有向无环图（DAG）与最优左近邻词</title>
    <link href="https://gawainx.github.io/2017/11/25/mpseg3/"/>
    <id>https://gawainx.github.io/2017/11/25/mpseg3/</id>
    <published>2017-11-25T08:51:09.000Z</published>
    <updated>2018-05-24T08:59:19.414Z</updated>
    
    <content type="html"><![CDATA[<p>本篇讨论的是对特定输入句子进行的处理过程。基本思想是对特定输入句子从前往后遍历找出所有词构成有向无环图，然后从最后一个词开始往前找每个词的“最优左近邻词”构成一个完整的词语序列。</p><a id="more"></a><h1 id="DAG"><a href="#DAG" class="headerlink" title="DAG"></a>DAG</h1><p>DAG，也就是有向无环图，可以用来记录一个句子的不同的切分状态集合，所谓的“向”就是句子从开始到结束的方向。假定句子的开始符为<code>S</code>，以“他们有意见分歧”这个句子为例，可以得到如下的有向无环图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7xpabg.com1.z0.glb.clouddn.com/20171126213424_4TTd1D_Screenshot.jpeg" alt="有向无环图例子" title="">                </div>                <div class="image-caption">有向无环图例子</div>            </figure><p>在生成一个句子的有向无环图的过程中，利用 BiGram 模型计算所有的转移概率并进行储存。</p><p>之后，从后往前回溯，寻找每个词的最优左近邻词，直到‘S’字符。结束。</p><h2 id="从句子生成-DAG"><a href="#从句子生成-DAG" class="headerlink" title="从句子生成 DAG"></a>从句子生成 DAG</h2><p>假设开始标识符为‘S’。</p><p>对于特定的一条输入句子<strong>sentence</strong>，原始问题可以理解成：由<code>sentence</code>和其前一个词‘S’构建有向无环图。</p><p>对 <strong>sentence</strong>进行分词操作，假设找到的第一个词为<strong>firstWord</strong>，输入句子 <strong>sentence</strong>便可切分为 <strong>firstWord</strong> + <strong>subsentence</strong>两部分，其中<strong>firstWord</strong>作为 <strong>subsentence</strong>的“前一个词”。原始问题便可归约为由<strong>firstWord</strong> 和 <strong>subsentence</strong>构建有向无环图（构建结果作为最终 DAG 的子图）。</p><p>根据上面的分析，构建完整DAG 的过程是一个递归求解的过程，完整的算法步骤描述如下（简记为 <code>Alg-1</code>)：</p><ol><li>输入句子 <strong>sentence</strong></li><li>以开始标记符“S”和 <strong>sentence</strong> 开始构建 DAG。（“S”作为整个图的开始结点，“源”点）</li><li>对 <strong>sentence</strong>从前往后找“第一个词”（<strong>firstWord</strong>），找到第一个词后，将 <strong>sentence</strong>划分为 <strong>firstWord</strong> 和 <strong>subsentence</strong>两部分。<strong>firstWord</strong>即可作为最终 DAG 的一个结点。</li><li>对 <strong>subsentence</strong>重复第三步的切分操作（寻找第一个词和子句），找到的“第一个词”作为最终 DAG 的结点，对子句继续切分（递归）。</li><li>递归结束条件：子句为空。</li><li>结束时，将所有最后一个词放入 endSet（结束词集合）里。</li></ol><p>在 <strong>Alg-1</strong>的步骤3中要寻找“第一个词”，要注意的是，这个寻找过程不是一次性的，因为“第一个词”可能有多种情况，譬如，“有意见分歧”这句话中，对于第一个词，存在着 有/意见分歧 和 有意/见分歧 这两种潜在可能的划分，需要一并进行考虑。因此，寻找词的过程是一个循环的过程，设定上限值为15（汉语中基本不存在长度超过15的词），从第一个字开始向前寻找（切片）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">15</span>):</div><div class="line">    word = sentence[:k]</div></pre></td></tr></table></figure><p>如果“切”出来的 <strong>word</strong>在词典中，则作为一个子问题，这样才能保证最后生成的 DAG 是考虑了所有可能情况的（考虑了所有的歧义）。</p><p>不过，这个“粗暴”的切分方式也存在着可见的缺陷。它会大幅度增大了有向无环图的规模（最坏情况下，所有的单字都作为图的一个结点）。对于长句子来说会极大的增大了生成时间，而且，这里用递归来生成子图，因此甚至存在递归过深导致堆栈溢出等问题，即使不是这样，也会显著的增加了程序运行时间。</p><h2 id="减少无用递归"><a href="#减少无用递归" class="headerlink" title="减少无用递归"></a>减少无用递归</h2><p>经过多次痛苦的测试过程，摸索出减少无用递归的方法可以短暂缓解上面提到的缺陷。</p><p>考虑如下句子：</p><blockquote><p>因为他们有意见分歧，会议的时间未能确定下来。</p></blockquote><p>虽然在中文语义上，可以以逗号为分隔直接划分成两个子问题再进行切分生成 DAG，但在计算机中还是视为一个句子进行处理。</p><p>在“有意见分歧，”这里，存在至少两种切分：</p><p>有/意见分歧 和 有意/见分歧</p><p>无论这个子句如何切分，切分之后的两个子句</p><blockquote><p>意见分歧，···</p><p>见分歧，···</p></blockquote><p>除了第一个词之外都是重叠的，生成的子图也是一样的，无需重复的递归进行处理。</p><p>基于这种分析，在考虑生成 DAG 函数的关键参数：<code>firstWord</code>和 <code>subsentence</code>，将这两个参数构成一个元组（tuple），用一个集合记录下已经进行了“子图生成”的元组，每次要执行递归前，首先判断关键参数组合是否在集合中，如果在集合中则直接跳过，否则再执行递归过程，执行完毕后将关键参数组合添加到集合中。</p><h1 id="最优左近邻词（bLAW）"><a href="#最优左近邻词（bLAW）" class="headerlink" title="最优左近邻词（bLAW）"></a>最优左近邻词（bLAW）</h1><p>考虑词序列</p><p>$$w_1,w_2,w<em>3,…,w</em>{i-1},w_i,…,w_n$$</p><p>$w_{i-1}$即为$w_i$的左近邻词。</p><p>用输入句子生成 DAG 之后，对结束词集合中的每一个词，从后往前回溯，寻找每一个词的最优左近邻词，直到“S”结束，得到潜在的切分序列。如果切分序列不止一个的时候，则计算每个切分句子的概率，取概率较大者作为切分结果序列。</p><h3 id="如何寻找最优左近邻词？"><a href="#如何寻找最优左近邻词？" class="headerlink" title="如何寻找最优左近邻词？"></a>如何寻找最优左近邻词？</h3><p>考虑累计概率计算公式：</p><p>$$P_a(w_i)=P<em>a (w</em>{i-1})*P(w<em>i/w</em>{i-1})$$</p><p>对每一个左近邻词（在 DAG 中表示为一个结点的所有前向相邻结点），计算累积概率，取概率较大者作为最优左近邻词。</p><h1 id="潜在问题"><a href="#潜在问题" class="headerlink" title="潜在问题"></a>潜在问题</h1><p>以下潜在问题的讨论仅限于本文讨论的 DAG 和寻找左近邻词的算法，并不一定 LAW 这个概念本身可能存在的问题。</p><ol><li>“最优”只考虑了局部的情况，在语料库生成的搭配词典规模受到限制的场合，基于语料库训练出来的 BiGram 模型计算出来的累积概率与实际应用场景中“本该有”的概率存在较大差异，这种差异将直接反映在切分结果上。</li><li>生成 DAG 的过程以词本身而不是词在句子中的下标序号作为图的结点，对于一个存在重复词的句子，从后往前找左近邻词时可能进入死循环中。解决办法是每次寻找词的时候将这个词与它“本该”出现在句子中的位置进行比较再决定是不是 LAW</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://www.voidcn.com/article/p-gnpklsla-sp.html" target="_blank" rel="external">jieba中文分词源码分析（三）</a></li><li>王小捷老师计算语言学课程相关课件资料</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇讨论的是对特定输入句子进行的处理过程。基本思想是对特定输入句子从前往后遍历找出所有词构成有向无环图，然后从最后一个词开始往前找每个词的“最优左近邻词”构成一个完整的词语序列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://gawainx.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="NLP" scheme="https://gawainx.github.io/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>最大概率汉语切分算法研究（二）BiGram语言模型</title>
    <link href="https://gawainx.github.io/2017/11/25/mpseg2/"/>
    <id>https://gawainx.github.io/2017/11/25/mpseg2/</id>
    <published>2017-11-25T08:51:06.000Z</published>
    <updated>2018-05-24T08:59:19.418Z</updated>
    
    <content type="html"><![CDATA[<p>BiGram 语言模型，也就是二元语法模型，起源于 NGram，属于 N = 2的情况。基本思想是当前词依赖于仅前一个词的出现概率。</p><a id="more"></a><h1 id="模型简介"><a href="#模型简介" class="headerlink" title="模型简介"></a>模型简介</h1><p>N 元语法模型属于概率模型的一种。在 Ngram 语言模型的概念里，我们假设当前词出现的概率依赖于前面<code>N-1</code>个单词。</p><h2 id="概率推导"><a href="#概率推导" class="headerlink" title="概率推导"></a>概率推导</h2><p>假设有单词序列$w_1,w_2,…,w_n$,将每个单词在它本身位置的出现看成一个独立事件，则这个单词串出现的概率可以表示为$P(w_1,w_2,…,w_n)$</p><p>一般情况下将这个单词序列简记为$w_1^n$，由概率的链式分解规则，有</p><p>$P(w_1^n) = P(w_1)P(w_2|w_1)P(w_3|w_1^2)···P(w_n|w_1^{n-1})$</p><p>在概率推导公式中，令$n=2$，式子可以简化为$P(w_1^n)=P(w<em>n|w</em>{n-1})$</p><h2 id="说人话？？？"><a href="#说人话？？？" class="headerlink" title="说人话？？？"></a>说人话？？？</h2><p>上面的概率推导很容易让人一头雾水，以“我喜欢你”这个句子为例，“我喜欢你”这个句子出现的概率，可以转化成“我喜欢”这个子句后面出现“你”这个词的概率，在二元语法模型中，就可以进一步等价成“喜欢”这个词后面出现“你”的概率。</p><p>也就是说，二元语法模型，将一句话出现的可能性，转化成一系列词语搭配出现的可能性。</p><h1 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h1><p>由频率估计概率的方法，对于给定的语料库，不难得出如下公式：</p><p>$P(w<em>n|w</em>{n-1})=\frac{C(w_{n-1}w_n)}{C(w_n)}$</p><p>还是以“喜欢你”这个句子为例，可以得到：</p><p>$P(你|喜欢)=\frac{“喜欢你”这个搭配在语料库中的出现次数}{所有以“喜欢”开头的双词搭配总数}$</p><p>因此，训练的目标就是对于给定的语料库和词典，统计整个语料库中的所有双词搭配和对于具体的每一个词，统计以该词开头的所有双词搭配数目。也就是一个数数的过程。</p><h1 id="平滑技术"><a href="#平滑技术" class="headerlink" title="平滑技术"></a>平滑技术</h1><p>上面提及的 N 元语法的问题在于“数数”这个过程对语料库是强依赖的，而每个特定的语料库都是有限的，肯定无法覆盖汉语中出现的所有双词搭配。所以便有了平滑技术，为“零概率的二元语法”指派非零概率，也就是在计数后进行概率转换之前为计数为0的指派一个非零的计数值。</p><p>在这里使用了最简单的加一平滑，在二元计数矩阵中，归一化计算概率之前为所有的计数加一。</p><h1 id="计算机编程实现"><a href="#计算机编程实现" class="headerlink" title="计算机编程实现"></a>计算机编程实现</h1><h2 id="模型表示"><a href="#模型表示" class="headerlink" title="模型表示"></a>模型表示</h2><p>在开发分词工具中，采用了 pandas 库提供的 DataFrame 这个二维的数据接口来表示整个模型，<code>index</code>部分是词典中的每一个词，<code>col</code>部分包含了两列，第一列是每个词出现的总数，第二列以字典类型来表示每个词所有可能的“下一个词”和对应出现次数。</p><h3 id="平滑技术的处理"><a href="#平滑技术的处理" class="headerlink" title="平滑技术的处理"></a>平滑技术的处理</h3><p>假设词典里面有 $m$个词，按照上面的描述，需要一个$m \times m$的矩阵来作为二元语法矩阵，加一平滑的时候遍历整个矩阵为每个元素加一。然而，从199801这个语料库中统计出来的词个数已经高达50000+，加载这么高维度的矩阵对于普通计算机来说显然是一笔很大的消耗。</p><p>而在这个模型表示中，只储存了所有出现过的“双词”搭配，将对未出现的搭配“赋值为1”的过程放在了概率计算部分，加快了模型的加载速度。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://book.douban.com/subject/1390499/" target="_blank" rel="external">JMBook-自然语言处理综论</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;BiGram 语言模型，也就是二元语法模型，起源于 NGram，属于 N = 2的情况。基本思想是当前词依赖于仅前一个词的出现概率。&lt;/p&gt;
    
    </summary>
    
    
      <category term="NLP" scheme="https://gawainx.github.io/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>最大概率汉语切分算法研究（一）词典构建</title>
    <link href="https://gawainx.github.io/2017/11/25/mpseg1/"/>
    <id>https://gawainx.github.io/2017/11/25/mpseg1/</id>
    <published>2017-11-25T08:51:02.000Z</published>
    <updated>2018-05-24T08:59:19.431Z</updated>
    
    <content type="html"><![CDATA[<p>最近忙活了将近一个多月总算把计算语言学布置的最大概率汉语切分作业写完了，虽然中途一波三折，还发生了很多让人难忘的事情，所幸最后还是比较完整的写了出来，也学到了不少的知识。因此便有了这个系列的文章。</p><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>基于最大概率的汉语切分工具的开发，是要利用计算语言学课上学到的知识，选用合适的模型开发一个汉语分词的工具并且进行代码测试与评估。</p><h1 id="阶段划分"><a href="#阶段划分" class="headerlink" title="阶段划分"></a>阶段划分</h1><p>一个完整的分词工具的开发包括以下几个步骤：</p><ol><li>选择合适的语料库</li><li>根据语料库构建词典</li><li>选择合适的分词模型和平滑技术</li><li>语料库切分：训练集和测试集</li><li>模型训练</li><li>模型测试，包括分词技术调整等，增强代码健壮性</li></ol><p>在本项目中选用的语料库是人民日报199801的语料库，分词模型选择2-gram 模型，平滑技术选用了最简单易行的加一平滑，分词技术包括了左近邻词，FMM 和 BMM 等，具体在接下来涉及到了再具体谈。</p><p>本文主要讨论的是从语料库构建词典的问题。</p><h1 id="TrieTree与词典"><a href="#TrieTree与词典" class="headerlink" title="TrieTree与词典"></a>TrieTree与词典</h1><p><a href="https://baike.baidu.com/item/Trie/140945?fr=aladdin" target="_blank" rel="external">TrieTree</a>，又名前缀词典树，是一个专门用于构建词典的数据结构，在这个数据结构上实现词语的添加和查找都可以获得非常高的效率。</p><h2 id="TrieTree-的-python-实现"><a href="#TrieTree-的-python-实现" class="headerlink" title="TrieTree 的 python 实现"></a>TrieTree 的 python 实现</h2><p>在<a href="https://www.zhihu.com/question/21610353" target="_blank" rel="external">知乎的一个回答</a>有非常简短的代码可以实现 TrieTree 的添加和查找功能，不过在这里要用 Trie 树构建词典的话还需要小小的修改，将该回答中叶子节点的’Exist’字段替换成’count’，用于统计每个词在语料库中出现的次数，每次添加一个词的时候，为后面的概率计算作铺垫。</p><h2 id="语料库分析"><a href="#语料库分析" class="headerlink" title="语料库分析"></a>语料库分析</h2><p>人民日报199801的语料库中，对于每一个词都是像<code>泽民/nr</code>这种形式，以<code>/</code>分割，前半部分为词，后半部分为该词的词性，词之间用两个空格进行分割。构建词典的时候，便可以读取语料库文件的每一行，用<code>split()</code>方法分割得到词列表，在每个词中再次执行分割获取每个词，添加到 Trie 树中，每次添加的时候首先进行判断，如果该词已经在树上，那么将该词的’ count’字段计数加一，否则，将词加入到词典树中，并将计数字段设为1。</p><h2 id="词典写入到文件"><a href="#词典写入到文件" class="headerlink" title="词典写入到文件"></a>词典写入到文件</h2><p>将词典写入到文件，其实就是遍历 Trie 树，每个包含‘count’键的节点对应于一个词，将这些词写入到文件中的过程。具体代码参考如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foreachTree</span><span class="params">(TTree,string,file)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="string">'freq'</span> <span class="keyword">in</span> TTree :</div><div class="line">        <span class="keyword">if</span> len(TTree) == <span class="number">1</span>:</div><div class="line">            print(string+<span class="string">' '</span>+str(TTree[<span class="string">'freq'</span>]),file=file)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            print(string+<span class="string">' '</span>+str(TTree[<span class="string">'freq'</span>]),file=file)</div><div class="line">            <span class="keyword">for</span> kk <span class="keyword">in</span> TTree:</div><div class="line">                <span class="keyword">if</span> kk == <span class="string">'freq'</span>:</div><div class="line">                    <span class="keyword">pass</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                  foreachTree(TTree[kk],string+kk,file)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">for</span> kk <span class="keyword">in</span> TTree:</div><div class="line">            foreachTree(TTree[kk],string+kk,file)</div></pre></td></tr></table></figure><p>对于树这种递归定义的数据结构，解决问题的最方便的方法自然也是递归，由于汉语词汇挂在“树”上的时候，每个节点都是单个“字”，因此需要一个 String 变量作为函数参数，记录前面的遍历状态。</p><p>要注意的地方是判断是否是完整词语的条件是‘count’或者‘freq’是否在该节点对应的字典中，而不是是否为‘叶子节点’。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近忙活了将近一个多月总算把计算语言学布置的最大概率汉语切分作业写完了，虽然中途一波三折，还发生了很多让人难忘的事情，所幸最后还是比较完整的写了出来，也学到了不少的知识。因此便有了这个系列的文章。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://gawainx.github.io/tags/Python/"/>
    
      <category term="NLP" scheme="https://gawainx.github.io/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>macOS 配置 libsvm for Python</title>
    <link href="https://gawainx.github.io/2017/11/22/macsvm/"/>
    <id>https://gawainx.github.io/2017/11/22/macsvm/</id>
    <published>2017-11-22T07:18:29.000Z</published>
    <updated>2018-05-24T08:59:19.415Z</updated>
    
    <content type="html"><![CDATA[<p>libsvm是一个高性能的 svm（支持向量机）实现，与 TensorFlow 这些非常热门的机器学习框架不同的地方在于它提供的是可执行文件、类库和针对不同编程语言的接口， 在 macOS 上配置这套接口的时候经常会出现一些奇奇怪怪的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;libsvm是一个高性能的 svm（支持向量机）实现，与 TensorFlow 这些非常热门的机器学习框架不同的地方在于它提供的是可执行文件、类库和针对不同编程语言的接口， 在 macOS 上配置这套接口的时候经常会出现一些奇奇怪怪的问题。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="ML" scheme="https://gawainx.github.io/tags/ML/"/>
    
      <category term="macOS" scheme="https://gawainx.github.io/tags/macOS/"/>
    
      <category term="libsvm" scheme="https://gawainx.github.io/tags/libsvm/"/>
    
  </entry>
  
  <entry>
    <title>Javalin框架使用指南(2)</title>
    <link href="https://gawainx.github.io/2017/10/28/javalin2/"/>
    <id>https://gawainx.github.io/2017/10/28/javalin2/</id>
    <published>2017-10-28T12:15:17.000Z</published>
    <updated>2018-05-24T08:59:19.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>WebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。</p></blockquote><p>最近在项目中需要开发响应 WebSocket 的服务器程序来实现向客户端推送视频流的功能，刚好 Javalin 在最新版本中已经添加了对 WebSocket 的基本支持，于是有了这篇文章。<br><a id="more"></a></p><h1 id="依赖关系配置（基于-Maven）"><a href="#依赖关系配置（基于-Maven）" class="headerlink" title="依赖关系配置（基于 Maven）"></a>依赖关系配置（基于 Maven）</h1><p>和前面一样，使用 Maven 作为项目的包管理工具。要使 Javalin 框架的应用程序完整支持 WebSocket，需要额外添加以下的依赖关系包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>websocket-servlet<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.4.7.v20170914<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>websocket-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.4.7.v20170914<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>websocket-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.4.7.v20170914<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>websocket-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.4.7.v20170914<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><p>为了避免一些千奇百怪的类、方法错误，建议加入的 jetty 依赖包的版本尽量保持严格一直（然而在目前的开发中还是遇到了奇奇怪怪的方法缺失错误，虽然不影响正常的运行不过看着还是蛮闹心的Orz）</p><h1 id="四个基本方法"><a href="#四个基本方法" class="headerlink" title="四个基本方法"></a>四个基本方法</h1><p>和前面介绍的一样，Javalin 主要还是通过 lamada 表达式的方式来实现对特定路径的 WebSocket响应，基本的代码架构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">app.ws(<span class="string">"/path"</span>,ws -&gt;&#123;</div><div class="line">  ws.onConnect(session -&gt; &#123;</div><div class="line">        <span class="comment">//do something</span></div><div class="line">    &#125;);</div><div class="line">  ws.onMessage((session,message) -&gt; &#123;</div><div class="line">      </div><div class="line">  &#125;);</div><div class="line">  ws.onClose(<span class="comment">/*insert you lamada expr*/</span>);</div><div class="line">  ws.onError(<span class="comment">/*insert you lamada expr*/</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>四个以<code>on</code>开头的方法是实现 WebSocket 基本功能的方法，每个方法的基本含义如下：</p><ul><li><code>onConnect( session)</code>用于处理客户端与服务器端的连接事件，用<code>session</code>来指代服务器端与具体某个客户端的连接本身。<code>session</code>中有个<code>getRemoteEndpoint()</code>的方法可以获取表征客户端的“端点”一类的东西，通过这个“端点”，可以随时“主动”的向客户端发送数据。这也是 WebSocket 的优势和魅力所在（一旦建立连接之后，服务器端可以根据具体情况随时主动的向客户端推送信息）。</li><li><code>onMessage(session,message)</code>用于处理收到客户端信息时候的响应，session 的基本含义同上，message 表示来自客户端的信息。</li><li><code>onClose()</code>用于处理连接关闭时的事件。</li><li><code>onError()</code>用于发生错误时的响应。</li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>Javalin 当中对于 WebSocket 的实现，主要是建基于 jetty 对 WebSocket 的支持的基础上进行了二次封装，所以，Javalin目前不支持的一些方法、操作等都可以单独引用 jetty 提供的方法进行实现，只是这时候更加要注意依赖关系等问题了。</p><p>除了绑定 lamada 表达式之外，<code>app.ws()</code>方法也可以将特定路径和实现了 WebSocket 响应的具体的类进行绑定，不过这个我还没有尝试过，理论上来说用起来会更加灵活，以后如果用到了也会写后续文章跟大家分享使用经验。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;WebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近在项目中需要开发响应 WebSocket 的服务器程序来实现向客户端推送视频流的功能，刚好 Javalin 在最新版本中已经添加了对 WebSocket 的基本支持，于是有了这篇文章。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://gawainx.github.io/tags/Java/"/>
    
      <category term="Javalin" scheme="https://gawainx.github.io/tags/Javalin/"/>
    
      <category term="WebSocket" scheme="https://gawainx.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>Javalin 框架使用指南（一）</title>
    <link href="https://gawainx.github.io/2017/10/24/javalin1/"/>
    <id>https://gawainx.github.io/2017/10/24/javalin1/</id>
    <published>2017-10-24T06:28:20.000Z</published>
    <updated>2018-05-24T08:59:19.416Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://javalin.io/" target="_blank" rel="external">Javalin</a>是一款建基于 jetty 的轻量级 RESTful 框架，支援 Java 和 Kotlin 编程语言，非常适合用来部署REST 风格的微服务程序，因为里面对 lamada 表达式的应用可以说是到了出神入化的地步，所以一直都是我最喜欢用的框架。这系列的文章主要是介绍如何在微服务开发中应用这套框架来进行开发。<br><a id="more"></a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Javalin 支持几乎所有常见的项目管理工具，出于一般性，文章中以 Maven 为例进行说明。</p><p>安装框架本体</p><p>在项目的 pom.xml文件中的<code>&lt;dependencies&gt;&lt;/dependencies&gt;</code>标签下粘贴以下代码。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.javalin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javalin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><p>这是官网中介绍的安装方法，要注意到，仅仅粘贴了以上代码段的话，会遇到两个问题：</p><ol><li><p>maven 默认的 JVM 环境是 JDK1.6，是不支持 Lamada 表达式这种尤物的，我们需要在项目中添加 Java8支持。</p><p>在<code>pom.xml</code>中粘贴以下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></div></pre></td></tr></table></figure><p>要注意到这段代码和<code>&lt;dependencies&gt;&lt;/dependencies&gt;</code>标签段是并行而不是包含关系的。</p></li><li><p>在运行过程中可能会遇到以下错误提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.SLF4J: Defaulting to no-operation (NOP) logger implementationSLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.</div></pre></td></tr></table></figure><p>​</p><p>​</p></li></ol><p>虽然这个错误提示不会影响程序的正常运行，但强迫症总是让人不爽，解决方法是添加这个依赖关系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-simple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><p>经过以上配置之后，就可以跑起第一段程序了</p><h1 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h1><p><code>HelloWorld</code> 是开发者学习新的编程语言、框架所绕不过去的坎，用 Javalin 开发一个 GET 方法访问根路径返回“helloworld”的 REST 服务器非常的简单。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> io.javalin.Javalin;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Javalin app = Javalin.start(<span class="number">7000</span>);</div><div class="line">        app.get(<span class="string">"/"</span>, ctx -&gt; ctx.result(<span class="string">"Hello World"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从代码中可以看出，通过一个 lamada 表达式就可以完成指定路径到具体响应方法的绑定操作，还有什么比这个更让 RESTful 微服务开发者拍手称快的呢。</p><p>简单说明一下，框架中用 Javalin 类型的一个对象实例来完成整个 RESTful 风格的服务器的全部操作。上述代码中，首先是实例化了一个名为<code>app</code>的 Javalin类型实体，然后调用了<code>get(String path, lamada expression)</code>，以 lamada 表达式的表示一个具体的响应操作，以字符串的形式表示具体的路径，将两者绑定到一体。方法名称<code>get</code>表示响应 REST 规范中的 GET 请求。</p><p>此外，<code>ctx</code>参数指代的是连接上下文，调用<code>result()</code>方法可以将字符串塞进响应体中进行返回。</p><h1 id="MORE"><a href="#MORE" class="headerlink" title="MORE"></a>MORE</h1><p>Javalin 框架的安装和第一个服务器程序都可以非常简便的就完成了，但这只是一个开始，通过 Javalin 框架可以完成非常复杂的响应逻辑，而且最近的更新版本中还加入了对 WebSocket 服务器的支持。接下来的文章将会介绍如何进行进一步的开发和遇到的常见问题等。</p><p><strong>1024</strong>节日快乐:halloween:</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://javalin.io/&quot;&gt;Javalin&lt;/a&gt;是一款建基于 jetty 的轻量级 RESTful 框架，支援 Java 和 Kotlin 编程语言，非常适合用来部署REST 风格的微服务程序，因为里面对 lamada 表达式的应用可以说是到了出神入化的地步，所以一直都是我最喜欢用的框架。这系列的文章主要是介绍如何在微服务开发中应用这套框架来进行开发。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://gawainx.github.io/tags/Java/"/>
    
      <category term="REST" scheme="https://gawainx.github.io/tags/REST/"/>
    
      <category term="微服务" scheme="https://gawainx.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
</feed>
