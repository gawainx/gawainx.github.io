<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gawainx&#39; Blog</title>
  
  <subtitle>Antarx is the heart of Scorpio</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://antarx.com/"/>
  <updated>2019-04-11T01:33:47.820Z</updated>
  <id>https://antarx.com/</id>
  
  <author>
    <name>Gawain Antarx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>济南三天小憩</title>
    <link href="https://antarx.com/2019/04/11/402/"/>
    <id>https://antarx.com/2019/04/11/402/</id>
    <published>2019-04-11T01:31:29.000Z</published>
    <updated>2019-04-11T01:33:47.820Z</updated>
    
    <content type="html"><![CDATA[<p>清明假期去济南瞎*乱逛了三天，对济南这个城市印象还挺深刻的，回来写个流水账。<br><strong>多图预警</strong></p><h2 id="“玩水”"><a href="#“玩水”" class="headerlink" title="“玩水”"></a>“玩水”</h2><p>济南被称为“泉城”，泉眼之多甚至影响了地铁的修建。围绕着泉的景点们自然是非常值得细细品味一下的。</p><p>首先便是泉城广场，应该是济南最大的广场，各种知名景点均匀分布在泉城广场的南北两侧。于是第一天从泉城广场出发，沿着护城河一路暴走，先后经过黑虎泉“地带”，大明湖，然后绕回来到趵突泉。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://antarx.cn/images/20190405_100232.jpg" alt="泉城广场" title>                </div>                <div class="image-caption">泉城广场</div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://antarx.cn/images/20190405_102421.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>护城河一带是各种泉眼，最具特色的地方是泉水非常清澈，甚至到达了饮用水的标准，一路上各种“扫码取水”随处可见，也有很多大爷大妈带着桶过来打水饮用。跟着他们试饮了一口，确实是够清澈，“有点甜”。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://antarx.cn/images/20190405_101831.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://antarx.cn/images/20190405_103025.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>大明湖估摸是济南最出名的景点，毕竟谁没听过“大明湖畔的夏雨荷”呢。大明湖大部分地段都是免费景点，不收取门票直接游玩。一路上柳树成荫，绿意盎然。里面有辛弃疾故居值得参观一下。另外有“超然楼”，是他们主要的收费景点。因为它是个现代的景点，就没花钱进去了（个人还是喜欢看古建筑多一些），在外面拍拍照感觉也还不错。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://antarx.cn/images/20190405_143854.jpg" alt="大明湖" title>                </div>                <div class="image-caption">大明湖</div>            </figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://antarx.cn/images/20190405_135315.jpg" alt="超然楼" title>                </div>                <div class="image-caption">超然楼</div>            </figure><p>从大明湖暴走到趵突泉的路上还经过了五龙潭公园，正在举办樱花节，不过当时已经天色近晚，趵突泉和五龙潭都是六点就停止售票，所以选择了趵突泉。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://antarx.cn/images/20190405_163023.jpg" alt="趵突泉" title>                </div>                <div class="image-caption">趵突泉</div>            </figure></p><p>趵突泉最早是在小学语文课本里面就学到了，真正看到本体的时候并没有想象中的那么震撼，公园里面还有个李清照故居，可以跟着导游听听故事hhhh</p><h2 id="“游山”"><a href="#“游山”" class="headerlink" title="“游山”"></a>“游山”</h2><p>济南的⛰️，也是只有“千佛山”这么一座山，第二天的重点便是对付这座山，总体感觉就是“不枉此行”。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://antarx.cn/images/20190406_145718.jpg" alt="千佛山" title>                </div>                <div class="image-caption">千佛山</div>            </figure></p><p>千佛山因为佛像多而闻名，山腰有个万佛洞，山顶是舜祠等。最带给我震撼的，便是万佛洞了。进去有种探险的感觉，可以看到形态各异的佛像，有三五米高的雕像和卧佛，也有各种“微型”但依然形态各异的佛像组成洞壁。一开始进去的时候有种无穷无尽的错觉，而形态各异的这些佛像又可以让人觉得兴趣昂然。</p><p>爬到山顶的过程，非常不幸运选了一条陡峭、狭窄而拥挤的小路，给我一种倾斜45度仰望天空的夜晚芙蓉街的错觉，无形中增加了体力成本和心理上的厌恶感。幸好下山的时候，反而误打误撞走了非常宽敞的路，不知不觉便下来了，打消了之前的厌恶情绪。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://antarx.cn/images/20190406_135717.jpg" alt="山顶" title>                </div>                <div class="image-caption">山顶</div>            </figure><p>那天刚好碰上了济南人的“三月三”庙会和“可能是故意安排在庙会期间”的大型纸面相亲活动，终于见识到了网上流传已久的那种大爷大妈拿着仔女的信息去挨个看“候选人”的信息然后认真记笔记的“名场面”，还挺震撼的。怎么说呢希望自己以后不会成为这种任君选择的其中一张纸牌吧（。有种摆在货架的过期罐头的感觉emmmmmm<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://antarx.cn/images/20190406_120542.jpg" alt="相亲角" title>                </div>                <div class="image-caption">相亲角</div>            </figure></p><h2 id="人文名胜"><a href="#人文名胜" class="headerlink" title="人文名胜"></a>人文名胜</h2><p>济南作为山东的省会城市，高校众多。原本想着去山东大学和山师闲逛一番的，无奈时间确实凑不出来，只有在去洪家楼地区的天主教堂出来之后去隔壁的山东大学洪家楼校区逛了一圈。</p><p>洪家楼的天主教堂给人的感觉还是蛮震撼的，虽然已经过了可以进去参观的时间点，在外面看也非常的shocking。从远处拍照甚至有点欧陆田园的感觉。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://antarx.cn/images/20190406_171934.jpg" alt="天主教堂" title>                </div>                <div class="image-caption">天主教堂</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://antarx.cn/images/20190406_172413.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>最后一天本来想去山东博物馆和美术馆的，但是博物馆排队的人实在太多，担心时间安排不过来赶不上火车，于是就去了美术馆，刚好赶上了齐白石的画展。在课本中学到的齐白石相关的画虾的典故，和看到真迹，是完全不同的两个感受。除了这个齐白石展览之外，美术馆展出的都是一些现代画展，我这样的俗人并不能看出味道来，只能图个乐子便是了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://antarx.cn/images/20190407_122842.jpg" alt="齐白石画展" title>                </div>                <div class="image-caption">齐白石画展</div>            </figure></p><h2 id="网红景点"><a href="#网红景点" class="headerlink" title="网红景点"></a>网红景点</h2><p>网红景点单独拎出来。“宽厚里”和“芙蓉街”是网红景点的二霸，之前看攻略的时候有人说是芙蓉街在抖音上火起来带旺了济南的人气的说法。宽厚里是一系列“网红小店”的聚集地，有种鼓浪屿“龙头路”和北京南锣鼓巷的感觉。一开始是对这些一点都不感冒的，不过实际逛下来，两个景点是截然不同的感觉啊。</p><p>宽厚里是早上从黑虎泉出来之后去的，或许是因为人不多，或许是因为本身地区就非常大，整体感觉还蛮不错的，一个和同行友人一致认同的重要因素是虽然里面都是网红店但居然没有重复的（此处怒斥接下来提到的芙蓉街）。所以一路逛下来有一种持续的新奇的感觉，非常的奇妙。顺便里面的店卖的东西出品也都还不错，以至于第二天晚上又过去消遣一番。</p><p>芙蓉街是第一天的“压轴”景点，然而也是因为这个景点让我们同时差点毁掉了一天的好心情，狭窄，拥挤，一条长长的街下来全是卖着重复的、不亚于流水线生产出来的垃圾食物，空气中飘散着劣质油脂的“腻味”，直教人想逃离。进去的时候还碰上了限流措施然后绕了一大圈才进去，结果给我看这个？虽然一开始就被提醒这里和王府井小吃街差不多，然而没想到这还差远了都。也是整个旅行的一大“不悦”。</p><h2 id="饮食文化"><a href="#饮食文化" class="headerlink" title="饮食文化"></a>饮食文化</h2><p>以前看亚洲电视黄麗梅的《中国八大名菜》就已经知道，鲁菜一直以来在排场和精致程度上都是能够和正统广府粤菜比肩的。这次在济南去了泉城广场附近的一家私房菜馆（感觉济南这边私房菜还挺多的），给我的感觉就是，确实名不虚传。糖醋鲤鱼能够通过调味干掉鲤鱼的腥味同时还能保留鱼肉的鲜嫩，然后另一个叫做“老坛子”的羹类美食，更是把海参，小鲍鱼，虫草花，松茸这些“惹味”炖在一块，充分发挥了食材的“鲜”，让人回味无穷。</p><p>下次一定要去青岛烟台这些地方大吃海鲜（小声</p><p>另外，济南比较出名的还有糖沫和把子肉。糖沫怎么说呢，和“糖”可是一点都不沾边，有种猪肉粥的感觉，中规中矩吧。把子肉据说是十几块钱一大块的五花肉，然而大家都看着图片都一致嫌腻，所以“打扰了”</p><p>除了这些以外，在做攻略的时候就觉得，济南好像没啥特色啊，没有那种看上去就值得专门跑去这个城市品尝的美味，事实上确实也是这样的，毕竟某点评APP上前十必去餐馆还是什么猪肚鸡和日本料理这些hhh但是人家消费便宜啊，随便吃就是了。三天下来在吃得方面倒也并没有发现明显的雷区。</p><h2 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h2><p>济南的消费水平又是一个让我“愉悦”的地方。一顿火锅点了三四个肉菜吃下来人均也就六十出头，在私房菜馆点了三个分量大到boom的肉菜人均不到80，还吃到了海参这样的海味和一整条鲤鱼，宽厚里这样的网红地方排第一的烧烤，撸串喝酒下来人均不到五十。在北京下一次馆子的消费都够这吃一天了。</p><p>大概是在北京待久了，去哪都觉得物价便宜吧hhhh</p><p>另外还有一点就是，去年年底学到的一个很重要的消费观是先存钱后花钱，然后建立了一个账户专门存钱旅行，这次出门终于感受到这种消费观的“威力”，在存钱和预算允许的范围内随便花钱的感觉真的太爽了！</p><h2 id="交通"><a href="#交通" class="headerlink" title="交通"></a>交通</h2><p>济南因为地下泉眼太多，地铁迟迟修不起来，临行前几天终于开通了济南一号线，然而却是从一个郊区通往另外一个郊区，和所有景点都毫无关系。所以一路上都是以“暴走🚶”和巴士为主，巴士最先进的地方是支持支付宝微信二维码还有银联闪付，三星Pay解决所有问题，并不需要考虑自备零钱的事情还是挺好的。</p><p>济南被戏称为“堵城”，打车的时候司机都在吐槽堵车经历，🚥设置不合理和道路规划成为了一个大问题，虽然近几年开了经十路这种八车道十车道，还是没有完美解决所有问题。白天看地图市中心区几乎所有道路都是红到发黑的emmmm</p><p>至于共享单车这种“新四大发明”，只看到了摩拜和哈罗，然而还是没逃脱想骑车的时候看到的都是别人在骑，不用骑车的时候看到一堆🚴available的“共享定律”</p><p>对于游客来说，最大好处就是，几乎所有景点都集中在泉城广场为中心的四平方公里的地区，游玩的话靠11路公共汽车便可以解决所有问题。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>环境上这里并没有给我太好的印象，虽然晚上风非常的大甚至可以把人吹倒，然而白天还是要面临轻度污染，拍照出来都是灰蒙蒙一片，也太不友好了。所以吧，这里也并不是一个适合带着相机游玩的地方了。回到北京呼吸着倒春寒带来的PM2.5指数under 50空气都让我有种如释重负的感觉。</p><h2 id="人文气息"><a href="#人文气息" class="headerlink" title="人文气息"></a>人文气息</h2><p>人文方面的话，总体来说和天津一样是非常悠闲的一个城市，除了几个景点人挤人以外，其他地方生活节奏并没有太快，流淌着舒适安逸的味道。</p><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><p>之所以管这次出门叫做“小憩”，因为济南的悠闲的氛围，极其舒适的消费水平都让人有种逃离大城市的感觉，而景点浓度也不高，不用把三天行程安排的满满当当疲于奔命，称之为休憩真的再合适不过了，和短促的三天假期搭配起来堪称完美。</p><p>说要推荐的话，超过三天的假期专门去那就肯定是不划算的了。短假期过去溜达一圈还是可以的，或者作为威海青岛烟台蓬莱这种山东沿海景点游历完毕之后的最后一站也未尝不可（今天晚上从基友口中听到的这波骚操作哈哈哈哈哈）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;清明假期去济南瞎*乱逛了三天，对济南这个城市印象还挺深刻的，回来写个流水账。&lt;br&gt;&lt;strong&gt;多图预警&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;“玩水”&quot;&gt;&lt;a href=&quot;#“玩水”&quot; class=&quot;headerlink&quot; title=&quot;“玩水”&quot;&gt;&lt;/a&gt;“玩水
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>11月论文阅读总结</title>
    <link href="https://antarx.com/2018/11/29/papers-nov/"/>
    <id>https://antarx.com/2018/11/29/papers-nov/</id>
    <published>2018-11-29T08:48:39.000Z</published>
    <updated>2018-11-29T12:58:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>转博了之后平时的工作重心从写代码慢慢的转移到科研读论文复现论文等上面来。选研究方向的时候也费了好大一番功夫去纠结，一开始想继续做微服务和SDN的东西，后面却逐渐发现往深入去做的话又兜兜转转回到了通信的轨道上了。后面终于下定决心做知识图谱的东西。整个十一月都在看知识图谱的论文，主要集中在知识表示领域的几种Translation模型上。</p><a id="more"></a><h2 id="什么是Translation？"><a href="#什么是Translation？" class="headerlink" title="什么是Translation？"></a>什么是Translation？</h2><p>知识图谱是一种偏向于人类认知的“数据结构”，将实体之间用关系的方式进行链接，比如说“中国的首都是北京“这句话，用知识图谱进行建模的方式就是，“中国”（实体）的首都是（“关系表示”）“北京”（另一个实体）。</p><p>这样，一条知识就可以用图这个数据结构的一条边（edge）来表示。参考图的关系描述方式，知识图谱中可以使用 $h,r,t$ 三元组来表示一条“知识”，$h$ 是head，头部知识，知识的端点，在上面的例子中，为“中国”，$r$是relation，表示关系的意思，$t$是tail，在上面的例子中，为“北京”。</p><p>知识终究是要喂给计算机进行处理的，计算机只能处理数据信息。知识图谱上面的东西都是离散的，符合人类认知逻辑的，和计算机处理的数据没有半毛钱的关系。因此，就有了知识表示的说法。怎么把图结构表示成计算机可以处理的数据的形式。</p><p>Translation，是对知识表示的一种“形容”，目标是将三元组映射到计算机可以处理的连续数值向量空间中，当然了，最好这个空间的维度可以低一些。</p><h2 id="Translation-Embedding（TransE）"><a href="#Translation-Embedding（TransE）" class="headerlink" title="Translation Embedding（TransE）"></a>Translation Embedding（TransE）</h2><p>TransE，是最早的研究用嵌入（embed）方法来进行知识表示的一篇论文。基本思想就是最直观的将实体关系数据嵌入到低维度向量空间中。</p><p>关于TransE，网路上有很多讨论的文章（毕竟出来最早），讨论的内容都大同小异，可以参考<a href="http://yaoleo.github.io/2017/10/27/TransE%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/" target="_blank" rel="noopener">TransE算法的理解 | Yaoleo</a></p><p>TransE所完成的，是最基本的知识嵌入，忽略了知识中普遍存在的一对多、多对一、自反关系的问题，自反关系中，$r$会被建模成$0$向量；多对一的关系中，因为它的Scoring Function设定为 $\Vert h-r+t \Vert$， 假设$h_0,…,h_m$ 均与$t$形成关系$r$，那么$h_0,…,h_m$的向量表示是相等的。一对多的关系同理。</p><p>因此，有了TransH。</p><h2 id="Translation-Hyperplane"><a href="#Translation-Hyperplane" class="headerlink" title="Translation Hyperplane"></a>Translation Hyperplane</h2><p>这个方法是紧跟随TransE提出来的。主要有两个改进的地方（对比TransE）</p><ol><li><p>引入entity的分布式表示。将Relation的表示放在了与entity的不同空间当中（也是Hyperplane的由来）。两个空间（relation和entity之间）的向量表示是一个投影关系（projection）</p></li><li><p>将现有知识图谱的“未完成”问题考虑进来，负样本的构造过程不再像以往模型那样随机选择，而是基于伯努利分布的一个选择过程。而且对与多对一和一对多时候的“污染源”也是有区别的。</p></li></ol><p>此外Scoring Function和Loss Function也有改进。</p><h2 id="OpenKE-Toolkit"><a href="#OpenKE-Toolkit" class="headerlink" title="OpenKE Toolkit"></a>OpenKE Toolkit</h2><p>第三篇论文是2018年清华大学发布的，是一个工具包的简介。基于Trans的模型有不下五六种，模型的训练和测试成为了一个难题。而且每提出一个新的算法都要对前面的东西进行重复验证。所以这篇论文中将这几种常见模型的算法集中到了一起，提供统一的接口和数据库，并且保证了向后兼容性。提供了TF和PyTorch的接口，实现GPU训练和CPU多线程并行训练。</p><p>在这篇论文中作者还指出，前面的各种Translation算法，本质上最大的区别就是Scoring Function和Loss Function的区别。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><p><a href="https://www.jiqizhixin.com/articles/2017-11-04-2" target="_blank" rel="noopener">清华大学开源OpenKE：知识表示学习平台 | 机器之心</a> 里面有上面提到的所有论文的链接。</p></li><li><p>Zhen Wang, J. Z. J. F. Z. C. (2014). Knowledge Graph Embedding by Translating on Hyperplanes, 1–8.</p></li><li><p>OpenKE: An Open Toolkit for Knowledge Embedding. (2018). OpenKE: An Open Toolkit for Knowledge Embedding, 1–6.</p></li><li><p>Translating Embeddings for Modeling Multi-relational Data. (2013). Translating Embeddings for Modeling Multi-relational Data, 1–9.</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转博了之后平时的工作重心从写代码慢慢的转移到科研读论文复现论文等上面来。选研究方向的时候也费了好大一番功夫去纠结，一开始想继续做微服务和SDN的东西，后面却逐渐发现往深入去做的话又兜兜转转回到了通信的轨道上了。后面终于下定决心做知识图谱的东西。整个十一月都在看知识图谱的论文，主要集中在知识表示领域的几种Translation模型上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="科研" scheme="https://antarx.com/tags/%E7%A7%91%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://antarx.com/2018/11/02/configs/sorts/"/>
    <id>https://antarx.com/2018/11/02/configs/sorts/</id>
    <published>2018-11-02T03:22:40.000Z</published>
    <updated>2018-11-02T03:22:40.000Z</updated>
    
    <content type="html"><![CDATA[{"":[],"__positions":{},"__raw_positions":{}}]]></content>
    
    <summary type="html">
    
      
      
        {&quot;&quot;:[],&quot;__positions&quot;:{},&quot;__raw_positions&quot;:{}}
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>新款 Mac mini 购买可行性分析</title>
    <link href="https://antarx.com/2018/11/02/macmini/"/>
    <id>https://antarx.com/2018/11/02/macmini/</id>
    <published>2018-11-02T03:20:29.000Z</published>
    <updated>2019-01-07T12:52:03.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="新款-Mac-mini-购买可行性分析（持续更新）"><a href="#新款-Mac-mini-购买可行性分析（持续更新）" class="headerlink" title="新款 Mac mini 购买可行性分析（持续更新）"></a>新款 Mac mini 购买可行性分析（持续更新）</h1><p>10 月 30 号苹果的新品发布会，我望眼欲穿的Mac mini 终于在时隔四年之后迎来了“大更新”，正如之前很多 KOL 所“预言”的一样，是一次面向专业人士的一次更新，最高支援了 i7 六核处理器和 64GB 内存和 2TB 固态，还有万兆以太网接口可选。昨天也同步更新了大陆的价格信息。网络上对于这款产品的评价也是褒贬不一，到底这款产品是不是值得购买呢。</p><a id="more"></a><h2 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h2><p>这里只关注 i5 和 i7 版本。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://antarx.cn/20181102112846_2NouDo_Screenshot.jpeg" alt="官网处理器规格表" title>                </div>                <div class="image-caption">官网处理器规格表</div>            </figure><br>Apple 一般都会和英特尔有定制处理器，根据<a href="https://ark.intel.com/zh-cn#@PanelLabel122139" target="_blank" rel="noopener">英特尔® 产品规格</a>，查找 i5 处理器的规格表<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://antarx.cn/20181102113138_9aUiT7_Screenshot.jpeg" alt="第八代 i5 处理器" title>                </div>                <div class="image-caption">第八代 i5 处理器</div>            </figure><br>从基准频率，睿频频率和 L3 缓存规格，基本可以确认，Mac mini 使用的 i5 处理器就是这款 8500B，是基于桌面版的 8500 的修改款。<br>同样可以找到<a href="https://ark.intel.com/zh-cn/products/series/122593/-i7-" target="_blank" rel="noopener">第八代智能英特尔® 酷睿™ i7 处理器 产品规格</a>，可以基本确认 Mac mini 的 i7 处理器是 8700B，是桌面版 8700（不带 k）的修改版（为了适配 Mac mini 的体积而进行散热性能的更改）。<br>可以看到，对比上一代的 Mac mini 使用的低压移动平台处理器，这次的升级可以说是一脚踩爆了牙膏管。<br>要注意的是，第八代 i5 和 i7 处理器（上面说的这两款），最大的区别是超线程支持上，也就是说只有 i7 8700B 这款处理器支持超线程，为 6C12T（6 Core 12 Thread）规格。</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>内存其实没啥好说的，横跨 8GB 到 64GB。<br>比较有意思的是，这一代重新采用了 SO-DIMM 的可插拔内存，理论上可以买 8GB 版本回来自己扩充到 32G 内存，还能省 2000 元。具体的内存更换教程和内存条兼容性报告，等发售和测试之后再更新。</p><h3 id="一点吐槽和一点疑问"><a href="#一点吐槽和一点疑问" class="headerlink" title="一点吐槽和一点疑问"></a>一点吐槽和一点疑问</h3><p>官网的自定义配置上，从 8GB 内存升格到 32GB 内存居然要加四千多。问题是现在内存价格已经回落了啊！！！<br>官网的宣传图片和规格上说是可插拔内存插槽，是不是意味着可以买低内存版本回来自己加爆到 32*2=64G 内存呢？具体情况关注 ifixit 的拆解情况再作判断。</p><h2 id="显卡-GPU"><a href="#显卡-GPU" class="headerlink" title="显卡/GPU"></a>显卡/GPU</h2><p>应该是这次“面向专业人士的升级”中最值得吐槽的地方。<br>之前微博上一直有说法，这次的 Mac mini 会选配 GTX 1050 图形处理器。<br>然而，然而，最后的结果是，全系列，Intel UHD630 集成图形处理器。<br>这个 GPU 是什么概念呢，在显卡天梯图上，这款产品的规格甚至比 2015 mid 的MacBook Pro 15 吋低配的 4770HQ 处理器内置的 Iris 5200 还要低。（能不能顺利带动我的 P2415Q 是很让我困惑的一件事，虽然官网规格说支援同时带两个 4k 显示器）</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>之前一直很担心 Mac mini 更新会不会只给 Thunderbolt 3 接口，甚至连以太网接口会不会砍掉，幸好最后库克证明是我多虑了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://antarx.cn/20181102120058_gkxv7d_Screenshot.jpeg" alt="Apple官网接口规格" title>                </div>                <div class="image-caption">Apple官网接口规格</div>            </figure><br>四个 Thunderbolt 3 接口，两个 USB3.0 接口，还有 HDMI2.0 和千兆以太网接口（可选万兆），覆盖了日常使用的所有接口类型，总而言之，管够！</p><h2 id="外接设备的可能性探讨"><a href="#外接设备的可能性探讨" class="headerlink" title="外接设备的可能性探讨"></a>外接设备的可能性探讨</h2><p>最重要的外接设备形式，就是自 macOS High Sierra 10.13.4 开始支援的 eGPU 了。关于 Mac 对 eGPU 原理的讨论，大别<a href="https://weibo.com/ibuick?profile_ftype=1&amp;is_article=1#_0" target="_blank" rel="noopener">ibuick的微博</a>上面有篇文章讨论的非常详细，我这里就不班门弄斧。有需要的可以自行参阅研究。<br>总的来说，外接 eGPU 可以满足视频渲染、照片处理等重型任务的需求，对于程序员（包括我）最关心的科学计算、深度学习任务可不可以使用 eGPU 进行加速的问题，目前调查到的情况有这几点：</p><ol><li><p>显卡硬件方面。</p><ul><li>NVIDIA Pascal 及以上架构的显卡（GTX10 开始）在 macOS Mojave 10.14 系统上还没发布驱动包（据说是还没通过苹果的审核）。</li><li>AMD 显卡，有<a href="https://rocm.github.io/index.html" target="_blank" rel="noopener">ROCm, a New Era in GPU Computing</a>方案实现 TensorFlow 调用 AMD GPU 资源进行计算加速。问题是 ROCm 到目前为止不支持 macOS。</li></ul></li><li><p>软件兼容性层。NVIDIA 有发布 CUDA 以及 CuDNN for macOS。</p><ul><li>同样的，这两个软件依然没有支持 macOS Mojave</li><li>TensorFlow for macOS 可以通过自编译的方式实现 GPU 支持。</li><li>就算以后打通了 NVIDIA eGPU + CUDA + CuDNN + TensorFlow for macOS 的完整流程，由于 Docker for macOS 是一种虚拟机实现方案，所以也许永远不会有 Nvidia-Docker for macOS 来实现更简单的开发环境部署和 Python 环境隔离。</li></ul></li><li>对于 macOS High Sierra 系统和 Pascal 以下的显卡，已经有非常详细的教程<a href="https://medium.com/@jianshi_94445/training-your-neural-net-with-egpu-acceleration-on-mac-with-tensorflow-1-5-b2b729f4e408" target="_blank" rel="noopener">Training Your Neural Net with eGPU Acceleration on Mac with Tensorflow 1.5</a>实现 2.3 所说的完整流程。</li></ol><h2 id="其他外接设备"><a href="#其他外接设备" class="headerlink" title="其他外接设备"></a>其他外接设备</h2><h3 id="显示器"><a href="#显示器" class="headerlink" title="显示器"></a>显示器</h3><ul><li>预算有限的，可以选 dell P2415Q，目前非 Ultrafine 荧幕里面 PPi 最接近视网膜的。接一般的 4k 荧幕（泛指所有尺寸在 27 寸及以上的 4k 荧幕），同样可以实现 HiDPI 缩放，具体判断是接入显示器之后，设置连接模式为扩展，然后打开显示器选项，选择缩放，看到的是下面这样的截图<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://antarx.cn/images/20181103161045_fOD6Fx_Screenshot.jpeg" alt title>                </div>                <div class="image-caption"></div>            </figure>而不是让你选择物理分辨率。HiDPI 技术对显示效果的影响，具体来说就是两种显示器（支持 HiDPI 和普通显示器），macOS 在渲染输出的时候会采用不同的色彩空间（对于后者，在系统中会被识别成“电视”，使用 YUV），看起来会觉得后者的字体锯齿甚至比 Windows10 外接高分屏荧幕更加严重。2k 显示器可以通过软件修改的方式实现 HiDPI，缺点是每次系统升级都可能导致不能用。</li><li>预算充足的，直接 LG Ultrafine 系列。<h3 id="机械键盘"><a href="#机械键盘" class="headerlink" title="机械键盘"></a>机械键盘</h3>ikbc G104 和阿米洛的 Mac 系列都是原生 Mac 键位支持。也可以买 Windows 键盘回来自己改键位和键帽，全凭个人喜好了。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;新款-Mac-mini-购买可行性分析（持续更新）&quot;&gt;&lt;a href=&quot;#新款-Mac-mini-购买可行性分析（持续更新）&quot; class=&quot;headerlink&quot; title=&quot;新款 Mac mini 购买可行性分析（持续更新）&quot;&gt;&lt;/a&gt;新款 Mac mini 购买可行性分析（持续更新）&lt;/h1&gt;&lt;p&gt;10 月 30 号苹果的新品发布会，我望眼欲穿的Mac mini 终于在时隔四年之后迎来了“大更新”，正如之前很多 KOL 所“预言”的一样，是一次面向专业人士的一次更新，最高支援了 i7 六核处理器和 64GB 内存和 2TB 固态，还有万兆以太网接口可选。昨天也同步更新了大陆的价格信息。网络上对于这款产品的评价也是褒贬不一，到底这款产品是不是值得购买呢。&lt;/p&gt;
    
    </summary>
    
    
      <category term="macOS" scheme="https://antarx.com/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>go模块入门</title>
    <link href="https://antarx.com/2018/09/03/gomod/"/>
    <id>https://antarx.com/2018/09/03/gomod/</id>
    <published>2018-09-03T07:25:44.000Z</published>
    <updated>2018-09-03T12:22:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go-模块入门"><a href="#Go-模块入门" class="headerlink" title="Go 模块入门"></a>Go 模块入门</h1><p>Go1.11 的一个重要特性就是 <code>go modules</code>，作为 Go 一直以来版本管理顽疾的官方解决方案，自然是非常值得重视的。最近看到一篇文章对它阐述的非常好，所以就翻译过来。</p><p>原文链接：<a href="https://roberto.selbach.ca/intro-to-go-modules/" target="_blank" rel="noopener">Introduction to Go Modules – Roberto Selbach</a></p><a id="more"></a><p>Go 语言的1.11版本即将带来modules 的实验性支持，这是 Go 语言中一个全新的依赖管理系统。</p><p>早前我<a href="https://roberto.selbach.ca/playing-with-go-modules/" target="_blank" rel="noopener">写过一篇文章</a>来阐述 Go 的模块，但里面的很多东西在那篇文章之后都发生了变化，所以就有了这篇文章，用更多的上手实践来介绍这个特性。</p><p>在这篇文章里，我们会创建一个新的包（package）和发布一些版本来验证 go 模块是如何工作的。</p><h2 id="创建一个模块"><a href="#创建一个模块" class="headerlink" title="创建一个模块"></a>创建一个模块</h2><p>首先，我们创建一个命名为“testmod”的包。一个重要的细节是，包文件夹应该在<code>$GOPATH</code>以外，因为在<code>$GOPATH</code>目录下，模块功能是默认关闭的。某种程度上可以认为 Go modules 是削弱<code>$GOPATH</code>职能的第一步。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir testmod</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> testmod</span></span><br></pre></td></tr></table></figure><p>包的内容非常简单，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> testmod</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Hi returns a friendly greeting</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hi</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> fmt.Sprintf(<span class="string">"Hi, %s"</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样不是一个模块，需要做以下变更</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go mod init github.com/robteix/testmod</span></span><br><span class="line">go: creating new go.mod: module github.com/robteix/testmod</span><br></pre></td></tr></table></figure><p>这个命令会在目录下创建<code>go.mod</code>文件，内容如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module github.com/robteix/testmod</span><br></pre></td></tr></table></figure><p>这些步骤已经将我们的包转换成一个模块，我们可以把这些代码推送到仓库中，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add * </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -am <span class="string">"First commit"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin master</span></span><br></pre></td></tr></table></figure><p>这样，其他人可以通过<code>go get github.com/robteix/testmod</code>来使用这个包</p><p>这个操作会拉取<code>master</code>分支下的代码。这依然有效，但我们应该停止这么做因为我们找到了更好的方法。拉取<code>master</code>分支的做法是具有潜在危险性的，因为我们不能确定软件包的作者会不会作出一些让我们的调用不再生效的更改。这是 modules 主要想改善的状况。</p><h2 id="Module-Versioning-简介"><a href="#Module-Versioning-简介" class="headerlink" title="Module Versioning 简介"></a>Module Versioning 简介</h2><p>Go 模块是支持版本的概念的，也支持特别对待一些特殊的版本。首先（运用这些特性之前）你要熟悉<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">语义化版本</a>的概念。</p><p>更重要的是，Go 使用仓库标签的方式来查找版本，某些版本会与众不同，比如version 2或者更高的版本应该享受与0或1版本不同的导入路径。</p><p>与此同时，Go 会默认拉取仓库中最新的可用标记版本（tagged version），这是非常值得注意的地方因为在此之前你或许已经习惯了使用 master 分支。</p><p>现在你需要知道的是为了发布我们的软件包，我们需要对软件仓库的代码用版本号来打标签，让我们开始吧！</p><h2 id="第一次发布"><a href="#第一次发布" class="headerlink" title="第一次发布"></a>第一次发布</h2><p>让我们把写好的软件包发布出去。我们使用版本号标签的方式来实现，比如说发布1.0.0版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag v1.0.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push --tags</span></span><br></pre></td></tr></table></figure><p>这会在我的 GitHub 仓库上面将当前的提交标记为1.0.0发布版。</p><p>为这次发布创建一个新分支是一个好主意，尽管 Go 不会强制要求我们这样做。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b v1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin v1</span></span><br></pre></td></tr></table></figure><p>现在我们可以专注于 <code>master</code> 分支，不用担心会破坏我们的发布版本。</p><h2 id="使用我们的模块"><a href="#使用我们的模块" class="headerlink" title="使用我们的模块"></a>使用我们的模块</h2><p>我们将会创建一个简易程序来演示如何使用我们的模块/</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/robteix/testmod"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(testmod.Hi(<span class="string">"roberto"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之前，你可以通过<code>go get github.com/robteix/testmod</code>来下载软件包，但使用模块功能，事情会变得有趣。首先我们要在自己的程序中开启模块功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init mod</span><br></pre></td></tr></table></figure><p>它会创建<code>go.mod</code>文件，内容如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module mod</span><br></pre></td></tr></table></figure><p>当我们在试图构建我们的代码的时候事情变得有趣起来，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go build</span></span><br><span class="line">go: finding github.com/robteix/testmod v1.0.0</span><br><span class="line">go: downloading github.com/robteix/testmod v1.0.0</span><br></pre></td></tr></table></figure><p>正如我们所见，<code>go</code>命令获取程序需要用到的软件包。这时候如果我们打开<code>go.mod</code>文件，可以看到</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module mod</span><br><span class="line">require github.com/robteix/testmod v1.0.0</span><br></pre></td></tr></table></figure><p>另外我们会看到一个名为<code>go.sum</code>的新文件，包含了软件包的哈希值，确保我们下载了正确的版本和对应的二进制文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">github.com/robteix/testmod v1.0.0 h1:9EdH0EArQ/rkpss9Tj8gUnwx3w5p0jkzJrd5tRAhxnA=</span><br><span class="line">github.com/robteix/testmod v1.0.0/go.mod h1:UVhi5McON9ZLc5kl5iN2bTXlL6ylcxE9VInV71RrlO8=</span><br></pre></td></tr></table></figure><h2 id="发布修复-bug-的版本"><a href="#发布修复-bug-的版本" class="headerlink" title="发布修复 bug 的版本"></a>发布修复 bug 的版本</h2><p>现在假设我们意识到程序中存在的一个问题，打招呼的语句缺少标点符号。人们会因为我们这个程序的不够友好而勃然大怒，所以我们用新版本来修复这个问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hi returns a friendly greeting</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hi</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">-       <span class="keyword">return</span> fmt.Sprintf(<span class="string">"Hi, %s"</span>, name)</span><br><span class="line">+       <span class="keyword">return</span> fmt.Sprintf(<span class="string">"Hi, %s!"</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在<code>v1</code>分支进行更改因为这与我们稍后在<code>v2</code>版本要做的事情毫无关系。在实际应用中，你或许会直接在 <code>master</code> 分支上干这件事情。无论哪种方式，我们需要修复我们<code>v1</code>分支上的代码并且标记成一个新的发布版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"Emphasize our friendliness"</span> testmod.go</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag v1.0.1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push --tags origin v1</span></span><br></pre></td></tr></table></figure><h2 id="更新模块"><a href="#更新模块" class="headerlink" title="更新模块"></a>更新模块</h2><p>在默认情况下，Go 在未经许可之前不会更新模块，这是一件好事因为我们希望软件构建过程是可以预测的。如果 Go 模块每次有新版本发布的时候都会自动更新，我们会回到 Go1.11的一个非常原始的版本。现在，我们需要告诉 Go 来更新模块。</p><p>在老版本的<code>go get</code>，我们可以这样做</p><ul><li><code>go get -u</code>来获取<em>minor</em>或者 <em>patch</em> 更新，比如从1.0.0更新到1.0.1或者1.1.0</li><li><code>go get -u=patch</code> 来获取最新的<em>patch</em>更新（会更新到1.0.1但不会更新1.1.0）</li><li><code>go get package@version</code> 来更新特定的版本。</li></ul><p>在上面所说的措施里面，没有一个可行的举措来更新到最新的<code>major</code>版本，我们稍后会看到，这是有原因的。</p><p>因为我们的程序使用的是<code>1.0.0</code>版本的软件包，我们刚刚创建了<code>1.0.1</code>版本，以下任意一个命令会更新我们的软件包到1.0.1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get -u</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go get -u=patch</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go get github.com/robteix/testmod@v1.0.1</span></span><br></pre></td></tr></table></figure><p>运行以上任意命令之后，<code>go.mod</code>文件更改为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module mod</span><br><span class="line">require github.com/robteix/testmod v1.0.1</span><br></pre></td></tr></table></figure><h2 id="主版本更新"><a href="#主版本更新" class="headerlink" title="主版本更新"></a>主版本更新</h2><p>根据语义化版本的语法，主版本（major version）不同于小版本更新（minors）。主版本可以破坏后向兼容性。Go模块的观点中，主版本是完全不同的软件包。这一点最开始看来非常的奇怪，但是讲得通的：两个版本的库是不兼容的，这是两个完全不同的库。</p><p>让我们创建软件包的一个主要版本，为<code>greeting</code>函数提供一个新的参数，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> testmod</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hi returns a friendly greeting in language lang</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hi</span><span class="params">(name, lang <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> lang &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"en"</span>:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">"Hi, %s!"</span>, name), <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"pt"</span>:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">"Oi, %s!"</span>, name), <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"es"</span>:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">"¡Hola, %s!"</span>, name), <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"fr"</span>:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">"Bonjour, %s!"</span>, name), <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"unknown language"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用我们 API 的现有软件在新版本之下不能运行因为他们不会传递一个语言参数而且不会返回一个错误，我们的新 API 不再与1.x 版本兼容。所以是时候更新2.0.0版本。</p><p>我之前提过有些版本有一些具体的特性，这里是具体的例子，Version 2 及以上的版本要修改导入路径，他们现在是不同的库。</p><p>我们通过在导入路径中加入新版本号来实现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module github.com/robteix/testmod/v2</span><br></pre></td></tr></table></figure><p>剩下要做的事和之前的差不多，把代码推送到软件仓库，标签为2.0。0版本，创建 v2分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit testmod.go -m <span class="string">"Change Hi to allow multilang"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b v2 <span class="comment"># optional but recommended</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"module github.com/robteix/testmod/v2"</span> &gt; go.mod</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit go.mod -m <span class="string">"Bump version to v2"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag v2.0.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push --tags origin v2 <span class="comment"># or master if we don't have a branch</span></span></span><br></pre></td></tr></table></figure><h2 id="主要版本更新"><a href="#主要版本更新" class="headerlink" title="主要版本更新"></a>主要版本更新</h2><p>虽然我们发布了软件库的新的、不兼容的版本，但现有的软件不会失效，因为它会继续使用现有的1.0.1版本，<code>go get -u</code>不会更新到2.0.0版本。</p><p>在某些场合，库的使用者可能会想要更新到2.0.0版本因为可能存在需要多语言支持的用户。</p><p>通过适度的修改来实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/robteix/testmod/v2"</span> </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    g, err := testmod.Hi(<span class="string">"Roberto"</span>, <span class="string">"pt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(g)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后，当我运行<code>go build</code>的时候，它会下载<code>2.0.0</code>版本。注意到，即使这个导入路径是以“v2”结尾，Go 依然可以正确引用模块名字（“testmod”）</p><p>正如我之前提到的是，主版本从各方面来说都是完全不同的包版本，Go 模块不会连接到两个不同的版本，这意味着我们可以在同一个程序里面使用两个不兼容的库版本。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/robteix/testmod"</span></span><br><span class="line">    testmodML <span class="string">"github.com/robteix/testmod/v2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(testmod.Hi(<span class="string">"Roberto"</span>))</span><br><span class="line">    g, err := testmodML.Hi(<span class="string">"Roberto"</span>, <span class="string">"pt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(g)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个举措降低了包管理体系里面常见问题的负面影响：在同一软件中依赖了同一个库的不同版本。</p><h2 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h2><p>回到那个只用<code>testmod v2.0.0</code>版本的软件，我们再看<code>go.mod</code>的内容，我们注意到</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module mod</span><br><span class="line">require github.com/robteix/testmod v1.0.1</span><br><span class="line">require github.com/robteix/testmod/v2 v2.0.0</span><br></pre></td></tr></table></figure><p>默认情况下 Go 不会主动移除过时版本的依赖，如果你不再使用并且想进行清理，你可以使用<code>tidy</code>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod tidy</span><br></pre></td></tr></table></figure><p>现在<code>go.mod</code>里面只有我们在使用的软件包版本。</p><h2 id="Vendoring"><a href="#Vendoring" class="headerlink" title="Vendoring"></a>Vendoring</h2><p>默认情况下 Go 模块忽略<code>vendor/</code>目录。这个构想是为了废除<code>vendoring</code>机制，但如果我们依然想加入vendor依赖的话，依然可以实现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod vendor</span><br></pre></td></tr></table></figure><p>它会在你项目的根目录下创建<code>vendor/</code>目录，目录里面是你源代码的所有依赖关系。</p><p>同样地，<code>go build</code>会忽略这个目录下的所有内容，如果你想从这个目录中构建依赖关系，你需要输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -mod vendor</span><br></pre></td></tr></table></figure><p>我觉得很多开发者会在自己的机器上面使用正常状态下的<code>go build</code>而在持续集成的环境里使用<code>-mod vendor</code></p><p>需要再次强调的是，Go 模块已经彻底抛弃了 vendoring 思想，转而使用 Go 模块代理，因为很多人不想直接依赖上游版本控制服务。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这篇东西多多少少看起来有点劝退的意味，不过我尝试在一篇文章里解释多个概念，事实上 Go 模块是非常透明的，我们只需要像往常一样在代码中导入需要使用的代码然后<code>go</code>命令会帮我们做完剩下的所有事情。</p><p>当我们构建应用的时候，会自动拉取依赖关系。Go 模块同样削弱了<code>$GOPATH</code>的必要性，这玩意是新入门的 Go 开发者的一大绊脚石，他们往往无法理解问什么所有东西都要放到同一个目录中。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Go-模块入门&quot;&gt;&lt;a href=&quot;#Go-模块入门&quot; class=&quot;headerlink&quot; title=&quot;Go 模块入门&quot;&gt;&lt;/a&gt;Go 模块入门&lt;/h1&gt;&lt;p&gt;Go1.11 的一个重要特性就是 &lt;code&gt;go modules&lt;/code&gt;，作为 Go 一直以来版本管理顽疾的官方解决方案，自然是非常值得重视的。最近看到一篇文章对它阐述的非常好，所以就翻译过来。&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://roberto.selbach.ca/intro-to-go-modules/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Introduction to Go Modules – Roberto Selbach&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="go" scheme="https://antarx.com/tags/go/"/>
    
      <category term="文章翻译" scheme="https://antarx.com/tags/%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>豆瓣电影海报下载-Workflow</title>
    <link href="https://antarx.com/2018/07/17/dbmv/"/>
    <id>https://antarx.com/2018/07/17/dbmv/</id>
    <published>2018-07-17T13:03:53.000Z</published>
    <updated>2018-07-17T13:57:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>最近实验室里买了打印机，手账 er 多年以来的为电影手账贴上海报缩略图的心愿终于有机会打成了。</p><p>那么问题来了，去哪找电影海报可以更快更方便呢？每次都是打开网页-&gt;搜索-&gt;图片另存为，太麻烦。于是我盯上了 Alfred，于是就有了这个工具。</p><a id="more"></a><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>首先配置好文件储存的路径，如下图<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://antarx.cn/20180717215527_QpCKV5_Screenshot.jpeg" alt="配置文件" title>                </div>                <div class="image-caption">配置文件</div>            </figure></p><p>在 Alfred 中输入 <code>dbmv</code>，选择 setting，在配置文件中的<code>img_path</code>输入想要保存图片的目录。</p><p>然后就可以愉快的使用了。</p><ol><li>⌘ + Space 唤醒 Alfred 窗口，输入 <code>dbmv</code> 启动 Workflow。</li><li>选择 Movie</li><li>输入想要搜索的电影名字</li><li>在搜索结果中选择要下载的电影海报，</li><li>回车确认，然后在目标路径就会看到下载好的海报了。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://antarx.cn/20180717214323_XEYh8z_dbmv.gif" alt="使用 dbmv" title>                </div>                <div class="image-caption">使用 dbmv</div>            </figure><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p><a href="https://github.com/gawainx/dbmv/releases" target="_blank" rel="noopener">Releases · gawainx/dbmv</a></p><h2 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h2><p>本 Workflow 系基于<a href="http://stonebythesea.org/posts/douban-search-workflow-for-alfred/" target="_blank" rel="noopener">做了一个豆瓣搜索的 Workflow for Alfred - 海边的石头</a>作品的改写。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Preface&quot;&gt;&lt;a href=&quot;#Preface&quot; class=&quot;headerlink&quot; title=&quot;Preface&quot;&gt;&lt;/a&gt;Preface&lt;/h1&gt;&lt;p&gt;最近实验室里买了打印机，手账 er 多年以来的为电影手账贴上海报缩略图的心愿终于有机会打成了。&lt;/p&gt;
&lt;p&gt;那么问题来了，去哪找电影海报可以更快更方便呢？每次都是打开网页-&amp;gt;搜索-&amp;gt;图片另存为，太麻烦。于是我盯上了 Alfred，于是就有了这个工具。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mac" scheme="https://antarx.com/tags/Mac/"/>
    
      <category term="Alfred" scheme="https://antarx.com/tags/Alfred/"/>
    
  </entry>
  
  <entry>
    <title>gxd-cli is gawainx&#39; docker client</title>
    <link href="https://antarx.com/2018/06/27/gxd-cli/"/>
    <id>https://antarx.com/2018/06/27/gxd-cli/</id>
    <published>2018-06-27T08:42:27.000Z</published>
    <updated>2018-06-27T09:23:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gxd-cli-一种快速创建多容器工具"><a href="#gxd-cli-一种快速创建多容器工具" class="headerlink" title="gxd-cli : 一种快速创建多容器工具"></a>gxd-cli : 一种快速创建多容器工具</h1><p>通过 <code>docker run</code> 命令行启动容器的时候，配置网络、挂载卷是一件非常麻烦的事，<code>gxd-cli</code>将这些麻烦的工作简化成修改配置文件<code>TOML</code>达成在不需要记忆繁琐的 docker 命令行参数就能快速启动多容器。</p><h2 id="功能列表"><a href="#功能列表" class="headerlink" title="功能列表"></a>功能列表</h2><ul><li>创建多容器，创建每个容器过程可以配置一下选项<ul><li>挂载卷（支持以<code>pwd</code>指代当前路径）</li><li>指定容器的网络</li><li>自定义容器名</li><li>设定容器暴露的端口</li></ul></li><li>创建网络</li><li>快速生成模板文件</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>支持从源码构建，构建之前首先保证系统已经安装<code>golang</code>和<code>dep</code><br>步骤如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:gawainx/gxd-cli.git</span><br><span class="line">dep ensure -update</span><br><span class="line">go install</span><br></pre></td></tr></table></figure><p>安装完毕后在命令行通过<code>gxd-cli</code>调用。</p><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/gawainx/gxd-cli" target="_blank" rel="noopener">gawainx/gxd-cli</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;gxd-cli-一种快速创建多容器工具&quot;&gt;&lt;a href=&quot;#gxd-cli-一种快速创建多容器工具&quot; class=&quot;headerlink&quot; title=&quot;gxd-cli : 一种快速创建多容器工具&quot;&gt;&lt;/a&gt;gxd-cli : 一种快速创建多容器工具&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="go" scheme="https://antarx.com/tags/go/"/>
    
      <category term="docker" scheme="https://antarx.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>golang/dep 包管理（一）原理</title>
    <link href="https://antarx.com/2018/06/12/dep/"/>
    <id>https://antarx.com/2018/06/12/dep/</id>
    <published>2018-06-12T13:17:51.000Z</published>
    <updated>2018-06-25T03:14:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang-包依赖管理工具"><a href="#Golang-包依赖管理工具" class="headerlink" title="Golang 包依赖管理工具"></a>Golang 包依赖管理工具</h1><p>golang 一直以来一个为人诟病的问题就是没有完善可用的包管理工具（类比 java 的 gradle 和 maven，Python 的 pip，nodejs 的 npm），这与 golang 的追求简约高效的原则有关。golang 1.5版本之后引入了<code>vendor</code>机制，1.8之后终于有了官方的包管理工具，<code>golang/dep</code>。<br><a id="more"></a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://golang.github.io/dep/docs/assets/four-states.png" alt="四元组架构" title>                </div>                <div class="image-caption">四元组架构</div>            </figure><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://supereagle.github.io/2017/10/05/golang-dep/" target="_blank" rel="noopener">Golang依赖管理工具：Dep - 乐金明的博客 | Robin Blog</a><br><a href="https://golang.github.io/dep/docs/ensure-mechanics.html" target="_blank" rel="noopener">Models and Mechanisms · dep</a><br><a href="https://github.com/golang/dep" target="_blank" rel="noopener">golang/dep: Go dependency management tool</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Golang-包依赖管理工具&quot;&gt;&lt;a href=&quot;#Golang-包依赖管理工具&quot; class=&quot;headerlink&quot; title=&quot;Golang 包依赖管理工具&quot;&gt;&lt;/a&gt;Golang 包依赖管理工具&lt;/h1&gt;&lt;p&gt;golang 一直以来一个为人诟病的问题就是没有完善可用的包管理工具（类比 java 的 gradle 和 maven，Python 的 pip，nodejs 的 npm），这与 golang 的追求简约高效的原则有关。golang 1.5版本之后引入了&lt;code&gt;vendor&lt;/code&gt;机制，1.8之后终于有了官方的包管理工具，&lt;code&gt;golang/dep&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="go" scheme="https://antarx.com/tags/go/"/>
    
      <category term="golang" scheme="https://antarx.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>TED 200 资源整理</title>
    <link href="https://antarx.com/2018/06/11/ted-categories/"/>
    <id>https://antarx.com/2018/06/11/ted-categories/</id>
    <published>2018-06-11T08:43:05.000Z</published>
    <updated>2018-06-25T13:23:02.000Z</updated>
    
    <content type="html"><![CDATA[<ol start="165"><li><p><a href="https://www.bilibili.com/video/av24693241" target="_blank" rel="noopener">【TED演讲】怎样的压力，会让一个人放弃生命？</a></p></li><li><p><a href="https://www.bilibili.com/video/av24595777" target="_blank" rel="noopener">「TED/4P字幕」语言如何形塑出我们的思考方式，多学一门语言的好处 /How language shapes the way we think</a></p></li><li><p><a href="https://www.bilibili.com/video/av8247183/index_52.html" target="_blank" rel="noopener">邪教组织如何重新连接大脑</a></p></li></ol><ol start="184"><li><a href="https://www.bilibili.com/video/av18400402" target="_blank" rel="noopener">【TED双语】推动学习革命_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></li></ol><p><a href="https://www.ornaross.com/wb-yeats-poems-inspired-by-maud-gonne/" target="_blank" rel="noopener">WB Yeats Poems Inspired By Maud Gonne | Indie Author Orna Ross</a></p><pre><code>&gt; He Wishes for the Cloths of Heaven,  Had I the heavens’ embroidered cloths,  Enwrought with golden and silver light,  The blue and the dim and the dark cloths  Of night and light and the half-light,  I would spread the cloths under your feet:  But I, being poor, have only my dreams;  I have spread my dreams under your feet;  Tread softly because you tread on my dreams.</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol start=&quot;165&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av24693241&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【TED演讲】怎样的压力，会让一个人放弃生命？&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>go docker client 使用教程（二）</title>
    <link href="https://antarx.com/2018/06/01/go-docker-02/"/>
    <id>https://antarx.com/2018/06/01/go-docker-02/</id>
    <published>2018-06-01T03:05:44.000Z</published>
    <updated>2018-06-01T08:12:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-client-for-golang-使用教程（二）：网络"><a href="#Docker-client-for-golang-使用教程（二）：网络" class="headerlink" title="Docker client for golang 使用教程（二）：网络"></a>Docker client for golang 使用教程（二）：网络</h1><h2 id="端口绑定"><a href="#端口绑定" class="headerlink" title="端口绑定"></a>端口绑定</h2><p>将微服务放到 docker 容器中运行的时候，端口绑定是一个无可避免的问题。在 docker 命令行中，可以通过简单的<code>-p 8080:80</code>解决问题。但在 golang client 中，问题却变得复杂起来。</p><p>首先来看创建容器的函数签名<code>func (cli *Client) ContainerCreate(ctx context.Context, config *container.Config, hostConfig *container.HostConfig, networkingConfig *network.NetworkingConfig, containerName string) (container.ContainerCreateCreatedBody, error)</code>,client 把运行配置拆分成了<code>container.Config</code> 和 <code>container.HostConfig</code> ，也就是容器内部设置和宿主机设置两项。</p><p>要实现端口绑定，首先要在容器设置中设定暴露的端口（exposed ports）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exports := <span class="built_in">make</span>(nat.PortSet, <span class="number">10</span>)</span><br><span class="line">port, _ := nat.NewPort(<span class="string">"tcp"</span>, <span class="string">"80"</span>)</span><br><span class="line">exports[port] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="comment">// in config:</span></span><br><span class="line">cli.ContainerCreate(ctx, &amp;container.Config&#123;</span><br><span class="line">        ExposedPorts:exports,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在 host.config 中，设置Host 端口与容器暴露出来的端口的绑定。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ports := <span class="built_in">make</span>(nat.PortMap)</span><br><span class="line">pb := <span class="built_in">make</span>([]nat.PortBinding,<span class="number">0</span>)</span><br><span class="line">pb = <span class="built_in">append</span>(pb,nat.PortBinding&#123;</span><br><span class="line">    HostPort:<span class="string">"8080"</span>,</span><br><span class="line">&#125;)</span><br><span class="line">ports[port] = pb</span><br><span class="line"></span><br><span class="line"><span class="comment">//in Host.config</span></span><br><span class="line">&amp;container.HostConfig&#123;</span><br><span class="line">    PortBindings:ports,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，在代码中就实现了端口绑定的操作。然而，如果只执行到这一步，编译器一般会报非常诡异的<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://antarx.cn/20180601160556_bNP72x_8DD0D6668316EECC0F8DCE8B1E8EEA76.jpeg" alt="类型不匹配错误" title>                </div>                <div class="image-caption">类型不匹配错误</div>            </figure></p><p>参考<a href="https://www.jianshu.com/p/283f32fc045a" target="_blank" rel="noopener">go操作docker - 简书</a>的解决方法，删除gopath里面pkg下面docker的vendor里面相应的connections包，然后运行<code>go get github.com/docker/go-connections/nat</code> ，问题解决。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul><li><a href="https://godoc.org/github.com/docker/docker/client#Client.ContainerCreate" target="_blank" rel="noopener">client - GoDoc</a></li><li><a href="https://www.jianshu.com/p/283f32fc045a" target="_blank" rel="noopener">go操作docker - 简书</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker-client-for-golang-使用教程（二）：网络&quot;&gt;&lt;a href=&quot;#Docker-client-for-golang-使用教程（二）：网络&quot; class=&quot;headerlink&quot; title=&quot;Docker client for gola
      
    
    </summary>
    
    
      <category term="go" scheme="https://antarx.com/tags/go/"/>
    
      <category term="golang" scheme="https://antarx.com/tags/golang/"/>
    
      <category term="docker" scheme="https://antarx.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>go docker client 使用教程（一）</title>
    <link href="https://antarx.com/2018/05/29/go-docker-01/"/>
    <id>https://antarx.com/2018/05/29/go-docker-01/</id>
    <published>2018-05-29T03:05:41.000Z</published>
    <updated>2018-05-29T03:39:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-client-for-golang-使用教程（一）"><a href="#Docker-client-for-golang-使用教程（一）" class="headerlink" title="Docker client for golang 使用教程（一）"></a>Docker client for golang 使用教程（一）</h1><p>Docker 官方提供了适用于 golang 的 <a href="https://github.com/moby/moby/tree/master/client" target="_blank" rel="noopener">client</a>，可惜的是网上几乎没有完整可用的使用教程或者例子。在开发<a href="https://github.com/gawainx/gxd-cli" target="_blank" rel="noopener">gxd-cli</a>的过程中，需要大量使用到这个 SDK，所以便有了这个系列。</p><p>本篇涉及通过代码运行第一个容器，以及如何挂载卷。<br><a id="more"></a></p><h2 id="运行第一个容器"><a href="#运行第一个容器" class="headerlink" title="运行第一个容器"></a>运行第一个容器</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Gawain Open Source Project</span></span><br><span class="line"><span class="comment"> *Author: Gawain Antarx</span></span><br><span class="line"><span class="comment"> *Create Date: 2018-May-29</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/docker/docker/client"</span></span><br><span class="line"><span class="string">"github.com/docker/docker/api/types"</span></span><br><span class="line"><span class="string">"github.com/docker/docker/api/types/container"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line">cli, err := client.NewClientWithOpts(client.WithVersion(<span class="string">"1.37"</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp, err := cli.ContainerCreate(ctx, &amp;container.Config&#123;</span><br><span class="line">Image: <span class="string">"alpine:latest"</span>,</span><br><span class="line">Cmd:   []<span class="keyword">string</span>&#123;<span class="string">"echo"</span>,<span class="string">"hello"</span>&#125;,</span><br><span class="line">&#125;, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">""</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := cli.ContainerStart(ctx, resp.ID, types.ContainerStartOptions&#123;&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">statusCh, errCh := cli.ContainerWait(ctx, resp.ID, container.WaitConditionNotRunning)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> err := &lt;-errCh:</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> &lt;-statusCh:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out, err := cli.ContainerLogs(ctx, resp.ID, types.ContainerLogsOptions&#123;ShowStdout: <span class="literal">true</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">io.Copy(os.Stdout, out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方使用<code>client.NewEnvClient()</code>来初始化<code>client</code>，在 IDE 中提示这个接口已经过时，推荐使用<code>client.NewClientWithOpts()</code>。要注意的是，直接调用的时候一般会提示 API 版本不匹配，需要加<code>client.WithVersion(&quot;1.37&quot;)</code>作为参数传入。<code>1.37</code>部分可以根据它的错误提示自行修改。</p><h2 id="绑定卷"><a href="#绑定卷" class="headerlink" title="绑定卷"></a>绑定卷</h2><p>将自己代码放入容器中运行时最基本的操作，在命令行中通过<code>-v {host vol}:{container vol}</code>实现，在 golang sdk 中，开发者却没有提供这部分的重要说明。通过查阅<a href="https://github.com/fsouza/go-dockerclient/issues/155" target="_blank" rel="noopener">issue155</a>以及<a href="https://github.com/fsouza/go-dockerclient/issues/132" target="_blank" rel="noopener">issue1</a>，得到的解决方案如下。</p><p>卷绑定通过<code>client.ContainerStart()</code>里面的参数<code>client.HostConfig</code>结构的<code>Binds</code>传入，传入的类型是<code>[]string</code>，这个字符串序列的中每个字符串的格式<code>{host_vol}:{com_col}</code>，也就是和命令行的一致。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-client-for-golang-使用教程（一）&quot;&gt;&lt;a href=&quot;#Docker-client-for-golang-使用教程（一）&quot; class=&quot;headerlink&quot; title=&quot;Docker client for golang 使用教程（一）&quot;&gt;&lt;/a&gt;Docker client for golang 使用教程（一）&lt;/h1&gt;&lt;p&gt;Docker 官方提供了适用于 golang 的 &lt;a href=&quot;https://github.com/moby/moby/tree/master/client&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;client&lt;/a&gt;，可惜的是网上几乎没有完整可用的使用教程或者例子。在开发&lt;a href=&quot;https://github.com/gawainx/gxd-cli&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gxd-cli&lt;/a&gt;的过程中，需要大量使用到这个 SDK，所以便有了这个系列。&lt;/p&gt;
&lt;p&gt;本篇涉及通过代码运行第一个容器，以及如何挂载卷。&lt;br&gt;
    
    </summary>
    
    
      <category term="docker" scheme="https://antarx.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>LaTeX排版学术论文工具链</title>
    <link href="https://antarx.com/2018/05/21/latex-toolchain/"/>
    <id>https://antarx.com/2018/05/21/latex-toolchain/</id>
    <published>2018-05-21T02:48:35.000Z</published>
    <updated>2018-05-24T08:59:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LaTeX-排版工具链"><a href="#LaTeX-排版工具链" class="headerlink" title="LaTeX 排版工具链"></a>LaTeX 排版工具链</h1><p> 这里整理了 $\LaTeX$ 排版学术论文的工具链。根据自己的实践和大家的留言补充定期更新。<br><a id="more"></a></p><h2 id="操作系统，软件等"><a href="#操作系统，软件等" class="headerlink" title="操作系统，软件等"></a>操作系统，软件等</h2><p>$\LaTeX$ 可以在 Windows、Linux 和 macOS 平台上运行。Windows 上可以安装 MikTex，Linux 上有 TeX Live，考虑美观度和排版过程的愉悦度，本人使用的 LaTeX 排版环境大致如下：</p><ul><li>OS : macOS(Darwin)</li><li>编辑器：<a href="https://code.visualstudio.com" target="_blank" rel="noopener">Microsoft VSCode</a></li><li>插件：LaTeX Workshop</li><li>$\LaTeX$ 软件：MacTeX 工具包</li><li>PDF 阅读工具：skim</li></ul><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p><a href="https://github.com/uefs/ieee-template-latex/blob/master/bare_jrnl.tex" target="_blank" rel="noopener">IEEE tran</a><br><code>bare_jrnl.tex</code>最新版本应该是 v1.7，但在网上好像找不到这个最新的版本，准备整理一个多文件编译的版本放到 GitHub 上。</p><p>欢迎留言补充其它模板。:)</p><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><p><a href="http://mohu.org/info/symbols/symbols.htm" target="_blank" rel="noopener">数学符号集</a></p><h2 id="插入伪代码（算法宏包的相关使用）"><a href="#插入伪代码（算法宏包的相关使用）" class="headerlink" title="插入伪代码（算法宏包的相关使用）"></a>插入伪代码（算法宏包的相关使用）</h2><p><a href="https://www.zybuluo.com/jfruan/note/720298" target="_blank" rel="noopener">LaTeX算法排版</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>使用<code>listings</code>宏包。<a href="https://en.wikibooks.org/wiki/LaTeX/Source_Code_Listings" target="_blank" rel="noopener">LaTeX/Source Code Listings</a><br>但这个宏包没有 golang 语法高亮支持的！要使 golang 语法高亮，可添加宏包<a href="https://github.com/julienc91/listings-golang" target="_blank" rel="noopener">listings-golang</a></p><h2 id="图片与表格"><a href="#图片与表格" class="headerlink" title="图片与表格"></a>图片与表格</h2><p>首先要理解浮动体的概念，<a href="https://liam0205.me/2017/04/30/floats-in-LaTeX-the-positioning-algorithm/" target="_blank" rel="noopener">LaTeX 中的浮动体：浮动算法</a></p><h2 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h2><p><a href="http://www.latexstudio.net" target="_blank" rel="noopener">LaTeX 开源小屋</a><br><a href="https://github.com/luongvo209/Begin-Latex-in-minutes" target="_blank" rel="noopener">Begin LaTeX in minutes</a><br><a href="https://book.douban.com/subject/24703731/" target="_blank" rel="noopener">LaTeX 入门</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LaTeX-排版工具链&quot;&gt;&lt;a href=&quot;#LaTeX-排版工具链&quot; class=&quot;headerlink&quot; title=&quot;LaTeX 排版工具链&quot;&gt;&lt;/a&gt;LaTeX 排版工具链&lt;/h1&gt;&lt;p&gt; 这里整理了 $\LaTeX$ 排版学术论文的工具链。根据自己的实践和大家的留言补充定期更新。&lt;br&gt;
    
    </summary>
    
    
      <category term="LaTeX" scheme="https://antarx.com/tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>博客迁移腾讯云小记</title>
    <link href="https://antarx.com/2018/05/11/hexossl/"/>
    <id>https://antarx.com/2018/05/11/hexossl/</id>
    <published>2018-05-11T09:30:58.000Z</published>
    <updated>2018-05-14T03:12:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="博客迁移腾讯云实战记录"><a href="#博客迁移腾讯云实战记录" class="headerlink" title="博客迁移腾讯云实战记录"></a>博客迁移腾讯云实战记录</h1><p>源于年初的一次突发奇想，将博客站点迁移到了腾讯云，五月份终于完成了备案，然后添加了 HTTPS 支援，并完成容器化。在这里把折腾的过程记录下来。</p><a id="more"></a><h2 id="转移腾讯云"><a href="#转移腾讯云" class="headerlink" title="转移腾讯云"></a>转移腾讯云</h2><p>原来的博客是放到 github page 上面，访问 <strong>antarx.com</strong> 是通过 CNAME 文件解析到 gawainx.github.io，只需要在<code>config.yaml</code>配置好，写完直接<code>hexo d -g</code>完事。</p><p>迁移到腾讯云之后，还想每次部署都这么方便，就免不了完成一些相关工作。</p><h3 id="资源准备"><a href="#资源准备" class="headerlink" title="资源准备"></a>资源准备</h3><p>这里准备的资源主要就是服务器的购入，可以根据自己博客的规模需要选择合适的套餐。如果是学生党记得使用学生优惠。<br>买完服务器就是装系统的事，根据自己的使用习惯自行选择，我用的是 ubuntu16.04.<br>如果想容器化的话需要安装 Docker。</p><h3 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><h3 id="新建-git-裸仓库"><a href="#新建-git-裸仓库" class="headerlink" title="新建 git 裸仓库"></a>新建 git 裸仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /var/repo/</span><br><span class="line">sudo chown -R $USER:$USER /var/repo/</span><br><span class="line">sudo chmod -R 755 /var/repo/</span><br><span class="line"></span><br><span class="line">cd /var/repo/</span><br><span class="line">git init --bare hexo_static.git</span><br></pre></td></tr></table></figure><h3 id="创建存放-hexo-生成的网页的文件夹"><a href="#创建存放-hexo-生成的网页的文件夹" class="headerlink" title="创建存放 hexo 生成的网页的文件夹"></a>创建存放 hexo 生成的网页的文件夹</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /var/www/hexo</span><br><span class="line">sudo chown -R $USER:$USER /var/www/hexo</span><br><span class="line">sudo chmod -R 755 /var/www/hexo</span><br></pre></td></tr></table></figure><p>这两步要注意的是文件夹的 owner 问题，要实现自动部署的话一般新建一个 git 账户然后全权接管部署网页的相关工作，那么上面创建的两个文件夹在后期的 owner 记得要变更为 git 用户。</p><h3 id="创建-git-钩子"><a href="#创建-git-钩子" class="headerlink" title="创建 git 钩子"></a>创建 git 钩子</h3><p>在<code>hexo_static.git</code>文件夹的 hooks 目录下面新建钩子文件并写入如下代码，然后将文件变更成可执行文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim /var/repo/hexo_static.git/hooks/post-receive</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> post-receive file content</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">git --work-tree=/var/www/hexo --git-dir=/var/repo/hexo_static.git checkout -f</span><br><span class="line"></span><br><span class="line">chmod +x /var/repo/hexo_static.git/hooks/post-receive</span><br></pre></td></tr></table></figure><h3 id="自动部署"><a href="#自动部署" class="headerlink" title="自动部署"></a>自动部署</h3><p>所谓自动部署，就是在每次部署的时候不需要键入密码。<br>在自己电脑上，创建公钥，复制到剪贴板</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "xx@xx.com"</span><br><span class="line">pbcopy &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>服务器上，切换到 git 用户（没有的话请新建），输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">su git</span><br><span class="line">cd ~</span><br><span class="line">mkdir .ssh</span><br><span class="line">vim .ssh/authorized_keys</span><br><span class="line"><span class="meta">#</span><span class="bash">粘贴自己电脑的 公钥，然后保存</span></span><br><span class="line">chmod 600 ~/.ssh/authorized_keys</span><br><span class="line">chmod 700 ~/.ssh</span><br></pre></td></tr></table></figure><h3 id="本地-hexo-git-配置"><a href="#本地-hexo-git-配置" class="headerlink" title="本地 hexo-git 配置"></a>本地 hexo-git 配置</h3><p>在<code>config.yaml</code>键入</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">    type:</span> git</span><br><span class="line"><span class="attr">    repo:</span> git@CVM 云服务器的IP地址:/var/repo/hexo_static</span><br><span class="line"><span class="attr">    branch:</span> master</span><br></pre></td></tr></table></figure><h2 id="添加-SSL-证书并容器化-Nginx"><a href="#添加-SSL-证书并容器化-Nginx" class="headerlink" title="添加 SSL 证书并容器化 Nginx"></a>添加 SSL 证书并容器化 Nginx</h2><p>Linux 配置软件向来复杂，所以毫不犹豫选用 docker 容器进行 Nginx 部署。<br>输入<code>docker pull nginx</code>拉取 Nginx 镜像。</p><p>首先基于镜像运行一个 nginx 容器，然后将容器里面的<code>/etc/nginx/</code>目录拷贝出来。可以看到文件内容如下图<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://antarx.cn/20180514104132_CkMTT5_Screenshot.jpeg" alt="Nginx 配置目录" title>                </div>                <div class="image-caption">Nginx 配置目录</div>            </figure>。<br>这里顺带一提 Nginx 的两个配置文件，<code>nginx.conf</code>和<code>deafult.conf</code>，一般而言修改<code>nginx.conf</code>然后把<code>deafult</code>里面的内容注释掉会比较妥当。</p><h3 id="添加-SSL-证书"><a href="#添加-SSL-证书" class="headerlink" title="添加 SSL 证书"></a>添加 SSL 证书</h3><p>在拷贝出来的<code>nginx.conf</code>文件，在<code>http</code>的选型里面，加入以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 443;</span><br><span class="line">        server_name 你的站点名称; #填写绑定证书的域名</span><br><span class="line">        ssl on;</span><br><span class="line">        ssl_certificate /cert/你的证书.crt;</span><br><span class="line">        ssl_certificate_key /cert/你的私钥.key;</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   /blog; #站点目录</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果强制使用 HTTPS，还要加上以下配置，将80端口的流量重定向到443端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name antarx.com;</span><br><span class="line">        rewrite ^(.*)$ https://$&#123;server_name&#125;$1 permanent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这两个 server 是独立的，都加到<code>http</code>的配置里面。<br>顺带一提 Nginx 要求的证书是 PEM 格式。</p><p>运行博客容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 443:443 -p 80:80 -v `pwd`:/etc/nginx -v /var/www/hexo:/hexo -v "$PWD/cert":/cert --name ng nginx</span><br></pre></td></tr></table></figure><p>这里注意到的是三个挂载卷，分别是配置文件，博客网页文件和证书文件。</p><p>容器运行之后，在腾讯云的域名管理里面添加 DNS 记录，OK，大功告成。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://cloud.tencent.com/developer/article/1004587" target="_blank" rel="noopener">在 Ubuntu 14.04 服务器上部署 Hexo 博客</a><br><a href="https://cloud.tencent.com/developer/article/1004839" target="_blank" rel="noopener">Hello Hexo之静态博客搭建+自动部署</a><br><a href="https://cloud.tencent.com/document/product/400/4143" target="_blank" rel="noopener">证书安装指引</a><br><a href="http://www.ruanyifeng.com/blog/2018/02/nginx-docker.html" target="_blank" rel="noopener">Nginx 容器教程（可能无法访问）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;博客迁移腾讯云实战记录&quot;&gt;&lt;a href=&quot;#博客迁移腾讯云实战记录&quot; class=&quot;headerlink&quot; title=&quot;博客迁移腾讯云实战记录&quot;&gt;&lt;/a&gt;博客迁移腾讯云实战记录&lt;/h1&gt;&lt;p&gt;源于年初的一次突发奇想，将博客站点迁移到了腾讯云，五月份终于完成了备案，然后添加了 HTTPS 支援，并完成容器化。在这里把折腾的过程记录下来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://antarx.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>gorequest中文文档(非官方)</title>
    <link href="https://antarx.com/2018/05/05/gorequest-doc/"/>
    <id>https://antarx.com/2018/05/05/gorequest-doc/</id>
    <published>2018-05-05T11:19:43.000Z</published>
    <updated>2018-05-24T08:59:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gorequest指南"><a href="#Gorequest指南" class="headerlink" title="Gorequest指南"></a>Gorequest指南</h1><p><a href="https://github.com/parnurzeal/gorequest" target="_blank" rel="noopener">gorequest</a>为 golang 程序提供了极为简便的方式发起 HTTP 请求。网上关于这个库的中文教程不多，因此把官方的 README 文件翻译过来，结合自己的一些使用经验，希望能为各位 Gopher 提供一些帮助。<br><a id="more"></a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/parnurzeal/gorequest/gh-pages/images/Gopher_GoRequest_400x300.jpg" alt="GopherGoRequest" title>                </div>                <div class="image-caption">GopherGoRequest</div>            </figure><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>支持发送Get/Post/Put/Head/Delete/Patch/Options 请求</li><li>建议的请求头设置</li><li>JSON 支持：以 JSON 格式字符串作为函数参数的方式简化传输 JSON 的步骤。</li><li>分段支持：分段请求（Multipart Request）的方式发送数据或传输文件</li><li>代理：支援通过代理的方式发送请求。</li><li>Timeout：为请求设置时间限制</li><li>TLS(传输层安全协议)相关设定。<blockquote><p>TLSClientConfig - taking control over tls where at least you can disable security check for https</p></blockquote></li><li>重定向策略</li><li>Cookie：为请求添加 cookie</li><li>CookieJar - automatic in-memory cookiejar</li><li>基本的权限认证。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get github.com/parnurzeal/gorequest</span></span><br></pre></td></tr></table></figure><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>参阅<a href="http://godoc.org/github.com/parnurzeal/gorequest" target="_blank" rel="noopener">Go Doc</a><br>后续我会根据自己在开发中使用经验将文档翻译过来。</p><h2 id="使用-GoRequest-的一万个理由？"><a href="#使用-GoRequest-的一万个理由？" class="headerlink" title="使用 GoRequest 的一万个理由？"></a>使用 GoRequest 的一万个理由？</h2><p>通过 GoRequest 可以使工作变得更简单，使可以发起 HTTP 请求这件事更加优雅而充满乐趣。</p><p>不使用本库发起简单 GET 请求：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(<span class="string">"http://example.com/"</span>)</span><br></pre></td></tr></table></figure><p>使用 GoRequest</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request := gorequest.New()</span><br><span class="line">resp, body, errs := request.Get(<span class="string">"http://example.com/"</span>).End()</span><br></pre></td></tr></table></figure><p>如果你不想重用<code>request</code>，也可以写成下面这样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resp, body, errs := gorequest.New().Get(<span class="string">"http://example.com/"</span>).End()</span><br></pre></td></tr></table></figure><p>如果你需要设定 HTTP 头，设定重定向策略等，使用标准库会瞬间使事情变得异常复杂，在发起仅仅一个 <strong>GET</strong> 请求的过程，你就需要一个 <code>Client</code>，通过一系列不同的命令来设定 HTTP 头（<code>HTTP Headers</code>）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">client := &amp;http.Client&#123;</span><br><span class="line">  CheckRedirect: redirectPolicyFunc,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">req, err := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"http://example.com"</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">req.Header.Add(<span class="string">"If-None-Match"</span>, <span class="string">`W/"wyzzy"`</span>)</span><br><span class="line">resp, err := client.Do(req)</span><br></pre></td></tr></table></figure><p>现在，你有更加美妙的方式来完成这件事</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">request := gorequest.New()</span><br><span class="line">resp, body, errs := request.Get(<span class="string">"http://example.com"</span>).</span><br><span class="line">  RedirectPolicy(redirectPolicyFunc).</span><br><span class="line">  Set(<span class="string">"If-None-Match"</span>, <span class="string">`W/"wyzzy"`</span>).</span><br><span class="line">  End()</span><br></pre></td></tr></table></figure><p>发起 <strong>DELETE</strong>, <strong>HEAD</strong>, <strong>POST</strong>, <strong>PUT</strong>, <strong>PATCH</strong> 请求的过程和发起 <strong>GET</strong> 请求类似。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">request := gorequest.New()</span><br><span class="line">resp, body, errs := request.Post(<span class="string">"http://example.com"</span>).End()</span><br><span class="line"><span class="comment">// PUT -&gt; request.Put("http://example.com").End()</span></span><br><span class="line"><span class="comment">// DELETE -&gt; request.Delete("http://example.com").End()</span></span><br><span class="line"><span class="comment">// HEAD -&gt; request.Head("http://example.com").End()</span></span><br><span class="line"><span class="comment">// ANYTHING -&gt; request.CustomMethod("TRACE", "http://example.com").End()</span></span><br></pre></td></tr></table></figure><h3 id="处理-JSON"><a href="#处理-JSON" class="headerlink" title="处理 JSON"></a>处理 JSON</h3><p>用标准库发起 <strong>JSON POST</strong> ，你需要先将 <code>map</code> 或者 <code>struct</code>格式的数据包装（<strong>Marshal</strong>）成 JSON 格式的数据，将头参数设定为’application/json’（必要时还要设定其他头），然后要新建一个<code>http.CLient</code>变量。经过这一系列的步骤，你的代码变得冗长而难以维护</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"backy"</span>,</span><br><span class="line">  <span class="string">"species"</span>: <span class="string">"dog"</span>,</span><br><span class="line">&#125;</span><br><span class="line">mJson, _ := json.Marshal(m)</span><br><span class="line">contentReader := bytes.NewReader(mJson)</span><br><span class="line">req, _ := http.NewRequest(<span class="string">"POST"</span>, <span class="string">"http://example.com"</span>, contentReader)</span><br><span class="line">req.Header.Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">req.Header.Set(<span class="string">"Notes"</span>,<span class="string">"GoRequest is coming!"</span>)</span><br><span class="line">client := &amp;http.Client&#123;&#125;</span><br><span class="line">resp, _ := client.Do(req)</span><br></pre></td></tr></table></figure><p>至于 GoRequest， JSON 支持是必须的，所以，用这个库你只需要一行代码完成所有工作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">request := gorequest.New()</span><br><span class="line">resp, body, errs := request.Post(<span class="string">"http://example.com"</span>).</span><br><span class="line">  Set(<span class="string">"Notes"</span>,<span class="string">"gorequst is coming!"</span>).</span><br><span class="line">  Send(<span class="string">`&#123;"name":"backy", "species":"dog"&#125;`</span>).</span><br><span class="line">  End()</span><br></pre></td></tr></table></figure><p>另外，它同样支持结构体类型。所以，你可以在你的请求中发送不同的数据类型（So, you can have a fun <strong>Mix &amp; Match</strong> sending the different data types for your request）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BrowserVersionSupport <span class="keyword">struct</span> &#123;</span><br><span class="line">  Chrome <span class="keyword">string</span></span><br><span class="line">  Firefox <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">ver := BrowserVersionSupport&#123; Chrome: <span class="string">"37.0.2041.6"</span>, Firefox: <span class="string">"30.0"</span> &#125;</span><br><span class="line">request := gorequest.New()</span><br><span class="line">resp, body, errs := request.Post(<span class="string">"http://version.com/update"</span>).</span><br><span class="line">  Send(ver).</span><br><span class="line">  Send(<span class="string">`&#123;"Safari":"5.1.10"&#125;`</span>).</span><br><span class="line">  End()</span><br></pre></td></tr></table></figure><p>Not only for <code>Send()</code> but <code>Query()</code> is also supported. Just give it a try! :)</p><h2 id="回调（Callback）"><a href="#回调（Callback）" class="headerlink" title="回调（Callback）"></a>回调（Callback）</h2><p>此外，GoRequest 支持回调函数，这让你可以更加灵活的使用这个库。<br>下面是回调函数的一个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printStatus</span><span class="params">(resp gorequest.Response, body <span class="keyword">string</span>, errs []error)</span></span>&#123;</span><br><span class="line">  fmt.Println(resp.Status)</span><br><span class="line">&#125;</span><br><span class="line">gorequest.New().Get(<span class="string">"http://example.com"</span>).End(printStatus)</span><br></pre></td></tr></table></figure><h2 id="Multipart-Form-Data"><a href="#Multipart-Form-Data" class="headerlink" title="Multipart/Form-Data"></a>Multipart/Form-Data</h2><p>你可以将请求的内容类型设定为<code>multipart</code>来以<code>multipart/form-data</code>的方式发送所有数据。这个特性可以帮助你发送多个文件。<br>下面是一个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gorequest.New().Post(<span class="string">"http://example.com/"</span>).</span><br><span class="line">  Type(<span class="string">"multipart"</span>).</span><br><span class="line">  Send(<span class="string">`&#123;"query1":"test"&#125;`</span>).</span><br><span class="line">  End()</span><br></pre></td></tr></table></figure><p>如果感兴趣可以在文档中查看<code>SendFile</code>函数部分获取更多。</p><h2 id="代理（Proxy）"><a href="#代理（Proxy）" class="headerlink" title="代理（Proxy）"></a>代理（Proxy）</h2><p>需要使用代理的时候，可以用 GoRequest Proxy Func 很好的处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">request := gorequest.New().Proxy(<span class="string">"http://proxy:999"</span>)</span><br><span class="line">resp, body, errs := request.Get(<span class="string">"http://example-proxy.com"</span>).End()</span><br><span class="line"><span class="comment">// To reuse same client with no_proxy, use empty string:</span></span><br><span class="line">resp, body, errs = request.Proxy(<span class="string">""</span>).Get(<span class="string">"http://example-no-proxy.com"</span>).End()</span><br></pre></td></tr></table></figure><h2 id="基本认证"><a href="#基本认证" class="headerlink" title="基本认证"></a>基本认证</h2><p>添加基本的认证头信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request := gorequest.New().SetBasicAuth(<span class="string">"username"</span>, <span class="string">"password"</span>)</span><br><span class="line">resp, body, errs := request.Get(<span class="string">"http://example-proxy.com"</span>).End()</span><br></pre></td></tr></table></figure><h2 id="超时处理（Timeout）"><a href="#超时处理（Timeout）" class="headerlink" title="超时处理（Timeout）"></a>超时处理（Timeout）</h2><p>与 <code>time</code> 库结合可以设置成任何的时间限制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request := gorequest.New().Timeout(<span class="number">2</span>*time.Millisecond)</span><br><span class="line">resp, body, errs:= request.Get(<span class="string">"http://example.com"</span>).End()</span><br></pre></td></tr></table></figure><p><code>Timeout</code> 函数同时设定了连接和 IO 的时间限制。</p><h2 id="以字节方式处理返回体（EndBytes）"><a href="#以字节方式处理返回体（EndBytes）" class="headerlink" title="以字节方式处理返回体（EndBytes）"></a>以字节方式处理返回体（EndBytes）</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resp, bodyBytes, errs := gorequest.New().Get(<span class="string">"http://example.com/"</span>).EndBytes()</span><br></pre></td></tr></table></figure><h2 id="以结构体的方式处理返回体"><a href="#以结构体的方式处理返回体" class="headerlink" title="以结构体的方式处理返回体"></a>以结构体的方式处理返回体</h2><p>假设 URL <strong><a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a></strong> 的返回体<code>{&quot;hey&quot;:&quot;you&quot;}</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">heyYou <span class="keyword">struct</span> &#123;</span><br><span class="line">  Hey <span class="keyword">string</span> <span class="string">`json:"hey"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> heyYou heyYou</span><br><span class="line"></span><br><span class="line">resp, _, errs := gorequest.New().Get(<span class="string">"http://example.com/"</span>).EndStruct(&amp;heyYou)</span><br></pre></td></tr></table></figure><h2 id="连续重复请求（Retry）"><a href="#连续重复请求（Retry）" class="headerlink" title="连续重复请求（Retry）"></a>连续重复请求（Retry）</h2><p>假设你在得到 BadRequest 或服务器内部错误（InternalServerError）时进行连续三次，间隔五秒的连接尝试</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">request := gorequest.New()</span><br><span class="line">resp, body, errs := request.Get(<span class="string">"http://example.com/"</span>).</span><br><span class="line">                    Retry(<span class="number">3</span>, <span class="number">5</span> * time.Second, http.StatusBadRequest, http.StatusInternalServerError).</span><br><span class="line">                    End()</span><br></pre></td></tr></table></figure><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><blockquote><p>Redirects can be handled with RedirectPolicy which behaves similarly to net/http Client’s <a href="https://golang.org/pkg/net/http#Client" target="_blank" rel="noopener">CheckRedirect function</a>. Simply specify a function which takes the Request about to be made and a slice of previous Requests in order of oldest first. When this function returns an error, the Request is not made.</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">request := gorequest.New()</span><br><span class="line">resp, body, errs := request.Get(<span class="string">"http://example.com/"</span>).</span><br><span class="line">                    RedirectPolicy(<span class="function"><span class="keyword">func</span><span class="params">(req Request, via []*Request)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">                      <span class="keyword">if</span> req.URL.Scheme != <span class="string">"https"</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> http.ErrUseLastResponse</span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;).</span><br><span class="line">                    End()</span><br></pre></td></tr></table></figure><h2 id="Debug-模式"><a href="#Debug-模式" class="headerlink" title="Debug 模式"></a>Debug 模式</h2><blockquote><p>For debugging, GoRequest leverages <code>httputil</code> to dump details of every request/response. (Thanks to @dafang).You can just use <code>SetDebug</code> or environment variable <code>GOREQUEST_DEBUG=0|1</code> to enable/disable debug mode and <code>SetLogger</code> to set your own choice of logger.Thanks to @QuentinPerez, we can see even how gorequest is compared to CURL by using <code>SetCurlCommand</code>.</p></blockquote><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p><code>gorequest.New()</code>函数应该一次调用，对返回的实例尽可能多次使用。</p><h2 id="Credits"><a href="#Credits" class="headerlink" title="Credits"></a>Credits</h2><ul><li>Renee French - the creator of Gopher mascot</li><li><a href="https://www.facebook.com/puairw" target="_blank" rel="noopener">Wisi Mongkhonsrisawat</a> for providing an awesome GoRequest’s Gopher image :)</li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>GoRequest is MIT License.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Gorequest指南&quot;&gt;&lt;a href=&quot;#Gorequest指南&quot; class=&quot;headerlink&quot; title=&quot;Gorequest指南&quot;&gt;&lt;/a&gt;Gorequest指南&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/parnurzeal/gorequest&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gorequest&lt;/a&gt;为 golang 程序提供了极为简便的方式发起 HTTP 请求。网上关于这个库的中文教程不多，因此把官方的 README 文件翻译过来，结合自己的一些使用经验，希望能为各位 Gopher 提供一些帮助。&lt;br&gt;
    
    </summary>
    
    
      <category term="go" scheme="https://antarx.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>使用mage实现交叉编译</title>
    <link href="https://antarx.com/2018/04/23/mage2/"/>
    <id>https://antarx.com/2018/04/23/mage2/</id>
    <published>2018-04-23T03:17:36.000Z</published>
    <updated>2018-05-24T08:59:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>golang 为微服务的开发带来了无可比拟的便利。使用的时候也自然而言发现一些问题，因为 golang 不像 Java 有 Maven 这样的打包工具，而是直接编译成二进制可执行文件，所以在开发机（macOS）上编译出来的可执行文件是无法在服务器或者 docker 容器里运行的，如果把源代码提交上去服务器编译，又会带来重新下载依赖包的麻烦（golang 的包依赖关系管理方面的缺失是我认为 golang 为数不多的缺点之一）。最近一直在思考有没有类似 Makefile 的方式来解决这件事（如果只想交叉编译的话直接用 go build或者借助 <a href="https://github.com/mitchellh/gox" target="_blank" rel="noopener">gox</a> 等工具也不是不可以，可还是，不够方便）。直到之前 ing 大神给我推荐了 Hugo 这个静态博客框架，虽然目前因为找不到合适的博客主题没有从 hexo 迁移过去，但看源代码的时候有了一个重要的收获，就是<a href="https://magefile.org" target="_blank" rel="noopener">mage</a><br>关于 mage 的基本安装和使用详见<a href>mage 使用教程(一)</a><br><a id="more"></a></p><h2 id="golang-交叉编译的基本原理"><a href="#golang-交叉编译的基本原理" class="headerlink" title="golang 交叉编译的基本原理"></a>golang 交叉编译的基本原理</h2><p>交叉编译的实现主要是依靠三个参数，<code>CGO_ENABLE</code>,<code>GOOS</code>,<code>GOARCH</code><br><code>CGO_ENABLE</code>在源代码中使用 C/C++时必须开启，这样就无法实现交叉编译了，这部分代码还是得具体平台生成特定的代码。因此，交叉编译是在没有混编代码的前提下的。将<code>CGO_ENABLE</code>设为0，表示关闭。<br><code>GOOS</code>是目标操作系统，macOS 对应的是<code>darwin</code>，Linux 平台对应的是<code>linux</code>。<br><code>GOARCH</code>是目标架构，一般设为<code>amd64</code><br>按照如上所述设定要编译参数之后再执行<code>go build</code>即可生成目标平台的代码。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build mega</span></span><br><span class="line"><span class="comment">// magefile.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Linux</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//设置环境变量</span></span><br><span class="line">    <span class="keyword">var</span> e= <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">e[<span class="string">"CGO_ENABLE"</span>] = <span class="string">"0"</span></span><br><span class="line">e[<span class="string">"GOOS"</span>] = <span class="string">"linux"</span></span><br><span class="line">e[<span class="string">"GOARCH"</span>] = <span class="string">"amd64"</span></span><br><span class="line">name := fmt.Sprintf(<span class="string">"%s-linux-%s"</span>,prefix,VERSION)</span><br><span class="line"><span class="comment">//创建 bin 文件夹</span></span><br><span class="line"><span class="keyword">if</span> err := os.Mkdir(<span class="string">"bin"</span>, <span class="number">0700</span>); err != <span class="literal">nil</span> &amp;&amp; !os.IsExist(err) &#123;</span><br><span class="line">fmt.Errorf(<span class="string">"failed to create %s: %v"</span>, <span class="string">"bin"</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">path := filepath.Join(<span class="string">"bin"</span>,name)</span><br><span class="line">fmt.Println(<span class="string">"Building app for linux..."</span>)</span><br><span class="line"><span class="comment">//运行构建命令</span></span><br><span class="line">err := sh.RunWith(e,<span class="string">"go"</span>,<span class="string">"build"</span>,<span class="string">"-o"</span>,path,<span class="string">"main.go"</span>,<span class="string">"utils.go"</span>,<span class="string">"RESTHandler.go"</span>,<span class="string">"module.go"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Sucessfully Built.Output File: %s\n"</span>,path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在magefile所在文件夹输入 <code>mage linux</code> 即可编译生成适用于 Linux 的运行文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;golang 为微服务的开发带来了无可比拟的便利。使用的时候也自然而言发现一些问题，因为 golang 不像 Java 有 Maven 这样的打包工具，而是直接编译成二进制可执行文件，所以在开发机（macOS）上编译出来的可执行文件是无法在服务器或者 docker 容器里运行的，如果把源代码提交上去服务器编译，又会带来重新下载依赖包的麻烦（golang 的包依赖关系管理方面的缺失是我认为 golang 为数不多的缺点之一）。最近一直在思考有没有类似 Makefile 的方式来解决这件事（如果只想交叉编译的话直接用 go build或者借助 &lt;a href=&quot;https://github.com/mitchellh/gox&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gox&lt;/a&gt; 等工具也不是不可以，可还是，不够方便）。直到之前 ing 大神给我推荐了 Hugo 这个静态博客框架，虽然目前因为找不到合适的博客主题没有从 hexo 迁移过去，但看源代码的时候有了一个重要的收获，就是&lt;a href=&quot;https://magefile.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mage&lt;/a&gt;&lt;br&gt;关于 mage 的基本安装和使用详见&lt;a href&gt;mage 使用教程(一)&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://antarx.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>mage 使用教程(一)</title>
    <link href="https://antarx.com/2018/04/23/mage1/"/>
    <id>https://antarx.com/2018/04/23/mage1/</id>
    <published>2018-04-23T02:24:36.000Z</published>
    <updated>2018-05-24T08:59:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mage 是使用 golang 开发的类 Make的软件构建工具。借助这个工具只需要编写符合 golang 语言规范的代码就可以实现比较复杂的源代码编译。<br><a id="more"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装 mage 之前首先要安装 golang1.7或以上版本。安装好之后，执行以下代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go get -u -d github.com/magefile/mage</span><br><span class="line">cd $GOPATH/src/github.com/magefile/mage</span><br><span class="line">go run bootstrap.go</span><br></pre></td></tr></table></figure><p>编译完成之后，名为 mage 的可执行文件放在<code>$GOPATH/bin</code>目录下，将<code>$GOPATH/bin</code>加入到系统路径即可在终端中直接输入<code>mage</code>运行软件。</p><h2 id="第一个-Magefile"><a href="#第一个-Magefile" class="headerlink" title="第一个 Magefile"></a>第一个 Magefile</h2><p>Magefile 实质是符合 golang 语法的源代码，并且加入了特定的注记，规则如下：</p><ol><li>在包名之前加入一行，<code>// +build mage</code></li><li>包名必须为 <code>main</code></li><li>每个可导出函数会变成可被 mage 执行的选项（类似 Makefile 的每一个 tag）</li><li>每个可导出函数前的注释会被转换成帮助文档</li><li>文件名可以但不一定必须是 Magefile.go</li></ol><p>在任意目录输入<code>mage -init</code>可以生成Magefile.go 模板代码。<br>可以输入以下代码实验以上规则</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build mage</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//Build</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"Building..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Install</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Install</span><span class="params">()</span></span>&#123;</span><br><span class="line">    log.Println(<span class="string">"Installing..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="预备，构建"><a href="#预备，构建" class="headerlink" title="预备，构建"></a>预备，构建</h2><p>构建只需要一行代码<code>mage build</code>，程序就会自动执行 <code>Build</code> 函数，完成整个构建过程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mage 是使用 golang 开发的类 Make的软件构建工具。借助这个工具只需要编写符合 golang 语言规范的代码就可以实现比较复杂的源代码编译。&lt;br&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://antarx.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang 处理 yaml 格式数据</title>
    <link href="https://antarx.com/2018/04/11/goyaml/"/>
    <id>https://antarx.com/2018/04/11/goyaml/</id>
    <published>2018-04-11T09:18:58.000Z</published>
    <updated>2018-05-24T08:59:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>YAML 格式的数据常用来作为配置文件使用, 因此相对来说字段比较固定, 在 golang 中进行解析时跟上一篇提到的解析 json 数据有所区别</p><p>## </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;YAML 格式的数据常用来作为配置文件使用, 因此相对来说字段比较固定, 在 golang 中进行解析时跟上一篇提到的解析 json 数据有所区别&lt;/p&gt;
&lt;p&gt;## &lt;/p&gt;

      
    
    </summary>
    
    
      <category term="golang" scheme="https://antarx.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>go 语言中 JSON 数据的处理</title>
    <link href="https://antarx.com/2018/03/30/gojson/"/>
    <id>https://antarx.com/2018/03/30/gojson/</id>
    <published>2018-03-30T07:20:31.000Z</published>
    <updated>2018-05-24T08:59:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>Golang 中处理 JSON 格式数据主要依赖<code>encoding/json</code>这个库，很多教程（包括 Go 语言圣经）讲 JSON 数据处理时都会定义一个结构体对应于 JSON 数据的各个字段，这种处理方法在 JSON 中字段相对固定时非常实用。但对于字段可能不断变化或者只有一两个字段是固定的时候，如何处理这个问题往往令很多人感到困惑。最近研究 gin 这个库的时候发现一个思路非常值得学习借鉴。<br><a id="more"></a></p><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>说了这么多，其实并不神秘，就是来自 gin 框架源码中的一句关键定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// H is a shortcup for map[string]interface&#123;&#125;</span></span><br><span class="line"><span class="keyword">type</span> H <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>定义了这个数据结构之后，gin 框架就可以处理几乎所有的 JSON 数据。</p><p>同理，我们在自己的代码中想不受结构体限制灵活处理 JSON 数据时，也可以在程序代码中添加类似的定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> message <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>从字符串解析 JSON 数据时，只需要</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//body is string message</span></span><br><span class="line"><span class="keyword">var</span> result mss</span><br><span class="line">json.Unmarshal([]<span class="keyword">byte</span>(body),&amp;result)</span><br></pre></td></tr></table></figure><p>包装 JSON 也类似</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mes is message type</span></span><br><span class="line">bty,err := json.Marshal(mes)</span><br></pre></td></tr></table></figure><p>值得一说的是平时处理 JSON 数据经常出现的反斜杠双引号问题，用这种方法处理时并没有出现。</p><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>背后原理分析。</p><p>这一行代码之所以这么实用是因为<code>interface{}</code>这个 golang 中的“万金油”。Golang 中不存在类和对象的概念，因此空接口就成了所有变量的“超类”一样的存在，可以承载一切的变量。</p><h2 id="潜在问题-and-Further-More"><a href="#潜在问题-and-Further-More" class="headerlink" title="潜在问题 and Further More"></a>潜在问题 and Further More</h2><p>处理 JSON Array 时会出现问题，就是明知它是数组却不能直接用下标进行操作（会提示<code>{}interface</code> 不支持下标，导致编译失败），实际运行时用反射包的<code>reflect.TypeOf</code>查看JSON 数组解析出来的类型明明是<code>[]interface{}</code>，是接口slice，是支持下标操作的。</p><p>原因是 Golang 是静态语言，代码中所有变量的类型都是在编译期确定的，我们所定义的类型中 map 的 value 部分是<code>{}interface</code>，在 运行时接收到需要解析的 JSON 数据之前编译器和我们都不知道它“事实上”是一个 slice。</p><p>这个在项目应用中实际存在的矛盾也解决我学 OOP 语言一直以来的困惑，就是反射是什么？为什么现代编程语言都选择加入反射作为基本特性（Java，C#，还有本文中的 Golang），就是因为我们有在运行时获取某个对象/变量的实际类型的需要。</p><p>由于目前学习还不够深入，不能对反射机制展开深入的探讨，在这里讲一下如何利用类型断言机制解决上面说到的问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cs,ok := result[<span class="string">"containers"</span>].([]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> ok&#123;</span><br><span class="line"><span class="keyword">for</span> i,item := <span class="keyword">range</span> cs&#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cs,ok := result[&quot;containers&quot;].([]interface{})</code>这一句就是解决问题的关键所在，也就是称为运行时类型断言的机制。<code>a.(Type)</code>是尝试对a进行类型转换的操作，如果转换成功则返回一个转换成 Type 类型的变量和<code>true</code>指示转换成功，失败则返回<code>false</code>。</p><p>值得一提的是，断言失败不会导致编译失败（要是会导致编译失败也就不能解决上面这个问题了），所以为了代码健壮性需要对转换结果进行判断比较好。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Golang 中处理 JSON 格式数据主要依赖&lt;code&gt;encoding/json&lt;/code&gt;这个库，很多教程（包括 Go 语言圣经）讲 JSON 数据处理时都会定义一个结构体对应于 JSON 数据的各个字段，这种处理方法在 JSON 中字段相对固定时非常实用。但对于字段可能不断变化或者只有一两个字段是固定的时候，如何处理这个问题往往令很多人感到困惑。最近研究 gin 这个库的时候发现一个思路非常值得学习借鉴。&lt;br&gt;
    
    </summary>
    
    
      <category term="go" scheme="https://antarx.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>redis的杂七杂八</title>
    <link href="https://antarx.com/2018/02/25/redis/"/>
    <id>https://antarx.com/2018/02/25/redis/</id>
    <published>2018-02-25T15:09:10.000Z</published>
    <updated>2018-05-24T08:59:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 是目前应用比较广泛的数据库。最近的实验室项目中用到它作为实时数据库。把这个过程中学到的一些东西记录下来，权且作为小白的入门参考吧<br><a id="more"></a></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Redis 是一种基于内存的数据库，这意味着在使用过程中的所有数据都是存放在内存当中的，省去硬盘读写的过程使得对数据库的操作会非常的快，很适合并发。</p><p>Redis 的基本储存单位是<code>key-value</code>，比 mongodb 中的“文档”的概念有着更细的粒度。<code>key</code>部分一般是字符串类型，<code>value</code>部分可以有以下五种类型：</p><ol><li>string。字符串类型</li><li>hash。一系列<code>k-v</code>的集合，适合用来储存对象实例或者 JSON</li><li>list。简单的字符串列表，也就是说可以通过 list 数据结构在一个<code>key</code>对应的<code>value</code>字段储存多个字符串。这多个字符串是有序排列的。“序”指的是插入的顺序（可以选从头部或者尾部插入）</li><li>set。String 类型的无序集合。满足唯一性。</li><li>有序集合。set 的有序版本</li></ol><h2 id="命令行操作"><a href="#命令行操作" class="headerlink" title="命令行操作"></a>命令行操作</h2><h3 id="服务器（server-端）"><a href="#服务器（server-端）" class="headerlink" title="服务器（server 端）"></a>服务器（server 端）</h3><p>安装 Redis 之后，在命令行窗口输入<code>redis-server</code>即可在本机运行一个radis 的 server 端，默认的端口是6379.</p><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>Redis 服务器端和其他主流数据库一样可以很方便的放到 Docker 容器里运行。</p><p>下载 Redis 镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull redis</span><br></pre></td></tr></table></figure><p>基于 redis 镜像运行容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --name redis-server -p 6379:6379 -d redis</span><br></pre></td></tr></table></figure><p>镜像内部已经设置了运行<code>redis-server</code>和监听6379端口，所以不需要额外的设置项，只需要在运行容器时将端口暴露出来（与宿主机的6379端口或者自己指定的端口绑定）就可以了</p><h3 id="client-端"><a href="#client-端" class="headerlink" title="client 端"></a>client 端</h3><p>shell 界面下输入<code>redis-cli -h 127.0.0.1 -p 6379</code>启动 redis-client。其中，<code>-h</code>指定服务器的地址，<code>-p</code>指定服务器的端口。</p><h4 id="基本操作命令"><a href="#基本操作命令" class="headerlink" title="基本操作命令"></a>基本操作命令</h4><p>注意到，命令的操作字段是不区分大小写的。</p><ol><li>value 为 String 类型时。<code>set key value</code>用于为 key 设置值为 value。 <code>get key</code>用于获取键为 key 的值。</li><li>value 为 list类型时。<code>lpush key value1 [value2]…</code>用于将一个或者多个值。 <code>LPOP key</code>可以移出并获取列表的第一个元素。这两个操作换成<code>rpush</code>和<code>rpop</code>可以向列表尾部插入元素。<code>LLEN key</code>可以获取 key 对应的列表的长度。<code>LRANGE key start stop</code>用于获取特定key 的指定范围的元素，特别地，<code>LRANGE key 0 -1</code>可以用来遍历列表。</li></ol><p>更加详细的命令教程可以参考<a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">Redis教程-菜鸟教程</a></p><h2 id="编程语言支持"><a href="#编程语言支持" class="headerlink" title="编程语言支持"></a>编程语言支持</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>在 Java 中主要通过 jedis 数据库驱动实现对 Redis 数据库的操作。</p><p>安装依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="JedisPool和-JedisClient"><a href="#JedisPool和-JedisClient" class="headerlink" title="JedisPool和 JedisClient"></a>JedisPool和 JedisClient</h4><p>jedis 使用 JedisPool 作为一个Redis连接池，用于解决对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题。</p><p>连接池初始化代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JedisPool <span class="title">getPool</span><span class="params">(String host, <span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pool == <span class="keyword">null</span>)&#123;</span><br><span class="line">            JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">            </span><br><span class="line"><span class="comment">//设置最大连接数</span></span><br><span class="line">            config.setMaxTotal(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">            config.setMaxIdle(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(host == <span class="keyword">null</span>)&#123;</span><br><span class="line">                pool = <span class="keyword">new</span> JedisPool(config, <span class="string">"127.0.0.1"</span>, port);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pool = <span class="keyword">new</span> JedisPool(config, host, port);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pool;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>要使用Client 时，使用<code>pool.getResource()</code>方法获取单个JedisClient实例，在此基础上对 Redis 数据库进行操作。</p><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><p>Go 语言中用来连接 Redis 数据库的库五花八门，主要分两个派系，将对 Redis 的操作封装成方法的，开发者通过调用库的方法实现对 Redis 数据库的操作；另一派是直接将 Redis 命令作为字符串提供给库来实现各种操作的。</p><p>这里以<code>&quot;github.com/garyburd/redigo/redis&quot;</code>为例。</p><p>安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/garyburd/redigo/redis</span><br></pre></td></tr></table></figure><p>获取 redis pool实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis.Pool&#123;</span><br><span class="line">MaxIdle:<span class="number">10</span>,</span><br><span class="line">MaxActive:<span class="number">15</span>,</span><br><span class="line">IdleTimeout:<span class="number">240</span>*time.Second,</span><br><span class="line">Dial: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(redis.Conn, error)</span></span> &#123;</span><br><span class="line">c, err := redis.Dial(<span class="string">"tcp"</span>, redisURL)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c, err</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 pool 中获取 Client 实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rClient := redisPool.Get()</span><br></pre></td></tr></table></figure><p>执行操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rClient.Do(<span class="string">"LPUSH"</span>,<span class="string">"key"</span>, <span class="string">"value"</span>)</span><br></pre></td></tr></table></figure><p>Do 方法用于执行对 Redis 数据库的操作命令。方法的第一个参数字符串命令（就是在 shell 交互时的各种命令。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 是目前应用比较广泛的数据库。最近的实验室项目中用到它作为实时数据库。把这个过程中学到的一些东西记录下来，权且作为小白的入门参考吧&lt;br&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://antarx.com/tags/golang/"/>
    
      <category term="Java" scheme="https://antarx.com/tags/Java/"/>
    
      <category term="Redis" scheme="https://antarx.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Keras 手写数字识别</title>
    <link href="https://antarx.com/2018/01/23/aml/"/>
    <id>https://antarx.com/2018/01/23/aml/</id>
    <published>2018-01-23T10:42:42.000Z</published>
    <updated>2018-05-24T08:59:18.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>之前机器学习课程布置的大作业是用尽可能多的模型来探索经典的手写数字识别问题。这里分享一下Keras的基本使用<br><a id="more"></a></p><h1 id="Keras简介"><a href="#Keras简介" class="headerlink" title="Keras简介"></a>Keras简介</h1><p>Keras 是由纯 Python 写成的，调用 TensorFlow 或者 Theano（最新版本还支持 CNTK）进行运算的类库。相比于 TensorFlow，Keras 使用起来更加简洁方便，便于调参，非常适合初学者进行机器学习探索。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>在安装好 anaconda 的前提下，输入<code>conda install keras</code>即可进行安装。</p><p>注意到，安装过程会自动判断机器是否已经安装好了TensorFlow，如果没有的话会自动进行安装。所以，如果想安装 TensorFlow GPU 版本加速计算过程的话，要先手动安装好 TensorFlow 的 GPU 版本，然后再安装 Keras。</p><h1 id="实现单层感知机"><a href="#实现单层感知机" class="headerlink" title="实现单层感知机"></a>实现单层感知机</h1><p>核心代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">128</span></span><br><span class="line">classes = <span class="number">10</span></span><br><span class="line">epoch = <span class="number">10</span></span><br><span class="line">img_size = <span class="number">28</span> * <span class="number">28</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'Loading Data...'</span>)</span><br><span class="line">(X_train, y_train),(X_test,y_test) = mnist.load_data()</span><br><span class="line"></span><br><span class="line">X_train = X_train.reshape(y_train.shape[<span class="number">0</span>], img_size).astype(<span class="string">'float32'</span>) / <span class="number">255</span></span><br><span class="line">X_test = X_test.reshape(y_test.shape[<span class="number">0</span>], img_size).astype(<span class="string">'float32'</span>) / <span class="number">255</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#encode labels</span></span><br><span class="line">Y_train = np_utils.to_categorical(y_train,classes)</span><br><span class="line">Y_test = np_utils.to_categorical(y_test,classes)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = Sequential([Dense(<span class="number">10</span>, input_shape=(img_size,), activation=<span class="string">'softmax'</span>),])</span><br><span class="line">model.compile(optimizer=<span class="string">'rmsprop'</span>, loss=<span class="string">'mean_absolute_error'</span>, metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Training..."</span>)</span><br><span class="line">model.fit(X_train, Y_train,batch_size=batch_size, epochs=epoch, verbose=<span class="number">1</span>, validation_data=(X_test,Y_test))</span><br><span class="line"></span><br><span class="line">score = model.evaluate(X_test,Y_test,verbose=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'accuracy: &#123;&#125;'</span>.format(score[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><p>前面很大一部分都是进行数据加载和处理，与模型有关的代码只有三行</p><p><code>model = Sequential([Dense(10, input_shape=(img_size,), activation=&#39;softmax&#39;),])</code>这一行是模型基本形态的定义，以图像的 size 作为输入，激活函数采用 softmax。</p><p><code>model.compile(optimizer=&#39;rmsprop&#39;, loss=&#39;mean_absolute_error&#39;, metrics=[&#39;accuracy&#39;])</code>这一行则是对模型的微观参数进行客制化。<code>optimizer</code>指定的是优化策略，<code>rmsprop</code>是一种改进的随机梯度下降策略。<code>loss</code>指的是损失函数。<code>metrics</code>是评估方法，这里用准确率进行评估。</p><p><code>model.fit(X_train, Y_train,batch_size=batch_size, epochs=epoch, verbose=1, validation_data=(X_test,Y_test))</code>这一句是训练过程，指定训练数据，训练轮次（迭代次数），是否输出训练过程，验证数据。</p><h1 id="多层全连接网络"><a href="#多层全连接网络" class="headerlink" title="多层全连接网络"></a>多层全连接网络</h1><p>核心代码部分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential([Dense(<span class="number">512</span>,input_shape=(img_size,)),</span><br><span class="line">                    Activation(<span class="string">'relu'</span>),</span><br><span class="line">                    Dropout(<span class="number">0.2</span>),</span><br><span class="line">                    Dense(<span class="number">512</span>, input_shape=(<span class="number">512</span>,)),</span><br><span class="line">                    Activation(<span class="string">'relu'</span>),</span><br><span class="line">                    Dropout(<span class="number">0.2</span>),</span><br><span class="line">                    Dense(<span class="number">10</span>,input_shape=(<span class="number">512</span>,),activation=<span class="string">'softmax'</span>)</span><br><span class="line">                    ])</span><br></pre></td></tr></table></figure><p>每一个 Dense 都是一个神经元训练层。训练层输出接 ReLU 激活函数层。如此类推。最后一层接单层感知机获取结果。值得注意的是两个 Dropout 层，用于应付过拟合问题，经过 Dropout 层会随机丢弃数据集中一定比率的激活值，同时将剩余的神经元的输出进行放大。</p><h1 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Conv2D(<span class="number">32</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">                 activation=<span class="string">'relu'</span>,</span><br><span class="line">                 input_shape=input_shape))</span><br><span class="line">model.add(Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(MaxPooling2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">model.add(Dropout(<span class="number">0.25</span>))</span><br><span class="line">model.add(Flatten())</span><br><span class="line">model.add(Dense(<span class="number">128</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.5</span>))</span><br><span class="line">model.add(Dense(num_classes, activation=<span class="string">'softmax'</span>))</span><br></pre></td></tr></table></figure><p>卷积神经网络中主角变成了 Conv2D （卷积层）和 Pooling 层（池化）。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;之前机器学习课程布置的大作业是用尽可能多的模型来探索经典的手写数字识别问题。这里分享一下Keras的基本使用&lt;br&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://antarx.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
