<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gawainx&#39; Blog</title>
  
  <subtitle>Antarx is the heart of Scorpio</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gawainx.github.io/"/>
  <updated>2018-07-17T13:57:50.827Z</updated>
  <id>https://gawainx.github.io/</id>
  
  <author>
    <name>Gawain Antarx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>豆瓣电影海报下载-Workflow</title>
    <link href="https://gawainx.github.io/2018/07/17/dbmv/"/>
    <id>https://gawainx.github.io/2018/07/17/dbmv/</id>
    <published>2018-07-17T13:03:53.000Z</published>
    <updated>2018-07-17T13:57:50.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>最近实验室里买了打印机，手账 er 多年以来的为电影手账贴上海报缩略图的心愿终于有机会打成了。</p><p>那么问题来了，去哪找电影海报可以更快更方便呢？每次都是打开网页-&gt;搜索-&gt;图片另存为，太麻烦。于是我盯上了 Alfred，于是就有了这个工具。</p><a id="more"></a><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>首先配置好文件储存的路径，如下图<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://antarx.cn/20180717215527_QpCKV5_Screenshot.jpeg" alt="配置文件" title="">                </div>                <div class="image-caption">配置文件</div>            </figure></p><p>在 Alfred 中输入 <code>dbmv</code>，选择 setting，在配置文件中的<code>img_path</code>输入想要保存图片的目录。</p><p>然后就可以愉快的使用了。</p><ol><li>⌘ + Space 唤醒 Alfred 窗口，输入 <code>dbmv</code> 启动 Workflow。</li><li>选择 Movie</li><li>输入想要搜索的电影名字</li><li>在搜索结果中选择要下载的电影海报，</li><li>回车确认，然后在目标路径就会看到下载好的海报了。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://antarx.cn/20180717214323_XEYh8z_dbmv.gif" alt="使用 dbmv" title="">                </div>                <div class="image-caption">使用 dbmv</div>            </figure><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p><a href="https://github.com/gawainx/dbmv/releases" target="_blank" rel="external">Releases · gawainx/dbmv</a></p><h2 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h2><p>本 Workflow 系基于<a href="http://stonebythesea.org/posts/douban-search-workflow-for-alfred/" target="_blank" rel="external">做了一个豆瓣搜索的 Workflow for Alfred - 海边的石头</a>作品的改写。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Preface&quot;&gt;&lt;a href=&quot;#Preface&quot; class=&quot;headerlink&quot; title=&quot;Preface&quot;&gt;&lt;/a&gt;Preface&lt;/h1&gt;&lt;p&gt;最近实验室里买了打印机，手账 er 多年以来的为电影手账贴上海报缩略图的心愿终于有机会打成了。&lt;/p&gt;
&lt;p&gt;那么问题来了，去哪找电影海报可以更快更方便呢？每次都是打开网页-&amp;gt;搜索-&amp;gt;图片另存为，太麻烦。于是我盯上了 Alfred，于是就有了这个工具。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mac" scheme="https://gawainx.github.io/tags/Mac/"/>
    
      <category term="Alfred" scheme="https://gawainx.github.io/tags/Alfred/"/>
    
  </entry>
  
  <entry>
    <title>gxd-cli is gawainx&#39; docker client</title>
    <link href="https://gawainx.github.io/2018/06/27/gxd-cli/"/>
    <id>https://gawainx.github.io/2018/06/27/gxd-cli/</id>
    <published>2018-06-27T08:42:27.000Z</published>
    <updated>2018-06-27T09:23:44.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gxd-cli-一种快速创建多容器工具"><a href="#gxd-cli-一种快速创建多容器工具" class="headerlink" title="gxd-cli : 一种快速创建多容器工具"></a>gxd-cli : 一种快速创建多容器工具</h1><p>通过 <code>docker run</code> 命令行启动容器的时候，配置网络、挂载卷是一件非常麻烦的事，<code>gxd-cli</code>将这些麻烦的工作简化成修改配置文件<code>TOML</code>达成在不需要记忆繁琐的 docker 命令行参数就能快速启动多容器。</p><h2 id="功能列表"><a href="#功能列表" class="headerlink" title="功能列表"></a>功能列表</h2><ul><li>创建多容器，创建每个容器过程可以配置一下选项<ul><li>挂载卷（支持以<code>pwd</code>指代当前路径）</li><li>指定容器的网络</li><li>自定义容器名</li><li>设定容器暴露的端口</li></ul></li><li>创建网络</li><li>快速生成模板文件</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>支持从源码构建，构建之前首先保证系统已经安装<code>golang</code>和<code>dep</code><br>步骤如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git clone git@github.com:gawainx/gxd-cli.git</div><div class="line">dep ensure -update</div><div class="line">go install</div></pre></td></tr></table></figure><p>安装完毕后在命令行通过<code>gxd-cli</code>调用。</p><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/gawainx/gxd-cli" target="_blank" rel="external">gawainx/gxd-cli</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;gxd-cli-一种快速创建多容器工具&quot;&gt;&lt;a href=&quot;#gxd-cli-一种快速创建多容器工具&quot; class=&quot;headerlink&quot; title=&quot;gxd-cli : 一种快速创建多容器工具&quot;&gt;&lt;/a&gt;gxd-cli : 一种快速创建多容器工具&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="docker" scheme="https://gawainx.github.io/tags/docker/"/>
    
      <category term="go" scheme="https://gawainx.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang/dep 包管理（一）原理</title>
    <link href="https://gawainx.github.io/2018/06/12/dep/"/>
    <id>https://gawainx.github.io/2018/06/12/dep/</id>
    <published>2018-06-12T13:17:51.000Z</published>
    <updated>2018-06-25T03:14:28.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang-包依赖管理工具"><a href="#Golang-包依赖管理工具" class="headerlink" title="Golang 包依赖管理工具"></a>Golang 包依赖管理工具</h1><p>golang 一直以来一个为人诟病的问题就是没有完善可用的包管理工具（类比 java 的 gradle 和 maven，Python 的 pip，nodejs 的 npm），这与 golang 的追求简约高效的原则有关。golang 1.5版本之后引入了<code>vendor</code>机制，1.8之后终于有了官方的包管理工具，<code>golang/dep</code>。<br><a id="more"></a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://golang.github.io/dep/docs/assets/four-states.png" alt="四元组架构" title="">                </div>                <div class="image-caption">四元组架构</div>            </figure><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://supereagle.github.io/2017/10/05/golang-dep/" target="_blank" rel="external">Golang依赖管理工具：Dep - 乐金明的博客 | Robin Blog</a><br><a href="https://golang.github.io/dep/docs/ensure-mechanics.html" target="_blank" rel="external">Models and Mechanisms · dep</a><br><a href="https://github.com/golang/dep" target="_blank" rel="external">golang/dep: Go dependency management tool</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Golang-包依赖管理工具&quot;&gt;&lt;a href=&quot;#Golang-包依赖管理工具&quot; class=&quot;headerlink&quot; title=&quot;Golang 包依赖管理工具&quot;&gt;&lt;/a&gt;Golang 包依赖管理工具&lt;/h1&gt;&lt;p&gt;golang 一直以来一个为人诟病的问题就是没有完善可用的包管理工具（类比 java 的 gradle 和 maven，Python 的 pip，nodejs 的 npm），这与 golang 的追求简约高效的原则有关。golang 1.5版本之后引入了&lt;code&gt;vendor&lt;/code&gt;机制，1.8之后终于有了官方的包管理工具，&lt;code&gt;golang/dep&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="go" scheme="https://gawainx.github.io/tags/go/"/>
    
      <category term="golang" scheme="https://gawainx.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>TED 200 资源整理</title>
    <link href="https://gawainx.github.io/2018/06/11/ted-categories/"/>
    <id>https://gawainx.github.io/2018/06/11/ted-categories/</id>
    <published>2018-06-11T08:43:05.000Z</published>
    <updated>2018-06-25T13:23:03.555Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p><a href="https://www.bilibili.com/video/av24693241" target="_blank" rel="external">【TED演讲】怎样的压力，会让一个人放弃生命？</a></p></li><li><p><a href="https://www.bilibili.com/video/av24595777" target="_blank" rel="external">「TED/4P字幕」语言如何形塑出我们的思考方式，多学一门语言的好处 /How language shapes the way we think</a></p></li><li><p><a href="https://www.bilibili.com/video/av8247183/index_52.html" target="_blank" rel="external">邪教组织如何重新连接大脑</a></p></li></ol><ol><li><a href="https://www.bilibili.com/video/av18400402" target="_blank" rel="external">【TED双语】推动学习革命_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></li></ol><p><a href="https://www.ornaross.com/wb-yeats-poems-inspired-by-maud-gonne/" target="_blank" rel="external">WB Yeats Poems Inspired By Maud Gonne | Indie Author Orna Ross</a></p><pre><code>&gt; He Wishes for the Cloths of Heaven,  Had I the heavens’ embroidered cloths,  Enwrought with golden and silver light,  The blue and the dim and the dark cloths  Of night and light and the half-light,  I would spread the cloths under your feet:  But I, being poor, have only my dreams;  I have spread my dreams under your feet;  Tread softly because you tread on my dreams.</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av24693241&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;【TED演讲】怎样的压力，会让一个人放弃生命？&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>go docker client 使用教程（二）</title>
    <link href="https://gawainx.github.io/2018/06/01/go-docker-02/"/>
    <id>https://gawainx.github.io/2018/06/01/go-docker-02/</id>
    <published>2018-06-01T03:05:44.000Z</published>
    <updated>2018-06-01T08:12:29.733Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-client-for-golang-使用教程（二）：网络"><a href="#Docker-client-for-golang-使用教程（二）：网络" class="headerlink" title="Docker client for golang 使用教程（二）：网络"></a>Docker client for golang 使用教程（二）：网络</h1><h2 id="端口绑定"><a href="#端口绑定" class="headerlink" title="端口绑定"></a>端口绑定</h2><p>将微服务放到 docker 容器中运行的时候，端口绑定是一个无可避免的问题。在 docker 命令行中，可以通过简单的<code>-p 8080:80</code>解决问题。但在 golang client 中，问题却变得复杂起来。</p><p>首先来看创建容器的函数签名<code>func (cli *Client) ContainerCreate(ctx context.Context, config *container.Config, hostConfig *container.HostConfig, networkingConfig *network.NetworkingConfig, containerName string) (container.ContainerCreateCreatedBody, error)</code>,client 把运行配置拆分成了<code>container.Config</code> 和 <code>container.HostConfig</code> ，也就是容器内部设置和宿主机设置两项。</p><p>要实现端口绑定，首先要在容器设置中设定暴露的端口（exposed ports）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">exports := <span class="built_in">make</span>(nat.PortSet, <span class="number">10</span>)</div><div class="line">port, _ := nat.NewPort(<span class="string">"tcp"</span>, <span class="string">"80"</span>)</div><div class="line">exports[port] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</div><div class="line"><span class="comment">// in config:</span></div><div class="line">cli.ContainerCreate(ctx, &amp;container.Config&#123;</div><div class="line">        ExposedPorts:exports,</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后，在 host.config 中，设置Host 端口与容器暴露出来的端口的绑定。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ports := <span class="built_in">make</span>(nat.PortMap)</div><div class="line">pb := <span class="built_in">make</span>([]nat.PortBinding,<span class="number">0</span>)</div><div class="line">pb = <span class="built_in">append</span>(pb,nat.PortBinding&#123;</div><div class="line">    HostPort:<span class="string">"8080"</span>,</div><div class="line">&#125;)</div><div class="line">ports[port] = pb</div><div class="line"></div><div class="line"><span class="comment">//in Host.config</span></div><div class="line">&amp;container.HostConfig&#123;</div><div class="line">    PortBindings:ports,</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>至此，在代码中就实现了端口绑定的操作。然而，如果只执行到这一步，编译器一般会报非常诡异的<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://antarx.cn/20180601160556_bNP72x_8DD0D6668316EECC0F8DCE8B1E8EEA76.jpeg" alt="类型不匹配错误" title="">                </div>                <div class="image-caption">类型不匹配错误</div>            </figure></p><p>参考<a href="https://www.jianshu.com/p/283f32fc045a" target="_blank" rel="external">go操作docker - 简书</a>的解决方法，删除gopath里面pkg下面docker的vendor里面相应的connections包，然后运行<code>go get github.com/docker/go-connections/nat</code> ，问题解决。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul><li><a href="https://godoc.org/github.com/docker/docker/client#Client.ContainerCreate" target="_blank" rel="external">client - GoDoc</a></li><li><a href="https://www.jianshu.com/p/283f32fc045a" target="_blank" rel="external">go操作docker - 简书</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker-client-for-golang-使用教程（二）：网络&quot;&gt;&lt;a href=&quot;#Docker-client-for-golang-使用教程（二）：网络&quot; class=&quot;headerlink&quot; title=&quot;Docker client for gola
      
    
    </summary>
    
    
      <category term="docker" scheme="https://gawainx.github.io/tags/docker/"/>
    
      <category term="go" scheme="https://gawainx.github.io/tags/go/"/>
    
      <category term="golang" scheme="https://gawainx.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>go docker client 使用教程（一）</title>
    <link href="https://gawainx.github.io/2018/05/29/go-docker-01/"/>
    <id>https://gawainx.github.io/2018/05/29/go-docker-01/</id>
    <published>2018-05-29T03:05:41.000Z</published>
    <updated>2018-05-29T03:39:03.829Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-client-for-golang-使用教程（一）"><a href="#Docker-client-for-golang-使用教程（一）" class="headerlink" title="Docker client for golang 使用教程（一）"></a>Docker client for golang 使用教程（一）</h1><p>Docker 官方提供了适用于 golang 的 <a href="https://github.com/moby/moby/tree/master/client" target="_blank" rel="external">client</a>，可惜的是网上几乎没有完整可用的使用教程或者例子。在开发<a href="https://github.com/gawainx/gxd-cli" target="_blank" rel="external">gxd-cli</a>的过程中，需要大量使用到这个 SDK，所以便有了这个系列。</p><p>本篇涉及通过代码运行第一个容器，以及如何挂载卷。<br><a id="more"></a></p><h2 id="运行第一个容器"><a href="#运行第一个容器" class="headerlink" title="运行第一个容器"></a>运行第一个容器</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> *Gawain Open Source Project</div><div class="line"> *Author: Gawain Antarx</div><div class="line"> *Create Date: 2018-May-29</div><div class="line"> *</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line"><span class="string">"github.com/docker/docker/client"</span></div><div class="line"><span class="string">"github.com/docker/docker/api/types"</span></div><div class="line"><span class="string">"github.com/docker/docker/api/types/container"</span></div><div class="line"><span class="string">"io"</span></div><div class="line"><span class="string">"os"</span></div><div class="line"><span class="string">"context"</span></div><div class="line"><span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">ctx := context.Background()</div><div class="line">cli, err := client.NewClientWithOpts(client.WithVersion(<span class="string">"1.37"</span>))</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line"><span class="built_in">panic</span>(err)</div><div class="line">&#125;</div><div class="line"></div><div class="line">resp, err := cli.ContainerCreate(ctx, &amp;container.Config&#123;</div><div class="line">Image: <span class="string">"alpine:latest"</span>,</div><div class="line">Cmd:   []<span class="keyword">string</span>&#123;<span class="string">"echo"</span>,<span class="string">"hello"</span>&#125;,</div><div class="line">&#125;, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">""</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line"><span class="built_in">panic</span>(err)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> err := cli.ContainerStart(ctx, resp.ID, types.ContainerStartOptions&#123;&#125;); err != <span class="literal">nil</span> &#123;</div><div class="line"><span class="built_in">panic</span>(err)</div><div class="line">&#125;</div><div class="line"></div><div class="line">statusCh, errCh := cli.ContainerWait(ctx, resp.ID, container.WaitConditionNotRunning)</div><div class="line"><span class="keyword">select</span> &#123;</div><div class="line"><span class="keyword">case</span> err := &lt;-errCh:</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line"><span class="built_in">panic</span>(err)</div><div class="line">&#125;</div><div class="line"><span class="keyword">case</span> &lt;-statusCh:</div><div class="line">&#125;</div><div class="line"></div><div class="line">out, err := cli.ContainerLogs(ctx, resp.ID, types.ContainerLogsOptions&#123;ShowStdout: <span class="literal">true</span>&#125;)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line"><span class="built_in">panic</span>(err)</div><div class="line">&#125;</div><div class="line"></div><div class="line">io.Copy(os.Stdout, out)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>官方使用<code>client.NewEnvClient()</code>来初始化<code>client</code>，在 IDE 中提示这个接口已经过时，推荐使用<code>client.NewClientWithOpts()</code>。要注意的是，直接调用的时候一般会提示 API 版本不匹配，需要加<code>client.WithVersion(&quot;1.37&quot;)</code>作为参数传入。<code>1.37</code>部分可以根据它的错误提示自行修改。</p><h2 id="绑定卷"><a href="#绑定卷" class="headerlink" title="绑定卷"></a>绑定卷</h2><p>将自己代码放入容器中运行时最基本的操作，在命令行中通过<code>-v {host vol}:{container vol}</code>实现，在 golang sdk 中，开发者却没有提供这部分的重要说明。通过查阅<a href="https://github.com/fsouza/go-dockerclient/issues/155" target="_blank" rel="external">issue155</a>以及<a href="https://github.com/fsouza/go-dockerclient/issues/132" target="_blank" rel="external">issue1</a>，得到的解决方案如下。</p><p>卷绑定通过<code>client.ContainerStart()</code>里面的参数<code>client.HostConfig</code>结构的<code>Binds</code>传入，传入的类型是<code>[]string</code>，这个字符串序列的中每个字符串的格式<code>{host_vol}:{com_col}</code>，也就是和命令行的一致。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-client-for-golang-使用教程（一）&quot;&gt;&lt;a href=&quot;#Docker-client-for-golang-使用教程（一）&quot; class=&quot;headerlink&quot; title=&quot;Docker client for golang 使用教程（一）&quot;&gt;&lt;/a&gt;Docker client for golang 使用教程（一）&lt;/h1&gt;&lt;p&gt;Docker 官方提供了适用于 golang 的 &lt;a href=&quot;https://github.com/moby/moby/tree/master/client&quot;&gt;client&lt;/a&gt;，可惜的是网上几乎没有完整可用的使用教程或者例子。在开发&lt;a href=&quot;https://github.com/gawainx/gxd-cli&quot;&gt;gxd-cli&lt;/a&gt;的过程中，需要大量使用到这个 SDK，所以便有了这个系列。&lt;/p&gt;
&lt;p&gt;本篇涉及通过代码运行第一个容器，以及如何挂载卷。&lt;br&gt;
    
    </summary>
    
    
      <category term="docker" scheme="https://gawainx.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>LaTeX排版学术论文工具链</title>
    <link href="https://gawainx.github.io/2018/05/21/latex-toolchain/"/>
    <id>https://gawainx.github.io/2018/05/21/latex-toolchain/</id>
    <published>2018-05-21T02:48:35.000Z</published>
    <updated>2018-05-24T08:59:19.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LaTeX-排版工具链"><a href="#LaTeX-排版工具链" class="headerlink" title="LaTeX 排版工具链"></a>LaTeX 排版工具链</h1><p> 这里整理了 $\LaTeX$ 排版学术论文的工具链。根据自己的实践和大家的留言补充定期更新。<br><a id="more"></a></p><h2 id="操作系统，软件等"><a href="#操作系统，软件等" class="headerlink" title="操作系统，软件等"></a>操作系统，软件等</h2><p>$\LaTeX$ 可以在 Windows、Linux 和 macOS 平台上运行。Windows 上可以安装 MikTex，Linux 上有 TeX Live，考虑美观度和排版过程的愉悦度，本人使用的 LaTeX 排版环境大致如下：</p><ul><li>OS : macOS(Darwin)</li><li>编辑器：<a href="https://code.visualstudio.com" target="_blank" rel="external">Microsoft VSCode</a></li><li>插件：LaTeX Workshop</li><li>$\LaTeX$ 软件：MacTeX 工具包</li><li>PDF 阅读工具：skim</li></ul><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p><a href="https://github.com/uefs/ieee-template-latex/blob/master/bare_jrnl.tex" target="_blank" rel="external">IEEE tran</a><br><code>bare_jrnl.tex</code>最新版本应该是 v1.7，但在网上好像找不到这个最新的版本，准备整理一个多文件编译的版本放到 GitHub 上。</p><p>欢迎留言补充其它模板。:)</p><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><p><a href="http://mohu.org/info/symbols/symbols.htm" target="_blank" rel="external">数学符号集</a></p><h2 id="插入伪代码（算法宏包的相关使用）"><a href="#插入伪代码（算法宏包的相关使用）" class="headerlink" title="插入伪代码（算法宏包的相关使用）"></a>插入伪代码（算法宏包的相关使用）</h2><p><a href="https://www.zybuluo.com/jfruan/note/720298" target="_blank" rel="external">LaTeX算法排版</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>使用<code>listings</code>宏包。<a href="https://en.wikibooks.org/wiki/LaTeX/Source_Code_Listings" target="_blank" rel="external">LaTeX/Source Code Listings</a><br>但这个宏包没有 golang 语法高亮支持的！要使 golang 语法高亮，可添加宏包<a href="https://github.com/julienc91/listings-golang" target="_blank" rel="external">listings-golang</a></p><h2 id="图片与表格"><a href="#图片与表格" class="headerlink" title="图片与表格"></a>图片与表格</h2><p>首先要理解浮动体的概念，<a href="https://liam0205.me/2017/04/30/floats-in-LaTeX-the-positioning-algorithm/" target="_blank" rel="external">LaTeX 中的浮动体：浮动算法</a></p><h2 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h2><p><a href="http://www.latexstudio.net" target="_blank" rel="external">LaTeX 开源小屋</a><br><a href="https://github.com/luongvo209/Begin-Latex-in-minutes" target="_blank" rel="external">Begin LaTeX in minutes</a><br><a href="https://book.douban.com/subject/24703731/" target="_blank" rel="external">LaTeX 入门</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LaTeX-排版工具链&quot;&gt;&lt;a href=&quot;#LaTeX-排版工具链&quot; class=&quot;headerlink&quot; title=&quot;LaTeX 排版工具链&quot;&gt;&lt;/a&gt;LaTeX 排版工具链&lt;/h1&gt;&lt;p&gt; 这里整理了 $\LaTeX$ 排版学术论文的工具链。根据自己的实践和大家的留言补充定期更新。&lt;br&gt;
    
    </summary>
    
    
      <category term="LaTeX" scheme="https://gawainx.github.io/tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>博客迁移腾讯云小记</title>
    <link href="https://gawainx.github.io/2018/05/11/hexossl/"/>
    <id>https://gawainx.github.io/2018/05/11/hexossl/</id>
    <published>2018-05-11T09:30:58.000Z</published>
    <updated>2018-05-14T03:12:19.094Z</updated>
    
    <content type="html"><![CDATA[<h1 id="博客迁移腾讯云实战记录"><a href="#博客迁移腾讯云实战记录" class="headerlink" title="博客迁移腾讯云实战记录"></a>博客迁移腾讯云实战记录</h1><p>源于年初的一次突发奇想，将博客站点迁移到了腾讯云，五月份终于完成了备案，然后添加了 HTTPS 支援，并完成容器化。在这里把折腾的过程记录下来。</p><a id="more"></a><h2 id="转移腾讯云"><a href="#转移腾讯云" class="headerlink" title="转移腾讯云"></a>转移腾讯云</h2><p>原来的博客是放到 github page 上面，访问 <strong>antarx.com</strong> 是通过 CNAME 文件解析到 gawainx.github.io，只需要在<code>config.yaml</code>配置好，写完直接<code>hexo d -g</code>完事。</p><p>迁移到腾讯云之后，还想每次部署都这么方便，就免不了完成一些相关工作。</p><h3 id="资源准备"><a href="#资源准备" class="headerlink" title="资源准备"></a>资源准备</h3><p>这里准备的资源主要就是服务器的购入，可以根据自己博客的规模需要选择合适的套餐。如果是学生党记得使用学生优惠。<br>买完服务器就是装系统的事，根据自己的使用习惯自行选择，我用的是 ubuntu16.04.<br>如果想容器化的话需要安装 Docker。</p><h3 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install git</div></pre></td></tr></table></figure><h3 id="新建-git-裸仓库"><a href="#新建-git-裸仓库" class="headerlink" title="新建 git 裸仓库"></a>新建 git 裸仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sudo mkdir /var/repo/</div><div class="line">sudo chown -R $USER:$USER /var/repo/</div><div class="line">sudo chmod -R 755 /var/repo/</div><div class="line"></div><div class="line">cd /var/repo/</div><div class="line">git init --bare hexo_static.git</div></pre></td></tr></table></figure><h3 id="创建存放-hexo-生成的网页的文件夹"><a href="#创建存放-hexo-生成的网页的文件夹" class="headerlink" title="创建存放 hexo 生成的网页的文件夹"></a>创建存放 hexo 生成的网页的文件夹</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo mkdir -p /var/www/hexo</div><div class="line">sudo chown -R $USER:$USER /var/www/hexo</div><div class="line">sudo chmod -R 755 /var/www/hexo</div></pre></td></tr></table></figure><p>这两步要注意的是文件夹的 owner 问题，要实现自动部署的话一般新建一个 git 账户然后全权接管部署网页的相关工作，那么上面创建的两个文件夹在后期的 owner 记得要变更为 git 用户。</p><h3 id="创建-git-钩子"><a href="#创建-git-钩子" class="headerlink" title="创建 git 钩子"></a>创建 git 钩子</h3><p>在<code>hexo_static.git</code>文件夹的 hooks 目录下面新建钩子文件并写入如下代码，然后将文件变更成可执行文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">vim /var/repo/hexo_static.git/hooks/post-receive</div><div class="line"></div><div class="line"># post-receive file content</div><div class="line"></div><div class="line">#!/bin/bash</div><div class="line">git --work-tree=/var/www/hexo --git-dir=/var/repo/hexo_static.git checkout -f</div><div class="line"></div><div class="line">chmod +x /var/repo/hexo_static.git/hooks/post-receive</div></pre></td></tr></table></figure><h3 id="自动部署"><a href="#自动部署" class="headerlink" title="自动部署"></a>自动部署</h3><p>所谓自动部署，就是在每次部署的时候不需要键入密码。<br>在自己电脑上，创建公钥，复制到剪贴板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C &quot;xx@xx.com&quot;</div><div class="line">pbcopy &lt; ~/.ssh/id_rsa.pub</div></pre></td></tr></table></figure><p>服务器上，切换到 git 用户（没有的话请新建），输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">su git</div><div class="line">cd ~</div><div class="line">mkdir .ssh</div><div class="line">vim .ssh/authorized_keys</div><div class="line">#粘贴自己电脑的 公钥，然后保存</div><div class="line">chmod 600 ~/.ssh/authorized_keys</div><div class="line">chmod 700 ~/.ssh</div></pre></td></tr></table></figure><h3 id="本地-hexo-git-配置"><a href="#本地-hexo-git-配置" class="headerlink" title="本地 hexo-git 配置"></a>本地 hexo-git 配置</h3><p>在<code>config.yaml</code>键入</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">deploy:</span></div><div class="line"><span class="attr">    type:</span> git</div><div class="line"><span class="attr">    repo:</span> git@CVM 云服务器的IP地址:/var/repo/hexo_static</div><div class="line"><span class="attr">    branch:</span> master</div></pre></td></tr></table></figure><h2 id="添加-SSL-证书并容器化-Nginx"><a href="#添加-SSL-证书并容器化-Nginx" class="headerlink" title="添加 SSL 证书并容器化 Nginx"></a>添加 SSL 证书并容器化 Nginx</h2><p>Linux 配置软件向来复杂，所以毫不犹豫选用 docker 容器进行 Nginx 部署。<br>输入<code>docker pull nginx</code>拉取 Nginx 镜像。</p><p>首先基于镜像运行一个 nginx 容器，然后将容器里面的<code>/etc/nginx/</code>目录拷贝出来。可以看到文件内容如下图<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://antarx.cn/20180514104132_CkMTT5_Screenshot.jpeg" alt="Nginx 配置目录" title="">                </div>                <div class="image-caption">Nginx 配置目录</div>            </figure>。<br>这里顺带一提 Nginx 的两个配置文件，<code>nginx.conf</code>和<code>deafult.conf</code>，一般而言修改<code>nginx.conf</code>然后把<code>deafult</code>里面的内容注释掉会比较妥当。</p><h3 id="添加-SSL-证书"><a href="#添加-SSL-证书" class="headerlink" title="添加 SSL 证书"></a>添加 SSL 证书</h3><p>在拷贝出来的<code>nginx.conf</code>文件，在<code>http</code>的选型里面，加入以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">        listen 443;</div><div class="line">        server_name 你的站点名称; #填写绑定证书的域名</div><div class="line">        ssl on;</div><div class="line">        ssl_certificate /cert/你的证书.crt;</div><div class="line">        ssl_certificate_key /cert/你的私钥.key;</div><div class="line">        ssl_session_timeout 5m;</div><div class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置</div><div class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置</div><div class="line">        ssl_prefer_server_ciphers on;</div><div class="line">        location / &#123;</div><div class="line">            root   /blog; #站点目录</div><div class="line">            index  index.html index.htm;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>如果强制使用 HTTPS，还要加上以下配置，将80端口的流量重定向到443端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">        listen 80;</div><div class="line">        server_name antarx.com;</div><div class="line">        rewrite ^(.*)$ https://$&#123;server_name&#125;$1 permanent;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>这两个 server 是独立的，都加到<code>http</code>的配置里面。<br>顺带一提 Nginx 要求的证书是 PEM 格式。</p><p>运行博客容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 443:443 -p 80:80 -v `pwd`:/etc/nginx -v /var/www/hexo:/hexo -v &quot;$PWD/cert&quot;:/cert --name ng nginx</div></pre></td></tr></table></figure><p>这里注意到的是三个挂载卷，分别是配置文件，博客网页文件和证书文件。</p><p>容器运行之后，在腾讯云的域名管理里面添加 DNS 记录，OK，大功告成。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://cloud.tencent.com/developer/article/1004587" target="_blank" rel="external">在 Ubuntu 14.04 服务器上部署 Hexo 博客</a><br><a href="https://cloud.tencent.com/developer/article/1004839" target="_blank" rel="external">Hello Hexo之静态博客搭建+自动部署</a><br><a href="https://cloud.tencent.com/document/product/400/4143" target="_blank" rel="external">证书安装指引</a><br><a href="http://www.ruanyifeng.com/blog/2018/02/nginx-docker.html" target="_blank" rel="external">Nginx 容器教程（可能无法访问）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;博客迁移腾讯云实战记录&quot;&gt;&lt;a href=&quot;#博客迁移腾讯云实战记录&quot; class=&quot;headerlink&quot; title=&quot;博客迁移腾讯云实战记录&quot;&gt;&lt;/a&gt;博客迁移腾讯云实战记录&lt;/h1&gt;&lt;p&gt;源于年初的一次突发奇想，将博客站点迁移到了腾讯云，五月份终于完成了备案，然后添加了 HTTPS 支援，并完成容器化。在这里把折腾的过程记录下来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://gawainx.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>gorequest中文文档(非官方)</title>
    <link href="https://gawainx.github.io/2018/05/05/gorequest-doc/"/>
    <id>https://gawainx.github.io/2018/05/05/gorequest-doc/</id>
    <published>2018-05-05T11:19:43.000Z</published>
    <updated>2018-05-24T08:59:19.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gorequest指南"><a href="#Gorequest指南" class="headerlink" title="Gorequest指南"></a>Gorequest指南</h1><p><a href="https://github.com/parnurzeal/gorequest" target="_blank" rel="external">gorequest</a>为 golang 程序提供了极为简便的方式发起 HTTP 请求。网上关于这个库的中文教程不多，因此把官方的 README 文件翻译过来，结合自己的一些使用经验，希望能为各位 Gopher 提供一些帮助。<br><a id="more"></a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/parnurzeal/gorequest/gh-pages/images/Gopher_GoRequest_400x300.jpg" alt="GopherGoRequest" title="">                </div>                <div class="image-caption">GopherGoRequest</div>            </figure><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>支持发送Get/Post/Put/Head/Delete/Patch/Options 请求</li><li>建议的请求头设置</li><li>JSON 支持：以 JSON 格式字符串作为函数参数的方式简化传输 JSON 的步骤。</li><li>分段支持：分段请求（Multipart Request）的方式发送数据或传输文件</li><li>代理：支援通过代理的方式发送请求。</li><li>Timeout：为请求设置时间限制</li><li>TLS(传输层安全协议)相关设定。<blockquote><p>TLSClientConfig - taking control over tls where at least you can disable security check for https</p></blockquote></li><li>重定向策略</li><li>Cookie：为请求添加 cookie</li><li>CookieJar - automatic in-memory cookiejar</li><li>基本的权限认证。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go get github.com/parnurzeal/gorequest</div></pre></td></tr></table></figure><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>参阅<a href="http://godoc.org/github.com/parnurzeal/gorequest" target="_blank" rel="external">Go Doc</a><br>后续我会根据自己在开发中使用经验将文档翻译过来。</p><h2 id="使用-GoRequest-的一万个理由？"><a href="#使用-GoRequest-的一万个理由？" class="headerlink" title="使用 GoRequest 的一万个理由？"></a>使用 GoRequest 的一万个理由？</h2><p>通过 GoRequest 可以使工作变得更简单，使可以发起 HTTP 请求这件事更加优雅而充满乐趣。</p><p>不使用本库发起简单 GET 请求：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">resp, err := http.Get(<span class="string">"http://example.com/"</span>)</div></pre></td></tr></table></figure><p>使用 GoRequest</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">request := gorequest.New()</div><div class="line">resp, body, errs := request.Get(<span class="string">"http://example.com/"</span>).End()</div></pre></td></tr></table></figure><p>如果你不想重用<code>request</code>，也可以写成下面这样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">resp, body, errs := gorequest.New().Get(<span class="string">"http://example.com/"</span>).End()</div></pre></td></tr></table></figure><p>如果你需要设定 HTTP 头，设定重定向策略等，使用标准库会瞬间使事情变得异常复杂，在发起仅仅一个 <strong>GET</strong> 请求的过程，你就需要一个 <code>Client</code>，通过一系列不同的命令来设定 HTTP 头（<code>HTTP Headers</code>）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">client := &amp;http.Client&#123;</div><div class="line">  CheckRedirect: redirectPolicyFunc,</div><div class="line">&#125;</div><div class="line"></div><div class="line">req, err := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"http://example.com"</span>, <span class="literal">nil</span>)</div><div class="line"></div><div class="line">req.Header.Add(<span class="string">"If-None-Match"</span>, <span class="string">`W/"wyzzy"`</span>)</div><div class="line">resp, err := client.Do(req)</div></pre></td></tr></table></figure><p>现在，你有更加美妙的方式来完成这件事</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">request := gorequest.New()</div><div class="line">resp, body, errs := request.Get(<span class="string">"http://example.com"</span>).</div><div class="line">  RedirectPolicy(redirectPolicyFunc).</div><div class="line">  Set(<span class="string">"If-None-Match"</span>, <span class="string">`W/"wyzzy"`</span>).</div><div class="line">  End()</div></pre></td></tr></table></figure><p>发起 <strong>DELETE</strong>, <strong>HEAD</strong>, <strong>POST</strong>, <strong>PUT</strong>, <strong>PATCH</strong> 请求的过程和发起 <strong>GET</strong> 请求类似。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">request := gorequest.New()</div><div class="line">resp, body, errs := request.Post(<span class="string">"http://example.com"</span>).End()</div><div class="line"><span class="comment">// PUT -&gt; request.Put("http://example.com").End()</span></div><div class="line"><span class="comment">// DELETE -&gt; request.Delete("http://example.com").End()</span></div><div class="line"><span class="comment">// HEAD -&gt; request.Head("http://example.com").End()</span></div><div class="line"><span class="comment">// ANYTHING -&gt; request.CustomMethod("TRACE", "http://example.com").End()</span></div></pre></td></tr></table></figure><h3 id="处理-JSON"><a href="#处理-JSON" class="headerlink" title="处理 JSON"></a>处理 JSON</h3><p>用标准库发起 <strong>JSON POST</strong> ，你需要先将 <code>map</code> 或者 <code>struct</code>格式的数据包装（<strong>Marshal</strong>）成 JSON 格式的数据，将头参数设定为’application/json’（必要时还要设定其他头），然后要新建一个<code>http.CLient</code>变量。经过这一系列的步骤，你的代码变得冗长而难以维护</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"backy"</span>,</div><div class="line">  <span class="string">"species"</span>: <span class="string">"dog"</span>,</div><div class="line">&#125;</div><div class="line">mJson, _ := json.Marshal(m)</div><div class="line">contentReader := bytes.NewReader(mJson)</div><div class="line">req, _ := http.NewRequest(<span class="string">"POST"</span>, <span class="string">"http://example.com"</span>, contentReader)</div><div class="line">req.Header.Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</div><div class="line">req.Header.Set(<span class="string">"Notes"</span>,<span class="string">"GoRequest is coming!"</span>)</div><div class="line">client := &amp;http.Client&#123;&#125;</div><div class="line">resp, _ := client.Do(req)</div></pre></td></tr></table></figure><p>至于 GoRequest， JSON 支持是必须的，所以，用这个库你只需要一行代码完成所有工作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">request := gorequest.New()</div><div class="line">resp, body, errs := request.Post(<span class="string">"http://example.com"</span>).</div><div class="line">  Set(<span class="string">"Notes"</span>,<span class="string">"gorequst is coming!"</span>).</div><div class="line">  Send(<span class="string">`&#123;"name":"backy", "species":"dog"&#125;`</span>).</div><div class="line">  End()</div></pre></td></tr></table></figure><p>另外，它同样支持结构体类型。所以，你可以在你的请求中发送不同的数据类型（So, you can have a fun <strong>Mix &amp; Match</strong> sending the different data types for your request）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> BrowserVersionSupport <span class="keyword">struct</span> &#123;</div><div class="line">  Chrome <span class="keyword">string</span></div><div class="line">  Firefox <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line">ver := BrowserVersionSupport&#123; Chrome: <span class="string">"37.0.2041.6"</span>, Firefox: <span class="string">"30.0"</span> &#125;</div><div class="line">request := gorequest.New()</div><div class="line">resp, body, errs := request.Post(<span class="string">"http://version.com/update"</span>).</div><div class="line">  Send(ver).</div><div class="line">  Send(<span class="string">`&#123;"Safari":"5.1.10"&#125;`</span>).</div><div class="line">  End()</div></pre></td></tr></table></figure><p>Not only for <code>Send()</code> but <code>Query()</code> is also supported. Just give it a try! :)</p><h2 id="回调（Callback）"><a href="#回调（Callback）" class="headerlink" title="回调（Callback）"></a>回调（Callback）</h2><p>此外，GoRequest 支持回调函数，这让你可以更加灵活的使用这个库。<br>下面是回调函数的一个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">printStatus</span><span class="params">(resp gorequest.Response, body <span class="keyword">string</span>, errs []error)</span></span>&#123;</div><div class="line">  fmt.Println(resp.Status)</div><div class="line">&#125;</div><div class="line">gorequest.New().Get(<span class="string">"http://example.com"</span>).End(printStatus)</div></pre></td></tr></table></figure><h2 id="Multipart-Form-Data"><a href="#Multipart-Form-Data" class="headerlink" title="Multipart/Form-Data"></a>Multipart/Form-Data</h2><p>你可以将请求的内容类型设定为<code>multipart</code>来以<code>multipart/form-data</code>的方式发送所有数据。这个特性可以帮助你发送多个文件。<br>下面是一个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">gorequest.New().Post(<span class="string">"http://example.com/"</span>).</div><div class="line">  Type(<span class="string">"multipart"</span>).</div><div class="line">  Send(<span class="string">`&#123;"query1":"test"&#125;`</span>).</div><div class="line">  End()</div></pre></td></tr></table></figure><p>如果感兴趣可以在文档中查看<code>SendFile</code>函数部分获取更多。</p><h2 id="代理（Proxy）"><a href="#代理（Proxy）" class="headerlink" title="代理（Proxy）"></a>代理（Proxy）</h2><p>需要使用代理的时候，可以用 GoRequest Proxy Func 很好的处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">request := gorequest.New().Proxy(<span class="string">"http://proxy:999"</span>)</div><div class="line">resp, body, errs := request.Get(<span class="string">"http://example-proxy.com"</span>).End()</div><div class="line"><span class="comment">// To reuse same client with no_proxy, use empty string:</span></div><div class="line">resp, body, errs = request.Proxy(<span class="string">""</span>).Get(<span class="string">"http://example-no-proxy.com"</span>).End()</div></pre></td></tr></table></figure><h2 id="基本认证"><a href="#基本认证" class="headerlink" title="基本认证"></a>基本认证</h2><p>添加基本的认证头信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">request := gorequest.New().SetBasicAuth(<span class="string">"username"</span>, <span class="string">"password"</span>)</div><div class="line">resp, body, errs := request.Get(<span class="string">"http://example-proxy.com"</span>).End()</div></pre></td></tr></table></figure><h2 id="超时处理（Timeout）"><a href="#超时处理（Timeout）" class="headerlink" title="超时处理（Timeout）"></a>超时处理（Timeout）</h2><p>与 <code>time</code> 库结合可以设置成任何的时间限制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">request := gorequest.New().Timeout(<span class="number">2</span>*time.Millisecond)</div><div class="line">resp, body, errs:= request.Get(<span class="string">"http://example.com"</span>).End()</div></pre></td></tr></table></figure><p><code>Timeout</code> 函数同时设定了连接和 IO 的时间限制。</p><h2 id="以字节方式处理返回体（EndBytes）"><a href="#以字节方式处理返回体（EndBytes）" class="headerlink" title="以字节方式处理返回体（EndBytes）"></a>以字节方式处理返回体（EndBytes）</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">resp, bodyBytes, errs := gorequest.New().Get(<span class="string">"http://example.com/"</span>).EndBytes()</div></pre></td></tr></table></figure><h2 id="以结构体的方式处理返回体"><a href="#以结构体的方式处理返回体" class="headerlink" title="以结构体的方式处理返回体"></a>以结构体的方式处理返回体</h2><p>假设 URL <strong><a href="http://example.com/" target="_blank" rel="external">http://example.com/</a></strong> 的返回体<code>{&quot;hey&quot;:&quot;you&quot;}</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">heyYou <span class="keyword">struct</span> &#123;</div><div class="line">  Hey <span class="keyword">string</span> <span class="string">`json:"hey"`</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> heyYou heyYou</div><div class="line"></div><div class="line">resp, _, errs := gorequest.New().Get(<span class="string">"http://example.com/"</span>).EndStruct(&amp;heyYou)</div></pre></td></tr></table></figure><h2 id="连续重复请求（Retry）"><a href="#连续重复请求（Retry）" class="headerlink" title="连续重复请求（Retry）"></a>连续重复请求（Retry）</h2><p>假设你在得到 BadRequest 或服务器内部错误（InternalServerError）时进行连续三次，间隔五秒的连接尝试</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">request := gorequest.New()</div><div class="line">resp, body, errs := request.Get(<span class="string">"http://example.com/"</span>).</div><div class="line">                    Retry(<span class="number">3</span>, <span class="number">5</span> * time.Second, http.StatusBadRequest, http.StatusInternalServerError).</div><div class="line">                    End()</div></pre></td></tr></table></figure><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><blockquote><p>Redirects can be handled with RedirectPolicy which behaves similarly to net/http Client’s <a href="https://golang.org/pkg/net/http#Client" target="_blank" rel="external">CheckRedirect function</a>. Simply specify a function which takes the Request about to be made and a slice of previous Requests in order of oldest first. When this function returns an error, the Request is not made.</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">request := gorequest.New()</div><div class="line">resp, body, errs := request.Get(<span class="string">"http://example.com/"</span>).</div><div class="line">                    RedirectPolicy(<span class="function"><span class="keyword">func</span><span class="params">(req Request, via []*Request)</span> <span class="title">error</span></span> &#123;</div><div class="line">                      <span class="keyword">if</span> req.URL.Scheme != <span class="string">"https"</span> &#123;</div><div class="line">                        <span class="keyword">return</span> http.ErrUseLastResponse</div><div class="line">                      &#125;</div><div class="line">                    &#125;).</div><div class="line">                    End()</div></pre></td></tr></table></figure><h2 id="Debug-模式"><a href="#Debug-模式" class="headerlink" title="Debug 模式"></a>Debug 模式</h2><blockquote><p>For debugging, GoRequest leverages <code>httputil</code> to dump details of every request/response. (Thanks to @dafang).You can just use <code>SetDebug</code> or environment variable <code>GOREQUEST_DEBUG=0|1</code> to enable/disable debug mode and <code>SetLogger</code> to set your own choice of logger.Thanks to @QuentinPerez, we can see even how gorequest is compared to CURL by using <code>SetCurlCommand</code>.</p></blockquote><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p><code>gorequest.New()</code>函数应该一次调用，对返回的实例尽可能多次使用。</p><h2 id="Credits"><a href="#Credits" class="headerlink" title="Credits"></a>Credits</h2><ul><li>Renee French - the creator of Gopher mascot</li><li><a href="https://www.facebook.com/puairw" target="_blank" rel="external">Wisi Mongkhonsrisawat</a> for providing an awesome GoRequest’s Gopher image :)</li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>GoRequest is MIT License.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Gorequest指南&quot;&gt;&lt;a href=&quot;#Gorequest指南&quot; class=&quot;headerlink&quot; title=&quot;Gorequest指南&quot;&gt;&lt;/a&gt;Gorequest指南&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/parnurzeal/gorequest&quot;&gt;gorequest&lt;/a&gt;为 golang 程序提供了极为简便的方式发起 HTTP 请求。网上关于这个库的中文教程不多，因此把官方的 README 文件翻译过来，结合自己的一些使用经验，希望能为各位 Gopher 提供一些帮助。&lt;br&gt;
    
    </summary>
    
    
      <category term="go" scheme="https://gawainx.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>使用mage实现交叉编译</title>
    <link href="https://gawainx.github.io/2018/04/23/mage2/"/>
    <id>https://gawainx.github.io/2018/04/23/mage2/</id>
    <published>2018-04-23T03:17:36.000Z</published>
    <updated>2018-05-24T08:59:19.427Z</updated>
    
    <content type="html"><![CDATA[<p>golang 为微服务的开发带来了无可比拟的便利。使用的时候也自然而言发现一些问题，因为 golang 不像 Java 有 Maven 这样的打包工具，而是直接编译成二进制可执行文件，所以在开发机（macOS）上编译出来的可执行文件是无法在服务器或者 docker 容器里运行的，如果把源代码提交上去服务器编译，又会带来重新下载依赖包的麻烦（golang 的包依赖关系管理方面的缺失是我认为 golang 为数不多的缺点之一）。最近一直在思考有没有类似 Makefile 的方式来解决这件事（如果只想交叉编译的话直接用 go build或者借助 <a href="https://github.com/mitchellh/gox" target="_blank" rel="external">gox</a> 等工具也不是不可以，可还是，不够方便）。直到之前 ing 大神给我推荐了 Hugo 这个静态博客框架，虽然目前因为找不到合适的博客主题没有从 hexo 迁移过去，但看源代码的时候有了一个重要的收获，就是<a href="https://magefile.org" target="_blank" rel="external">mage</a><br>关于 mage 的基本安装和使用详见<a href="">mage 使用教程(一)</a><br><a id="more"></a></p><h2 id="golang-交叉编译的基本原理"><a href="#golang-交叉编译的基本原理" class="headerlink" title="golang 交叉编译的基本原理"></a>golang 交叉编译的基本原理</h2><p>交叉编译的实现主要是依靠三个参数，<code>CGO_ENABLE</code>,<code>GOOS</code>,<code>GOARCH</code><br><code>CGO_ENABLE</code>在源代码中使用 C/C++时必须开启，这样就无法实现交叉编译了，这部分代码还是得具体平台生成特定的代码。因此，交叉编译是在没有混编代码的前提下的。将<code>CGO_ENABLE</code>设为0，表示关闭。<br><code>GOOS</code>是目标操作系统，macOS 对应的是<code>darwin</code>，Linux 平台对应的是<code>linux</code>。<br><code>GOARCH</code>是目标架构，一般设为<code>amd64</code><br>按照如上所述设定要编译参数之后再执行<code>go build</code>即可生成目标平台的代码。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// +build mega</span></div><div class="line"><span class="comment">// magefile.go</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Linux</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="comment">//设置环境变量</span></div><div class="line">    <span class="keyword">var</span> e= <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</div><div class="line">e[<span class="string">"CGO_ENABLE"</span>] = <span class="string">"0"</span></div><div class="line">e[<span class="string">"GOOS"</span>] = <span class="string">"linux"</span></div><div class="line">e[<span class="string">"GOARCH"</span>] = <span class="string">"amd64"</span></div><div class="line">name := fmt.Sprintf(<span class="string">"%s-linux-%s"</span>,prefix,VERSION)</div><div class="line"><span class="comment">//创建 bin 文件夹</span></div><div class="line"><span class="keyword">if</span> err := os.Mkdir(<span class="string">"bin"</span>, <span class="number">0700</span>); err != <span class="literal">nil</span> &amp;&amp; !os.IsExist(err) &#123;</div><div class="line">fmt.Errorf(<span class="string">"failed to create %s: %v"</span>, <span class="string">"bin"</span>, err)</div><div class="line">os.Exit(<span class="number">1</span>)</div><div class="line">&#125;</div><div class="line">path := filepath.Join(<span class="string">"bin"</span>,name)</div><div class="line">fmt.Println(<span class="string">"Building app for linux..."</span>)</div><div class="line"><span class="comment">//运行构建命令</span></div><div class="line">err := sh.RunWith(e,<span class="string">"go"</span>,<span class="string">"build"</span>,<span class="string">"-o"</span>,path,<span class="string">"main.go"</span>,<span class="string">"utils.go"</span>,<span class="string">"RESTHandler.go"</span>,<span class="string">"module.go"</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</div><div class="line">fmt.Println(err)</div><div class="line"><span class="keyword">return</span></div><div class="line">&#125;</div><div class="line">fmt.Printf(<span class="string">"Sucessfully Built.Output File: %s\n"</span>,path)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在magefile所在文件夹输入 <code>mage linux</code> 即可编译生成适用于 Linux 的运行文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;golang 为微服务的开发带来了无可比拟的便利。使用的时候也自然而言发现一些问题，因为 golang 不像 Java 有 Maven 这样的打包工具，而是直接编译成二进制可执行文件，所以在开发机（macOS）上编译出来的可执行文件是无法在服务器或者 docker 容器里运行的，如果把源代码提交上去服务器编译，又会带来重新下载依赖包的麻烦（golang 的包依赖关系管理方面的缺失是我认为 golang 为数不多的缺点之一）。最近一直在思考有没有类似 Makefile 的方式来解决这件事（如果只想交叉编译的话直接用 go build或者借助 &lt;a href=&quot;https://github.com/mitchellh/gox&quot;&gt;gox&lt;/a&gt; 等工具也不是不可以，可还是，不够方便）。直到之前 ing 大神给我推荐了 Hugo 这个静态博客框架，虽然目前因为找不到合适的博客主题没有从 hexo 迁移过去，但看源代码的时候有了一个重要的收获，就是&lt;a href=&quot;https://magefile.org&quot;&gt;mage&lt;/a&gt;&lt;br&gt;关于 mage 的基本安装和使用详见&lt;a href=&quot;&quot;&gt;mage 使用教程(一)&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://gawainx.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>mage 使用教程(一)</title>
    <link href="https://gawainx.github.io/2018/04/23/mage1/"/>
    <id>https://gawainx.github.io/2018/04/23/mage1/</id>
    <published>2018-04-23T02:24:36.000Z</published>
    <updated>2018-05-24T08:59:19.426Z</updated>
    
    <content type="html"><![CDATA[<p>Mage 是使用 golang 开发的类 Make的软件构建工具。借助这个工具只需要编写符合 golang 语言规范的代码就可以实现比较复杂的源代码编译。<br><a id="more"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装 mage 之前首先要安装 golang1.7或以上版本。安装好之后，执行以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">go get -u -d github.com/magefile/mage</div><div class="line">cd $GOPATH/src/github.com/magefile/mage</div><div class="line">go run bootstrap.go</div></pre></td></tr></table></figure><p>编译完成之后，名为 mage 的可执行文件放在<code>$GOPATH/bin</code>目录下，将<code>$GOPATH/bin</code>加入到系统路径即可在终端中直接输入<code>mage</code>运行软件。</p><h2 id="第一个-Magefile"><a href="#第一个-Magefile" class="headerlink" title="第一个 Magefile"></a>第一个 Magefile</h2><p>Magefile 实质是符合 golang 语法的源代码，并且加入了特定的注记，规则如下：</p><ol><li>在包名之前加入一行，<code>// +build mage</code></li><li>包名必须为 <code>main</code></li><li>每个可导出函数会变成可被 mage 执行的选项（类似 Makefile 的每一个 tag）</li><li>每个可导出函数前的注释会被转换成帮助文档</li><li>文件名可以但不一定必须是 Magefile.go</li></ol><p>在任意目录输入<code>mage -init</code>可以生成Magefile.go 模板代码。<br>可以输入以下代码实验以上规则</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// +build mage</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"><span class="keyword">import</span>(</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"log"</span></div><div class="line">)</div><div class="line"><span class="comment">//Build</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Build</span><span class="params">()</span></span>&#123;</div><div class="line">    fmt.Println(<span class="string">"Building..."</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">//Install</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Install</span><span class="params">()</span></span>&#123;</div><div class="line">    log.Println(<span class="string">"Installing..."</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="预备，构建"><a href="#预备，构建" class="headerlink" title="预备，构建"></a>预备，构建</h2><p>构建只需要一行代码<code>mage build</code>，程序就会自动执行 <code>Build</code> 函数，完成整个构建过程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mage 是使用 golang 开发的类 Make的软件构建工具。借助这个工具只需要编写符合 golang 语言规范的代码就可以实现比较复杂的源代码编译。&lt;br&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://gawainx.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang 处理 yaml 格式数据</title>
    <link href="https://gawainx.github.io/2018/04/11/goyaml/"/>
    <id>https://gawainx.github.io/2018/04/11/goyaml/</id>
    <published>2018-04-11T09:18:58.000Z</published>
    <updated>2018-05-24T08:59:19.428Z</updated>
    
    <content type="html"><![CDATA[<p>YAML 格式的数据常用来作为配置文件使用, 因此相对来说字段比较固定, 在 golang 中进行解析时跟上一篇提到的解析 json 数据有所区别</p><p>## </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;YAML 格式的数据常用来作为配置文件使用, 因此相对来说字段比较固定, 在 golang 中进行解析时跟上一篇提到的解析 json 数据有所区别&lt;/p&gt;
&lt;p&gt;## &lt;/p&gt;

      
    
    </summary>
    
    
      <category term="golang" scheme="https://gawainx.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>go 语言中 JSON 数据的处理</title>
    <link href="https://gawainx.github.io/2018/03/30/gojson/"/>
    <id>https://gawainx.github.io/2018/03/30/gojson/</id>
    <published>2018-03-30T07:20:31.000Z</published>
    <updated>2018-05-24T08:59:19.440Z</updated>
    
    <content type="html"><![CDATA[<p>Golang 中处理 JSON 格式数据主要依赖<code>encoding/json</code>这个库，很多教程（包括 Go 语言圣经）讲 JSON 数据处理时都会定义一个结构体对应于 JSON 数据的各个字段，这种处理方法在 JSON 中字段相对固定时非常实用。但对于字段可能不断变化或者只有一两个字段是固定的时候，如何处理这个问题往往令很多人感到困惑。最近研究 gin 这个库的时候发现一个思路非常值得学习借鉴。<br><a id="more"></a></p><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>说了这么多，其实并不神秘，就是来自 gin 框架源码中的一句关键定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// H is a shortcup for map[string]interface&#123;&#125;</span></div><div class="line"><span class="keyword">type</span> H <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</div></pre></td></tr></table></figure><p>定义了这个数据结构之后，gin 框架就可以处理几乎所有的 JSON 数据。</p><p>同理，我们在自己的代码中想不受结构体限制灵活处理 JSON 数据时，也可以在程序代码中添加类似的定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> message <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</div></pre></td></tr></table></figure><p>从字符串解析 JSON 数据时，只需要</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//body is string message</span></div><div class="line"><span class="keyword">var</span> result mss</div><div class="line">json.Unmarshal([]<span class="keyword">byte</span>(body),&amp;result)</div></pre></td></tr></table></figure><p>包装 JSON 也类似</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//mes is message type</span></div><div class="line">bty,err := json.Marshal(mes)</div></pre></td></tr></table></figure><p>值得一说的是平时处理 JSON 数据经常出现的反斜杠双引号问题，用这种方法处理时并没有出现。</p><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>背后原理分析。</p><p>这一行代码之所以这么实用是因为<code>interface{}</code>这个 golang 中的“万金油”。Golang 中不存在类和对象的概念，因此空接口就成了所有变量的“超类”一样的存在，可以承载一切的变量。</p><h2 id="潜在问题-and-Further-More"><a href="#潜在问题-and-Further-More" class="headerlink" title="潜在问题 and Further More"></a>潜在问题 and Further More</h2><p>处理 JSON Array 时会出现问题，就是明知它是数组却不能直接用下标进行操作（会提示<code>{}interface</code> 不支持下标，导致编译失败），实际运行时用反射包的<code>reflect.TypeOf</code>查看JSON 数组解析出来的类型明明是<code>[]interface{}</code>，是接口slice，是支持下标操作的。</p><p>原因是 Golang 是静态语言，代码中所有变量的类型都是在编译期确定的，我们所定义的类型中 map 的 value 部分是<code>{}interface</code>，在 运行时接收到需要解析的 JSON 数据之前编译器和我们都不知道它“事实上”是一个 slice。</p><p>这个在项目应用中实际存在的矛盾也解决我学 OOP 语言一直以来的困惑，就是反射是什么？为什么现代编程语言都选择加入反射作为基本特性（Java，C#，还有本文中的 Golang），就是因为我们有在运行时获取某个对象/变量的实际类型的需要。</p><p>由于目前学习还不够深入，不能对反射机制展开深入的探讨，在这里讲一下如何利用类型断言机制解决上面说到的问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cs,ok := result[<span class="string">"containers"</span>].([]<span class="keyword">interface</span>&#123;&#125;)</div><div class="line"><span class="keyword">if</span> ok&#123;</div><div class="line"><span class="keyword">for</span> i,item := <span class="keyword">range</span> cs&#123;</div><div class="line"><span class="comment">//do something</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>cs,ok := result[&quot;containers&quot;].([]interface{})</code>这一句就是解决问题的关键所在，也就是称为运行时类型断言的机制。<code>a.(Type)</code>是尝试对a进行类型转换的操作，如果转换成功则返回一个转换成 Type 类型的变量和<code>true</code>指示转换成功，失败则返回<code>false</code>。</p><p>值得一提的是，断言失败不会导致编译失败（要是会导致编译失败也就不能解决上面这个问题了），所以为了代码健壮性需要对转换结果进行判断比较好。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Golang 中处理 JSON 格式数据主要依赖&lt;code&gt;encoding/json&lt;/code&gt;这个库，很多教程（包括 Go 语言圣经）讲 JSON 数据处理时都会定义一个结构体对应于 JSON 数据的各个字段，这种处理方法在 JSON 中字段相对固定时非常实用。但对于字段可能不断变化或者只有一两个字段是固定的时候，如何处理这个问题往往令很多人感到困惑。最近研究 gin 这个库的时候发现一个思路非常值得学习借鉴。&lt;br&gt;
    
    </summary>
    
    
      <category term="go" scheme="https://gawainx.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>redis的杂七杂八</title>
    <link href="https://gawainx.github.io/2018/02/25/redis/"/>
    <id>https://gawainx.github.io/2018/02/25/redis/</id>
    <published>2018-02-25T15:09:10.000Z</published>
    <updated>2018-05-24T08:59:19.421Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 是目前应用比较广泛的数据库。最近的实验室项目中用到它作为实时数据库。把这个过程中学到的一些东西记录下来，权且作为小白的入门参考吧<br><a id="more"></a></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Redis 是一种基于内存的数据库，这意味着在使用过程中的所有数据都是存放在内存当中的，省去硬盘读写的过程使得对数据库的操作会非常的快，很适合并发。</p><p>Redis 的基本储存单位是<code>key-value</code>，比 mongodb 中的“文档”的概念有着更细的粒度。<code>key</code>部分一般是字符串类型，<code>value</code>部分可以有以下五种类型：</p><ol><li>string。字符串类型</li><li>hash。一系列<code>k-v</code>的集合，适合用来储存对象实例或者 JSON</li><li>list。简单的字符串列表，也就是说可以通过 list 数据结构在一个<code>key</code>对应的<code>value</code>字段储存多个字符串。这多个字符串是有序排列的。“序”指的是插入的顺序（可以选从头部或者尾部插入）</li><li>set。String 类型的无序集合。满足唯一性。</li><li>有序集合。set 的有序版本</li></ol><h2 id="命令行操作"><a href="#命令行操作" class="headerlink" title="命令行操作"></a>命令行操作</h2><h3 id="服务器（server-端）"><a href="#服务器（server-端）" class="headerlink" title="服务器（server 端）"></a>服务器（server 端）</h3><p>安装 Redis 之后，在命令行窗口输入<code>redis-server</code>即可在本机运行一个radis 的 server 端，默认的端口是6379.</p><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>Redis 服务器端和其他主流数据库一样可以很方便的放到 Docker 容器里运行。</p><p>下载 Redis 镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo docker pull redis</div></pre></td></tr></table></figure><p>基于 redis 镜像运行容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo docker run --name redis-server -p 6379:6379 -d redis</div></pre></td></tr></table></figure><p>镜像内部已经设置了运行<code>redis-server</code>和监听6379端口，所以不需要额外的设置项，只需要在运行容器时将端口暴露出来（与宿主机的6379端口或者自己指定的端口绑定）就可以了</p><h3 id="client-端"><a href="#client-端" class="headerlink" title="client 端"></a>client 端</h3><p>shell 界面下输入<code>redis-cli -h 127.0.0.1 -p 6379</code>启动 redis-client。其中，<code>-h</code>指定服务器的地址，<code>-p</code>指定服务器的端口。</p><h4 id="基本操作命令"><a href="#基本操作命令" class="headerlink" title="基本操作命令"></a>基本操作命令</h4><p>注意到，命令的操作字段是不区分大小写的。</p><ol><li>value 为 String 类型时。<code>set key value</code>用于为 key 设置值为 value。 <code>get key</code>用于获取键为 key 的值。</li><li>value 为 list类型时。<code>lpush key value1 [value2]…</code>用于将一个或者多个值。 <code>LPOP key</code>可以移出并获取列表的第一个元素。这两个操作换成<code>rpush</code>和<code>rpop</code>可以向列表尾部插入元素。<code>LLEN key</code>可以获取 key 对应的列表的长度。<code>LRANGE key start stop</code>用于获取特定key 的指定范围的元素，特别地，<code>LRANGE key 0 -1</code>可以用来遍历列表。</li></ol><p>更加详细的命令教程可以参考<a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="external">Redis教程-菜鸟教程</a></p><h2 id="编程语言支持"><a href="#编程语言支持" class="headerlink" title="编程语言支持"></a>编程语言支持</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>在 Java 中主要通过 jedis 数据库驱动实现对 Redis 数据库的操作。</p><p>安装依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><h4 id="JedisPool和-JedisClient"><a href="#JedisPool和-JedisClient" class="headerlink" title="JedisPool和 JedisClient"></a>JedisPool和 JedisClient</h4><p>jedis 使用 JedisPool 作为一个Redis连接池，用于解决对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题。</p><p>连接池初始化代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JedisPool <span class="title">getPool</span><span class="params">(String host, <span class="keyword">int</span> port)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(pool == <span class="keyword">null</span>)&#123;</div><div class="line">            JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</div><div class="line">            </div><div class="line"><span class="comment">//设置最大连接数</span></div><div class="line">            config.setMaxTotal(<span class="number">100</span>);</div><div class="line"></div><div class="line">            config.setMaxIdle(<span class="number">5</span>);</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(host == <span class="keyword">null</span>)&#123;</div><div class="line">                pool = <span class="keyword">new</span> JedisPool(config, <span class="string">"127.0.0.1"</span>, port);</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                pool = <span class="keyword">new</span> JedisPool(config, host, port);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> pool;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>要使用Client 时，使用<code>pool.getResource()</code>方法获取单个JedisClient实例，在此基础上对 Redis 数据库进行操作。</p><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><p>Go 语言中用来连接 Redis 数据库的库五花八门，主要分两个派系，将对 Redis 的操作封装成方法的，开发者通过调用库的方法实现对 Redis 数据库的操作；另一派是直接将 Redis 命令作为字符串提供给库来实现各种操作的。</p><p>这里以<code>&quot;github.com/garyburd/redigo/redis&quot;</code>为例。</p><p>安装依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go get github.com/garyburd/redigo/redis</div></pre></td></tr></table></figure><p>获取 redis pool实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">redis.Pool&#123;</div><div class="line">MaxIdle:<span class="number">10</span>,</div><div class="line">MaxActive:<span class="number">15</span>,</div><div class="line">IdleTimeout:<span class="number">240</span>*time.Second,</div><div class="line">Dial: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(redis.Conn, error)</span></span> &#123;</div><div class="line">c, err := redis.Dial(<span class="string">"tcp"</span>, redisURL)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> c, err</div><div class="line">&#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从 pool 中获取 Client 实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rClient := redisPool.Get()</div></pre></td></tr></table></figure><p>执行操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rClient.Do(<span class="string">"LPUSH"</span>,<span class="string">"key"</span>, <span class="string">"value"</span>)</div></pre></td></tr></table></figure><p>Do 方法用于执行对 Redis 数据库的操作命令。方法的第一个参数字符串命令（就是在 shell 交互时的各种命令。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 是目前应用比较广泛的数据库。最近的实验室项目中用到它作为实时数据库。把这个过程中学到的一些东西记录下来，权且作为小白的入门参考吧&lt;br&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://gawainx.github.io/tags/golang/"/>
    
      <category term="Java" scheme="https://gawainx.github.io/tags/Java/"/>
    
      <category term="Redis" scheme="https://gawainx.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Keras 手写数字识别</title>
    <link href="https://gawainx.github.io/2018/01/23/aml/"/>
    <id>https://gawainx.github.io/2018/01/23/aml/</id>
    <published>2018-01-23T10:42:42.000Z</published>
    <updated>2018-05-24T08:59:19.432Z</updated>
    
    <content type="html"><![CDATA[<hr><p>之前机器学习课程布置的大作业是用尽可能多的模型来探索经典的手写数字识别问题。这里分享一下Keras的基本使用<br><a id="more"></a></p><h1 id="Keras简介"><a href="#Keras简介" class="headerlink" title="Keras简介"></a>Keras简介</h1><p>Keras 是由纯 Python 写成的，调用 TensorFlow 或者 Theano（最新版本还支持 CNTK）进行运算的类库。相比于 TensorFlow，Keras 使用起来更加简洁方便，便于调参，非常适合初学者进行机器学习探索。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>在安装好 anaconda 的前提下，输入<code>conda install keras</code>即可进行安装。</p><p>注意到，安装过程会自动判断机器是否已经安装好了TensorFlow，如果没有的话会自动进行安装。所以，如果想安装 TensorFlow GPU 版本加速计算过程的话，要先手动安装好 TensorFlow 的 GPU 版本，然后再安装 Keras。</p><h1 id="实现单层感知机"><a href="#实现单层感知机" class="headerlink" title="实现单层感知机"></a>实现单层感知机</h1><p>核心代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">batch_size = <span class="number">128</span></div><div class="line">classes = <span class="number">10</span></div><div class="line">epoch = <span class="number">10</span></div><div class="line">img_size = <span class="number">28</span> * <span class="number">28</span></div><div class="line"></div><div class="line">print(<span class="string">'Loading Data...'</span>)</div><div class="line">(X_train, y_train),(X_test,y_test) = mnist.load_data()</div><div class="line"></div><div class="line">X_train = X_train.reshape(y_train.shape[<span class="number">0</span>], img_size).astype(<span class="string">'float32'</span>) / <span class="number">255</span></div><div class="line">X_test = X_test.reshape(y_test.shape[<span class="number">0</span>], img_size).astype(<span class="string">'float32'</span>) / <span class="number">255</span></div><div class="line"></div><div class="line"><span class="comment">#encode labels</span></div><div class="line">Y_train = np_utils.to_categorical(y_train,classes)</div><div class="line">Y_test = np_utils.to_categorical(y_test,classes)</div><div class="line"></div><div class="line"></div><div class="line">model = Sequential([Dense(<span class="number">10</span>, input_shape=(img_size,), activation=<span class="string">'softmax'</span>),])</div><div class="line">model.compile(optimizer=<span class="string">'rmsprop'</span>, loss=<span class="string">'mean_absolute_error'</span>, metrics=[<span class="string">'accuracy'</span>])</div><div class="line"></div><div class="line">print(<span class="string">"Training..."</span>)</div><div class="line">model.fit(X_train, Y_train,batch_size=batch_size, epochs=epoch, verbose=<span class="number">1</span>, validation_data=(X_test,Y_test))</div><div class="line"></div><div class="line">score = model.evaluate(X_test,Y_test,verbose=<span class="number">0</span>)</div><div class="line"></div><div class="line">print(<span class="string">'accuracy: &#123;&#125;'</span>.format(score[<span class="number">1</span>]))</div></pre></td></tr></table></figure><p>前面很大一部分都是进行数据加载和处理，与模型有关的代码只有三行</p><p><code>model = Sequential([Dense(10, input_shape=(img_size,), activation=&#39;softmax&#39;),])</code>这一行是模型基本形态的定义，以图像的 size 作为输入，激活函数采用 softmax。</p><p><code>model.compile(optimizer=&#39;rmsprop&#39;, loss=&#39;mean_absolute_error&#39;, metrics=[&#39;accuracy&#39;])</code>这一行则是对模型的微观参数进行客制化。<code>optimizer</code>指定的是优化策略，<code>rmsprop</code>是一种改进的随机梯度下降策略。<code>loss</code>指的是损失函数。<code>metrics</code>是评估方法，这里用准确率进行评估。</p><p><code>model.fit(X_train, Y_train,batch_size=batch_size, epochs=epoch, verbose=1, validation_data=(X_test,Y_test))</code>这一句是训练过程，指定训练数据，训练轮次（迭代次数），是否输出训练过程，验证数据。</p><h1 id="多层全连接网络"><a href="#多层全连接网络" class="headerlink" title="多层全连接网络"></a>多层全连接网络</h1><p>核心代码部分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">model = Sequential([Dense(<span class="number">512</span>,input_shape=(img_size,)),</div><div class="line">                    Activation(<span class="string">'relu'</span>),</div><div class="line">                    Dropout(<span class="number">0.2</span>),</div><div class="line">                    Dense(<span class="number">512</span>, input_shape=(<span class="number">512</span>,)),</div><div class="line">                    Activation(<span class="string">'relu'</span>),</div><div class="line">                    Dropout(<span class="number">0.2</span>),</div><div class="line">                    Dense(<span class="number">10</span>,input_shape=(<span class="number">512</span>,),activation=<span class="string">'softmax'</span>)</div><div class="line">                    ])</div></pre></td></tr></table></figure><p>每一个 Dense 都是一个神经元训练层。训练层输出接 ReLU 激活函数层。如此类推。最后一层接单层感知机获取结果。值得注意的是两个 Dropout 层，用于应付过拟合问题，经过 Dropout 层会随机丢弃数据集中一定比率的激活值，同时将剩余的神经元的输出进行放大。</p><h1 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">model = Sequential()</div><div class="line">model.add(Conv2D(<span class="number">32</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>),</div><div class="line">                 activation=<span class="string">'relu'</span>,</div><div class="line">                 input_shape=input_shape))</div><div class="line">model.add(Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">'relu'</span>))</div><div class="line">model.add(MaxPooling2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>)))</div><div class="line">model.add(Dropout(<span class="number">0.25</span>))</div><div class="line">model.add(Flatten())</div><div class="line">model.add(Dense(<span class="number">128</span>, activation=<span class="string">'relu'</span>))</div><div class="line">model.add(Dropout(<span class="number">0.5</span>))</div><div class="line">model.add(Dense(num_classes, activation=<span class="string">'softmax'</span>))</div></pre></td></tr></table></figure><p>卷积神经网络中主角变成了 Conv2D （卷积层）和 Pooling 层（池化）。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;之前机器学习课程布置的大作业是用尽可能多的模型来探索经典的手写数字识别问题。这里分享一下Keras的基本使用&lt;br&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://gawainx.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>网研机试101</title>
    <link href="https://gawainx.github.io/2018/01/08/buptoj/"/>
    <id>https://gawainx.github.io/2018/01/08/buptoj/</id>
    <published>2018-01-08T10:13:08.000Z</published>
    <updated>2018-05-24T08:59:19.417Z</updated>
    
    <content type="html"><![CDATA[<p>2018考研的初试已经结束了，平时看考研群里已经有很多人在讨论在焦虑机试应该怎么复习，作为过来人在这里就随便说说自己的一些经验吧。</p><p>实现说明一下，这篇文章基本就是个扫盲，不能保证你看完文章就能从 A0变 AK，但帮助你脱离新手区，扫除对机试的恐惧，保个底让机试不会成为复试阶段的软肋还是可以的。<br><a id="more"></a></p><h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>首先得先了解机试的基本情况。按照去年的考试风格，是两个小时四道题的 OJ（Online Judge）形式，也就是在线提交，在线判题返回程序在测试结果集的运行结果。AC（accept）代表正确解题，WA（Wrong Answer）表示错误答案，另外还有超时、超出内存空间等等结果。所有考试前准备的目的，就是为了更多的 AC，或者保底情况，避免 A0。</p><h1 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h1><h2 id="该用什么语言"><a href="#该用什么语言" class="headerlink" title="该用什么语言"></a>该用什么语言</h2><p>北邮 OJ 平台可以用的编程语言有三种，C（gcc4.8），C++（g++ 4.8）和 Java（注意：没有 Python，没有 JavaScript）。另外，C++是<strong>不支持 c++11的</strong>，Java 只支持到 Java6。</p><p>在这个天煞的背景下，考虑到程序时间限制（1ms）和开发速度（避免无谓的造轮子），用 C + STL 是最理想的选择。</p><p>展开来说，就是用 C 的那一套输入输出（scanf 和 printf），C 与 C++通用的循环控制、选择结构、数组等，在加上 C++独特的“宝具”——STL 标准库，来进行解题。提交的时候编译器选 g++即可。</p><p>STL 标准库内容非常多，只需要了解 Map，stack，list，queue就够了。</p><h2 id="IDE？不存在的"><a href="#IDE？不存在的" class="headerlink" title="IDE？不存在的"></a>IDE？不存在的</h2><p>两个小时做四道题对大脑转数的要求还是挺高的，更何况在那种紧张的气氛和不熟悉的开发环境之下。要保证解题能够快狠准，就需要从现在开始培养一定的针对考试的编程习惯，包括 编辑器和编译器、调试器的使用等等。</p><p>首先，抛弃手上所有的 IDE，包括但不限于 Visual Studio和 Clion，DevC++，或者只在疑难杂症的时候拿它们当单步调试的工具（但也不能依赖）。考试环境只提供了（没有智能提示的）devcpp，（长得贼丑的）CFree两种最“原始”的开发工具，也就拿来当代码高亮，保证括号补全没有基本的语法问题差不多了，很多现代 IDE、开发工具可以做的事它们一概做不了。</p><p>要适应这种艰苦恶劣的考试环境，就得从准备机试的时候开始，把开发工具换成 VScode and g++。VScode 是微软提供的跨平台编辑器，有着漂亮的界面和基本的语法高亮功能，在配置各种插件之前基本可以拿来模拟考场的开发环境，用来编辑代码，而且还能保证练习的时候是比较舒服的。</p><p>编译过程全部转到命令行用 g++完成。</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>两个最基本额调试手段：打印大法和单步调试大法。个人推荐第一种。单步调试大法需要掌握 gdb这个 g++配套的调试工具，相对来说比较费时间（无论上手还是在考场上使用），而且比较容易出一些奇奇怪怪的问题。想成为 AK 达人的话，倒是必须掌握的。</p><p>打印大法就是在关键步骤将关键变量输出的方法，简单易行，只要注意提交之前注释掉代码就OK。</p><h2 id="参考教材"><a href="#参考教材" class="headerlink" title="参考教材"></a>参考教材</h2><p>注意到，机试是可以带任何纸质打印资料的，一本简介明了的语言参考指南显得非常重要。</p><p>抛弃所有国内教科书，包括但不限于谭浩强，除非你想拿成绩开玩笑在考试的时候验证一下<code>int a++++</code>会不会报错。</p><p>在这里，只推荐<a href="https://item.jd.com/10057446.html" target="_blank" rel="external">K&amp;R The C Programming Language</a>小薄本。将 ANSI C 的所有内容都讲得很透彻而简洁，里面的习题也可以作为入门练手。</p><h1 id="能力层级"><a href="#能力层级" class="headerlink" title="能力层级"></a>能力层级</h1><p>这一部分提供平时训练刷题的参考方向。列举我在去年准备的时候看过的一些题型，具体知识和代码在<a href="https://item.jd.com/11399054.html" target="_blank" rel="external">王道机试指南</a>和<a href="https://item.jd.com/11469701.html" target="_blank" rel="external">算法竞赛入门经典</a>介绍的比较详尽。</p><h2 id="基本输入输出"><a href="#基本输入输出" class="headerlink" title="基本输入输出"></a>基本输入输出</h2><p>OJ 的输入输出风格可是能玩死不少人的，怎么保证循环接收输入，接收特定符号能退出，每一轮输入怎么界定，怎么输出小数点后三位浮点数，输出的时候删掉无谓信息（比如句子最后的致命空格），等等等等，都是值得关注的内容，也是首先要练习的。所幸 scanf 和 printf 函数在 KR 里面已经介绍得非常详尽，对照着看和练习就行。</p><h2 id="数字和数组处理"><a href="#数字和数组处理" class="headerlink" title="数字和数组处理"></a>数字和数组处理</h2><p>数字部分有点像小学数学的找规律填数，也会夹带私货弄些奇形怪状的浮点数处理，数组处理方面典型例子就是找最大最小数，找次小数，奇偶数分离这些。一般都在签到题出现。</p><h2 id="日期问题"><a href="#日期问题" class="headerlink" title="日期问题"></a>日期问题</h2><p>闰年问题，星期几问题等等。</p><h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><p>翻转字符串，回文字符串判断，甚至字符串匹配、简易正则表达式识别、字符串搜索都是有可能出现的，活用 std::string 和 char 数组的下标嗯。</p><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><p>图论的 D 算法 F 算法，深度优先搜索，矩阵乘法等等。这种基本都是最终 boss 级别，因为很多 ACM 资料都会有典型的算法题目，代码可以直接套用，改改关键变量就可以，所以称为模板题。</p><h2 id="特别提名：模拟题"><a href="#特别提名：模拟题" class="headerlink" title="特别提名：模拟题"></a>特别提名：模拟题</h2><p>模拟题，可不是模拟卷子，而是一类型模拟计算机内部操作比如进程调度，死锁识别等的题目，印象最深刻就是去年最后一题算进程完成时间的。</p><h1 id="思维方法"><a href="#思维方法" class="headerlink" title="思维方法"></a>思维方法</h1><p>这里介绍一些玄学的东西，也是机试对以后的开发生涯最有帮助的东西</p><h3 id="边界值控制和处理"><a href="#边界值控制和处理" class="headerlink" title="边界值控制和处理"></a>边界值控制和处理</h3><p>刚开始接触 OJ 的时候很容易会遇到本地编译没问题，提供的测试数据也能获得预期结果可是提交之后就是 WA 这种百思不得其解的问题，根源便在于边界值考虑不周全，比如整数0，范围的边界，字符串中的空串等等，解决之道便是通过大量的练习，对每个算法题首先花上几秒考虑可能的边界情况和特殊情况，久而久之形成严密的思维。</p><h3 id="时间性能"><a href="#时间性能" class="headerlink" title="时间性能"></a>时间性能</h3><p>1ms 的时间限制，看起来非常的充分，那只是还没遇到大规模输入。在那种几万甚至十万级别的数据（OJ 上真的会有），就算是$O(n^3)$的算法，翻车也是随时随地的。</p><p>应对这个问题，得对计算机内部执行过程有最基本的认识，更好一点的得对算法的时间复杂度有认识，优化起来才不会像无头苍蝇一样。</p><p>还是祭出<a href="https://item.jd.com/12006637.html" target="_blank" rel="external">CSAPP</a>，里面对程序优化的介绍比较详细，充分利用 Cache 可以编写更高效程序。</p><h4 id="奇技淫巧"><a href="#奇技淫巧" class="headerlink" title="奇技淫巧"></a>奇技淫巧</h4><p>这里特别提名位运算，关键时刻可以省下大量的时间。</p><p>安利<a href="https://item.jd.com/1092950325.html" target="_blank" rel="external">Hackers’ Delight</a></p><h2 id="基本的算法设计思想"><a href="#基本的算法设计思想" class="headerlink" title="基本的算法设计思想"></a>基本的算法设计思想</h2><p>递归，动态规划，不一而足，还是那句话，需要不断的刷题积累经验。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018考研的初试已经结束了，平时看考研群里已经有很多人在讨论在焦虑机试应该怎么复习，作为过来人在这里就随便说说自己的一些经验吧。&lt;/p&gt;
&lt;p&gt;实现说明一下，这篇文章基本就是个扫盲，不能保证你看完文章就能从 A0变 AK，但帮助你脱离新手区，扫除对机试的恐惧，保个底让机试不会成为复试阶段的软肋还是可以的。&lt;br&gt;
    
    </summary>
    
    
      <category term="BOJ" scheme="https://gawainx.github.io/tags/BOJ/"/>
    
  </entry>
  
  <entry>
    <title>linuxnv</title>
    <link href="https://gawainx.github.io/2017/12/06/linuxnv/"/>
    <id>https://gawainx.github.io/2017/12/06/linuxnv/</id>
    <published>2017-12-06T13:30:36.000Z</published>
    <updated>2018-05-24T08:59:19.424Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TensorFlow For Docker 初体验</title>
    <link href="https://gawainx.github.io/2017/12/06/dockertf/"/>
    <id>https://gawainx.github.io/2017/12/06/dockertf/</id>
    <published>2017-12-06T13:30:22.000Z</published>
    <updated>2018-05-24T08:59:19.436Z</updated>
    
    <content type="html"><![CDATA[<hr><p>TensorFlow 是一套开源的机器学习工具。一般来说只用 TensorFlow 的话配置运行环境什么的并没有特别坑的地方，但如果想用到 GPU 加速计算的话配置起来就要费好大一番力气了，还经常遇到各种版本不兼容、找不到依赖关系等问题，让人头疼。而 Docker 刚好是解决开源软件各种依赖关系的神物，NVIDIA 刚好又有工具能让容器用上 GPU 进行计算。</p><p>下面分享配置过程。</p><p>测试环境是 GTX850M+Ubuntu16.04.3+CUDA9.0+GeForce 384.00</p><p>驱动及 CUDA 安装过程参考即将到来的另一篇文章。</p><a id="more"></a><h1 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h1><p>可以用<code>curl -sSL https://get.daocloud.io/docker | sh</code>这条命令快速安装 Docker，不过，这个安装脚本默认会安装最新版本的 Docker（当前是17.11.0 docker-ce），而 NVIDIA Docker 并不支持这个新版本（跪</p><p>所以要进行一下卸载再降级操作…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># uninstall docker</div><div class="line">sudo apt-get purge docker-ce</div><div class="line"># 查看软件库中可用的历史版本</div><div class="line">sudo apt-cache policy docker-ce</div><div class="line"># install docker-ce 17.09</div><div class="line">sudo apt-get install -y docker-ce=17.09.0~ce-0~ubuntu</div></pre></td></tr></table></figure><p>值得一提的是17年的某个版本开始，docker 的软件包统一到 docker-ce（社区）和 docker-ee（付费企业版）上面来了，开发使用的主要以 docker-ce 为主，网上很多教程（尤其是2016年、2016年的）说到安装 docker 的软件包名叫例如 lxc-docker docker.io 等的都是老旧版本的。</p><h1 id="安装-NVIDIA-docker"><a href="#安装-NVIDIA-docker" class="headerlink" title="安装 NVIDIA-docker"></a>安装 NVIDIA-docker</h1><p><a href="https://github.com/NVIDIA/nvidia-docker" target="_blank" rel="external">Nvidia-Docker</a>是老黄提供的一套在 Docker 上制造跑核弹的工具（。</p><p>简单来说，这套工具提供了一个运行时，用来连接 Docker 容器和物理设备的 GPU 资源，使得 Docker 容器可以直接访问、调用物理机的 GPU 资源进行密集型计算操作。</p><p>安装步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># Add the package repositories 添加软件仓库</div><div class="line">curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | \</div><div class="line">  sudo apt-key add -</div><div class="line">curl -s -L https://nvidia.github.io/nvidia-docker/ubuntu16.04/amd64/nvidia-docker.list | \</div><div class="line">  sudo tee /etc/apt/sources.list.d/nvidia-docker.list</div><div class="line">sudo apt-get update</div><div class="line"></div><div class="line"># Install nvidia-docker2 and reload the Docker daemon configuration</div><div class="line">sudo apt-get install -y nvidia-docker2</div><div class="line">sudo pkill -SIGHUP dockerd</div><div class="line"></div><div class="line"># Test nvidia-smi with the latest official CUDA image</div><div class="line">docker run --runtime=nvidia --rm nvidia/cuda nvidia-smi</div></pre></td></tr></table></figure><p>在 Ubuntu16.04测试通过。</p><h1 id="安装-TensorFlow-的-Docker-镜像"><a href="#安装-TensorFlow-的-Docker-镜像" class="headerlink" title="安装 TensorFlow 的 Docker 镜像"></a>安装 TensorFlow 的 Docker 镜像</h1><p>TensorFlow 官方提供了 for Docker 的镜像，里面集成了完整的依赖关系，免去了用<code>pip</code>安装各种包的烦恼。</p><p>镜像包含很多 tag，常用的有下面几个：</p><ul><li>tensorflow/tensorflow:latest，运行环境是 python2.7，仅支持 CPU</li><li>tensorflow/tensorflow:latest-gpu，运行环境是 python2.7，支持 GPU 计算</li><li>tensorflow/tensorflow:latest-py3，运行环境是 python3.5，仅支持 CPU</li><li>tensorflow/tensorflow:latest-gpu-py3，运行环境是 python2.7，支持 调用GPU</li></ul><p>我自己用的是最后一个。</p><p>首先下载镜像下来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull tensorflow/tensorflow:latest-gpu-py3</div></pre></td></tr></table></figure><p>然后跑个 python3交互环境试试水</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --runtime=nvidia --rm -it tensorflow/tensorflow:latest-gpu-py3 python3</div></pre></td></tr></table></figure><p>在交互环境下输入<code>import tensorflow as tf</code>，如果没提示依赖库错误则说明安装成功。</p><p>上面的<code>—runtime=nvidia</code>为调用 nvidia-docker 工具包（运行时）而不是标准运行时来运行镜像，只有加了这个选项才能调用 GPU。</p><p>最后跑一下多重感知机训练手写数字识别，效果图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://7xpabg.com1.z0.glb.clouddn.com/20171206222913_Q4dNYH_Snip20171206_3.jpeg" alt="多重感知机训练手写数字识别模型" title="">                </div>                <div class="image-caption">多重感知机训练手写数字识别模型</div>            </figure><p>输出显示调用 GPU:0进行计算，说明配置一路顺风了。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;TensorFlow 是一套开源的机器学习工具。一般来说只用 TensorFlow 的话配置运行环境什么的并没有特别坑的地方，但如果想用到 GPU 加速计算的话配置起来就要费好大一番力气了，还经常遇到各种版本不兼容、找不到依赖关系等问题，让人头疼。而 Docker 刚好是解决开源软件各种依赖关系的神物，NVIDIA 刚好又有工具能让容器用上 GPU 进行计算。&lt;/p&gt;
&lt;p&gt;下面分享配置过程。&lt;/p&gt;
&lt;p&gt;测试环境是 GTX850M+Ubuntu16.04.3+CUDA9.0+GeForce 384.00&lt;/p&gt;
&lt;p&gt;驱动及 CUDA 安装过程参考即将到来的另一篇文章。&lt;/p&gt;
    
    </summary>
    
    
      <category term="TensorFlow" scheme="https://gawainx.github.io/tags/TensorFlow/"/>
    
      <category term="Docker" scheme="https://gawainx.github.io/tags/Docker/"/>
    
      <category term="ML" scheme="https://gawainx.github.io/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>最大概率汉语切分算法研究-(0)-概览</title>
    <link href="https://gawainx.github.io/2017/11/27/mpseg0/"/>
    <id>https://gawainx.github.io/2017/11/27/mpseg0/</id>
    <published>2017-11-27T13:48:13.000Z</published>
    <updated>2018-05-24T08:59:19.437Z</updated>
    
    <content type="html"><![CDATA[<p>最近忙活了将近一个多月总算把计算语言学布置的最大概率汉语切分作业写完了，虽然中途一波三折，还发生了很多五光十色奇形怪状让人难忘的事情，所幸最后还是比较完整的写了出来，也学到了不少的知识。因此便有了这个系列的文章。</p><p>在这篇给出这系列文章的导航帖汇总。<br><a id="more"></a></p><p>至于代码嘛，等交完实验报告再说嗯。。</p><p><a href="http://antarx.com/2017/11/25/mpseg1/" target="_blank" rel="external">最大概率汉语切分算法研究（一）词典构建</a></p><p><a href="http://antarx.com/2017/11/25/mpseg2/" target="_blank" rel="external">最大概率汉语切分算法研究（二）BiGram语言模型</a></p><p><a href="http://antarx.com/2017/11/25/mpseg3/" target="_blank" rel="external">最大概率汉语切分算法研究（三）有向无环图（DAG）与最优左近邻词</a></p><p><a href="http://antarx.com/2017/11/25/mpseg4/" target="_blank" rel="external">最大概率汉语切分算法研究(四）FMM 与 BMM 在分词中的应用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近忙活了将近一个多月总算把计算语言学布置的最大概率汉语切分作业写完了，虽然中途一波三折，还发生了很多五光十色奇形怪状让人难忘的事情，所幸最后还是比较完整的写了出来，也学到了不少的知识。因此便有了这个系列的文章。&lt;/p&gt;
&lt;p&gt;在这篇给出这系列文章的导航帖汇总。&lt;br&gt;
    
    </summary>
    
    
      <category term="NLP" scheme="https://gawainx.github.io/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>最大概率汉语切分算法研究(四）FMM 与 BMM 在分词中的应用</title>
    <link href="https://gawainx.github.io/2017/11/25/mpseg4/"/>
    <id>https://gawainx.github.io/2017/11/25/mpseg4/</id>
    <published>2017-11-25T10:04:43.000Z</published>
    <updated>2018-05-24T08:59:19.435Z</updated>
    
    <content type="html"><![CDATA[<p>本篇继续讨论对输入句子的处理问题。FMM 和 BMM 是指对输入句子分别找前向最长词和后向最长词，某种程度上来说属于贪心算法的一种，比较惊喜的地方是两者结合常常能获得比较不错的分词效果。<br><a id="more"></a></p><h1 id="FMM"><a href="#FMM" class="headerlink" title="FMM"></a>FMM</h1><p>FMM，可以理解成前向（Forward）最长词，就是对一个句子，每次切分找词的时候，都是从前往后“切出”最长的词和剩下的子句，例如：</p><p>“<strong>有意见分歧</strong>”这句话，用 FMM 进行切分找第一个词的时候就会切分成：</p><p><strong>有意/见分歧</strong></p><p>只利用 FMM 进行分词时，对每次切分后的子句都反复寻找最长前缀词，直到子句为空。注意到，FMM 得到的切分序列是唯一的。</p><h1 id="BMM"><a href="#BMM" class="headerlink" title="BMM"></a>BMM</h1><p>BMM，可以理解成后向（Backward）最长词，就是对一个句子进行切分的时候，都是从后往前“切出”最长词和剩下的子句，例如</p><p>“有意见分歧”这句话，用 BMM 切分的时候会分成：</p><p><strong>有意见/分歧</strong></p><p>其中，“分歧”是寻找到的“第一个词”，“有意见”是待切分的子句。</p><p>用 BMM 分词的时候，对每次切分后的子句都反复寻找最长后缀词，直到句子为空。</p><h1 id="FMM-与-BMM-组合分词"><a href="#FMM-与-BMM-组合分词" class="headerlink" title="FMM 与 BMM 组合分词"></a>FMM 与 BMM 组合分词</h1><p>只用 FMM 或 BMM 进行分词的话，由于算法本身“贪心”的属性，往往得不到最理想的切分结果。所以在进行汉语切分的时候，可以将两个算法结合使用，用于发现歧义（因为对于没有歧义的句子，FMM 和 BMM 得到的切分结果一定是一致的），也可以将两个算法得到的序列计算整句话的概率（利用 BiGram 模型），选取概率较大者作为最终的切分结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇继续讨论对输入句子的处理问题。FMM 和 BMM 是指对输入句子分别找前向最长词和后向最长词，某种程度上来说属于贪心算法的一种，比较惊喜的地方是两者结合常常能获得比较不错的分词效果。&lt;br&gt;
    
    </summary>
    
    
      <category term="NLP" scheme="https://gawainx.github.io/tags/NLP/"/>
    
  </entry>
  
</feed>
