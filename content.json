[{"title":"BOJ 解题报告-268内存管理","date":"2017-03-11T12:36:09.000Z","path":"2017/03/11/268/","text":"前言进行 OJ 练习以来做的最复杂的一个题目,A 完之后趁热打铁写个解题报告. 题目描述详情访问268.进程管理 大体的意思就是实现操作系统中进程管理基本的 fork, kill 和查询功能 输入输出处理输入第一行是整数 T, 表示有多少组输入数据. 第二行是整数 N, 表示本组数据中有多少行命令. 接下来每一行是一条命令.形式如下 FORK PID_1 PID_2 KILL PID QUERY PID 难点一: 同时出现输入组数和操作的数量这是在之前做的题目中没出现过的.解决办法如下面代码 1234567while(T--)&#123; int n; scanf(\"%d\",&amp;n); while(n--)&#123; //do something &#125;&#125; 难点二: 如何应对输入命令的不同格式从给出的示例可见, FORK 后面有两个整形参数,其他两个命令后面都只有一个参数,这个时候如果只使用scanf()函数处理输入,会因为输入的变量个数不一致而出现奇奇怪怪的问题,所以转而先使用gets( char*) 获取一整行命令读进 buff 数组,然后用sscanf(char* source, char* fomat, …)进行处理. 要注意的是,因为 scanf(&quot;%d&quot;,&amp;n)之后会有个\\n 会塞在缓冲区, 影响 gets() 函数的正常读入,所以要先getchar() 一下. 另外, gets() 函数在 c11标准中不再被支持,使用之前要注意运行环境限制. 输出当输入命令为QUERY PID 的形式时会产生输出,如果查询的进程存在则输出 Yes, 否则输出 No.( 注意大小写) 解题思路和坑点数据储存首先要解决数据储存的问题. 采用 bool 类型数组记录每个进程的存在情况, 并且使用下标记录进程号. map&lt;int,vector&lt;int&gt; &gt;来记录每个进程及其子进程的映射.按照操作系统课本的思想采用链表记录最为恰当,但在 OJ 这种特殊情况下, 自然可以选择更加”偷懒”的方法.更何况 STL 的性能还是相当可靠的. 对于每一条命令,用sscanf 处理后将指令部分赋值到string 变量, 方便判断. 坑点一: 0进程不能被删除题目条件中说到0进程在任何情况下都是存在的,因此输入KILL 0不会有任何响应. 坑点二: 子进程的子进程要被删除比如说如下以来关系0-&gt;1-&gt;2-&gt;3-&gt;4,杀死1进程之后,后继的2,3,4进程都必须被杀死,否则会导致 WA. 使用递归删除的办法可以确保子进程的子进程会被安全删除. 不算坑的坑点三题目中还说到KILL 指令中如果是不存在或者已经结束的进程,则不采取任何操作.这一点在本题中靠输入来保证了,所以不用在代码中额外处理.否则,需要额外的数组来记录每个进程的出现情况. 程序代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;map&gt;using std::vector;using std::map;using std::string;char buff[20];char cmd[10];;map&lt;int,vector&lt;int&gt; &gt; relation;bool pid[105];void killKids(int x)&#123; if(!relation[x].empty())&#123; //no empty vector&lt;int&gt;::iterator j; for(j=relation[x].begin();j!=relation[x].end();j++)&#123; pid[*j] = false;//kill it killKids(*j);//kill them all &#125; relation[x].clear(); &#125;&#125;// kill kids methodint main()&#123; int T; scanf(\"%d\",&amp;T); while(T--)&#123; relation.clear();//init memset(pid,0,sizeof(pid)); pid[0] = true; int n; scanf(\"%d\",&amp;n); getchar(); for(int z = n;z&gt;0;z--)&#123; int x,y; gets(buff); if(sscanf(buff,\"%s%d%d\",cmd,&amp;x,&amp;y)==3)&#123; //FORK command if(pid[x])&#123; //x exist relation[x].push_back(y); pid[y] = true; &#125; &#125;else&#123; string act = cmd; if(act == \"QUERY\")&#123; if(pid[x]==1)&#123; puts(\"Yes\"); &#125;else&#123; puts(\"No\"); &#125; &#125;else if(act == \"KILL\")&#123; //end all kids if(pid[x]&amp;&amp;(x!=0))&#123; killKids(x); pid[x] = false;//kill x &#125; &#125; &#125; &#125; &#125;&#125;","tags":[{"name":"BOJ","slug":"BOJ","permalink":"http://antarx.com/tags/BOJ/"}]},{"title":"BOJ解题报告(2)-89-统计时间间隔","date":"2017-03-07T12:23:30.000Z","path":"2017/03/07/89/","text":"题目描述给出两个时间(24小时制)，求第一个时间至少要经过多久才能到达第二个时间。给出的时间一定满足的形式，其中x和y分别代表小时和分钟。0≤x&lt;24,0≤y&lt;60。 输入输出处理输入格式hh:mm,也就是在数字时钟中最常见的24小时表示法, 对于这种输入形式, 可以仿照87题中的技巧通过 scanf(&quot;%d:%d&quot;,&amp;hh,&amp;mm)的形式将时间和分钟分别复制到两个整形变量当中. 输出是最少经过的分钟数, 是一个整形变量,没有太多的技巧. 思路因为题目中要求输出的是分钟数,所以可以先将输入的两个时间换算成当天的分钟数,然后计算时间差就是所求. 要注意的是起始时间大于结束时间的时候, 求出t1-t2要加上24*60(一天的分钟数). 源代码12345678910111213#include&lt;cstdio&gt;int main()&#123; int T,x1,y1,x2,y2; scanf(\"%d\",&amp;T); while(T--)&#123; scanf(\"%d:%d\",&amp;x1,&amp;y1); scanf(\"%d:%d\",&amp;x2,&amp;y2); int t1 = x1*60+y1; int t2 = x2*60+y2; int res = ((t2&gt;=t1)?(t2-t1):(t2-t1+24*60)); printf(\"%d\\n\",res); &#125;&#125;","tags":[{"name":"BOJ","slug":"BOJ","permalink":"http://antarx.com/tags/BOJ/"}]},{"title":"BOJ 解题报告(1)-87-日期","date":"2017-03-07T11:58:57.000Z","path":"2017/03/07/87-cpp/","text":"题目描述请你计算出第X年Y月Z日是第X年的第几天。其中，1月1日是第一天，1月2日是第二天，以此类推。 计算时请注意闰年的影响。对于非整百年，年数能整除4是闰年，否则不是闰年；对于整百年，年数能整除400是闰年，否则不是闰年。如1900年和1901年不是闰年，而2000年和2004年是闰年。 题目链接 思路这是个典型的涉及闰年的日期问题, 要求解某一年是第几天.思路很直接,从月份入手,先计算前$ Y-1$个月一共有多少天,然后在加上这个月中这一天之前有多少天,就可以得到结果. 输入输出处理在所有 OJ 中,输入输出都是绕不过的坎,很多时候会因为输出处理不好而导致莫名其妙的 WA, 又有很多时候可以从输入格式中获得解题的灵感. 回到本题,输入格式为X:Y:Z的形式, X,Y,Z 都是整数, 以冒号隔开.这不由得让我们想到了可以利用 scanf 的格式字段做”手脚”, 直接将 X, Y, Z 读入到整形变量当中进行后续的处理.所以有了以下代码来处理日期的输入. 12int X,Y,Z;scanf(\"%d:%d:%d\",&amp;X,&amp;Y,&amp;Z); 输出方面,只需要输出天数,是一个整形变量,没有什么特别的技巧. 注意事项这部分描述题目中的”边沿”情况, 如果忽略这些情况,就会导致 WA 闰年的处理题目中也给出了提示.在代码中可以利用宏来判断闰年. 1#define ISYEAP(x) ((x%100!=0)&amp;&amp;(x%4==0))||(x%400==0)?1:0 使用宏的时候一定要注意, 编译器在编译的时候会将宏展开之后插到每一个调用宏的地方,为了避免由于运算符优先级问题带来奇奇怪怪的 bug, 建议前后用括号括起来,像这样( ISYEA(X)) 一月份1月份的时候,天数即为当日的日期,直接输出 Z 字段即可. 二月份这也是个容易踩坑的地方,大家都知道闰年要算2月29天,但有时太匆忙的时候,会糊里糊涂把闰年1月2月的日期也会莫名其妙的加上了”1天”,导致 WA. 因此要单独处理.也可以通过构造合理的if 语句和一月份的情况一起处理. 对每个月的日子进行预处理在程序开始之前可以定义一个数组储存每个月的天数, 计算日子时直接根据下标找到天数相加即可,可以减少代码量和运行时间. 预处理的时候要注意, c 语言的数组下标从0开始, 而月份是从1月开始,所以可以构造一个13个元素的数组并且让第一个元素值为0避免不必要的麻烦. 代码1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#define ISYEAP(x) ((x%100!=0)&amp;&amp;(x%4==0))||(x%400==0)?1:0int daysOfMonth[13] = &#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;int main()&#123; int T; scanf(\"%d\",&amp;T); while(T--)&#123; int yy,mm,dd; int days=0; scanf(\"%d:%d:%d\",&amp;yy,&amp;mm,&amp;dd); if(mm==1)&#123; days = dd;//special situation &#125;else&#123; for(int i = 1;i&lt;mm;i++)&#123; days+=daysOfMonth[i]; &#125; days+=dd; if(ISYEAP(yy))&#123; if(mm&gt;2)&#123; days++; &#125; &#125; &#125; printf(\"%d\\n\",days); &#125; &#125;","tags":[{"name":"BOJ","slug":"BOJ","permalink":"http://antarx.com/tags/BOJ/"}]},{"title":"vscode配置 c++ 开发环境(一):智能提示","date":"2017-02-18T10:48:20.000Z","path":"2017/02/18/vscode/","text":"#前言vscode是微软推出的跨平台的编辑器, 开发者可以通过丰富的插件把它定制成最适合自己使用的开发环境. 对于我来说,它最吸引的地方之一就是可以为 Mac 还有 Linux 平台提供了与 Visual Studio 类似的智能提示功能. 正文 首先, 下载对应系统的 VScode. 如果是 Mac 系统,那么请安装 xcode 命令行工具,如果是 Linux 系统,请安装clang 编译器. 安装 cpptools 和 C++clang 插件.其中, cpptools 可以提供代码检错等功能,而 IntelliSense 功能,是通过 C++clang 插件实现的. 按command+,,打开用户配置文件setting.json, 将以下代码拷贝进去. 123456789&#123; \"clang.executable\": \"/usr/bin/clang++\", \"clang.completion.enable\": true, \"clang.completion.triggerChars\": [ \".\", \":\", \"&gt;\"], \"clang.cxxflags\": [\"-std=c++11\"]&#125; 要注意到配置文件是 json 格式,所以,如果之前已经有其它的设置,请按照 json 文件的语法格式将大括号里面的内容拷贝进去. 重启应用程序,即可享受 vscode 带来的智能提示功能了.效果图如下.","tags":[{"name":"M$","slug":"M","permalink":"http://antarx.com/tags/M/"}]},{"title":"使用国际版Azure搭建梯子教程","date":"2016-08-07T14:16:40.000Z","path":"2016/08/07/Azure/","text":"前言本文基于MSDN订阅版本对应的Azure云服务提供的虚拟机服务，搭建自己的影子袜子（自己翻译成英文，懂的人都懂）。 过程中参考了众多软狗的相关文章，对此表示感谢。 准备阶段这部分介绍如何激活自己的Azure服务并配置自己的虚拟机。 首先用微软账号登录Azure云服务，注意与国内的Azure区别开来。然后选择新建-&gt;虚拟机-&gt;Ubuntu Server 14.04 LTS，部署类型选择资源管理器。 这一步结束之后，如果你之前已经激活了Azure服务，则跳过本段继续阅读。否则继续。在未激活Azure订阅时，上一步点击创建之后它会自动导航到“添加您的Azure订阅”的页面,选择Visual Studio Enterprise选项，点击了解更多，进到关于这项订阅的介绍页面，找到相关按钮然后点击激活Azure订阅。 此后，回到第一步，再新建一个虚拟机，镜像类型同样选择Ubuntu Server 14.04 LTS，就会弹出创建虚拟机的选项卡，基本配置中填写虚拟机的名字，用户名，密码（它默认是SSH公钥登录，你需要切换到密码登录的选项卡中），然后新建一个资源组。主机位置建议选择东亚（香港机房）或美国西部（加利福尼亚机房），虽然在铁通12M宽带环境下发现这俩的速度都差不多QAQ。点击确定以继续。 接下来，选择虚拟机套餐方案，A1足矣。 接下来就是虚拟机的配置部分。 磁盘类型选择标准。公共IP地址中注意选择静态IP（它默认给的是动态）。其他选项保持默认，点击确定.（有人提到在网络安全组当中要建一个入站规则允许所有网络连接，我在部署时未发现这个规则的必要性，所以暂且不表）。 进入第四步，确定相关信息没问题之后点击确定，开始部署。部署完成后，在概要中记下公共IP地址。 虚拟机安装影子袜子本步骤需要ssh连接虚拟机。在*nix下用bash自带的ssh命令行即可。Windows平台下，可以使用cmder或者Xshell或者securCRT，putty之类的软件，我自己用的是Cygwin。 输入 ssh [username]@[your IP] 回车之后，输入Yes，然后输入登录密码，登录到虚拟服务器。 注：方括号部分为根据自己的配置需要自行更改的部分。方括号里面已经标明字段含义。 登录成功后，输入 sudo apt-get update 更新Ubuntu的软件列表，否则会导致后续软件安装失败。 然后，输入 sudo apt-get install python-pip 安装pip软件管理程序。 输入 sudo pip install shadowsocks 安装影子袜子。 输入 sudo ssserver -p [port number] -k [password] -m aes-256-cfb --user nobody -d start 启动影子袜子的服务器端。 #客户端操作 至此，Azure部署影子袜子的服务器端部分已经完毕。接下来就是在需要梯子的地方，安装相关的客户端软件（貌似在水果手机上功能会受到很多限制）. 安装相关软件后，在设置页面，服务器地址，密码，端口，协议类型分别对应你的虚拟机IP地址，[passport]字段，[port]字段，以及 aes-256-cfb。点击连接，即可。","tags":[{"name":"Azure","slug":"Azure","permalink":"http://antarx.com/tags/Azure/"}]},{"title":"通信的基础——大学这三年到底学了啥（主线课程篇）","date":"2016-03-08T14:33:57.000Z","path":"2016/03/08/Communication/","text":"前言每次跟其他专业的同学聊天的时候往往会被问到，“你们通信工程这个专业到底是学些啥的”，之前回答这个问题的时候一直都是支支吾吾，实在惭愧。到了这个学期，在几乎所有的专业基础课都学完的时候，总算可以稍稍整理一下这个问题了。 正文整理的第一件事，就是明确通信的概念。通信，就是说白了就是实现两点之间的信息传输。所以就字面上看，着眼点并不多，主要在于怎么表示信息和怎么传的问题。 本文的写作思路根据学校培养方案给出的每个学期开设课程的时间顺序来叙述。这两年多来学的课程庞杂，近乎无所不包，这里先整理出与通信最密切相关的课程来整理一下。 信号与系统这是通信工程专业首先接触的一门与“通信”这个概念密切相关的专业基础课。在这门课中，我们首先接触到了“信号”这个概念。 平时我们现实生活中听到的声音，看到的图像，每一个场景，都是信息。目前受到技术的各种限制，这样的信息是没办法直接传输的（这么传输可能需要无限的带宽，需要极强的抗干扰性能，等等）。目前基于电的形式运作的通信系统只能传输“电”，所以，引入了“电信号”的概念。 好了，有了电信号的概念，一切就方便了，因为“电”这个东西的很多特性是从19世纪就开始有所研究的。于是，就有了各种用函数表示的确定信号。 只有函数表示的信号是没有用的，就像在二进制代码中只知道1和0而不了解上下文一样。要怎么对这些信号进行处理呢？这个时候引入了三大变换：傅立叶变换，Laplace变换和Z变换。三个变换的本质都是将时域信号转换成变换域进行分析处理。这些变换一个主要目的就是将时域中繁琐的卷积操作转换为变换域相成操作，为分析运算带来巨大的方便。 关于变换域概念的理解，是理解系统的一个先决条件。我们都是生活在时域世界，简单来说就是一切按照时间顺序发展和变化的，这样的缺点就是在自己的角度没办法“高屋建瓴”的去分析问题，所以很多小说为了描述整个故事，都会有并行支线，描写同一个时段不同人物的活动，还利用各种叙述方式。变换域也是同样的道理，拿傅立叶变换（时域频域变换）来举例，可以理解成在同一时间点有不同频率的分量同时活动，傅立叶变换的目的，就是把这样一个个“人物”抽离出来进行分析处理。 说完变换域之后，终于可以到“系统”这个词了。我记得通信原理老师的一句经典名言“通信里面对信号所有的处理都可以理解成滤波器。”滤波器是一个具体的系统，也就是说，“所有系统的本质就是对信号进行各种处理”。这个处理，通常是频域的，对某个频域分量进行操作，比如“砍掉”一部分分量，“强化（增益）”某些分量，等等。 数字信号处理DSP，俗称“大山炮”，是通信主线课程的第二门专业基础课，顾名思义，在这门课上，讨论了“数字信号”的分析问题。 在信号与系统中，所有的信号都是“模拟”的，也就是时域连续，取值连续的信号。模拟信号的缺点就是无法用计算机进行处理。 数字信号，就是时域离散，而且取值离散的信号。数字信号可以通过模拟信号“取样，保持，量化”得到，在坐标系上表现出来就是一个个离散的点。 为了对数字信号的分析处理，引入了离散时间傅立叶变换和离散傅立叶变换的概念。DTFT是时域离散，变换域连续的，DFT是时域离散，变换域离散的。考虑到“系统”是对信号在变换域中进行处理，DFT更适合用计算机对信号进行分析处理。 随机信号分析这门课讨论的重点是随机信号。这样做的实际背景是在实际通信系统中，信号都是随机的，我们永远不能预测别人下一句话会说什么；另外，在传输过程中会收到噪声的干扰，噪声也是一种随机信号。然而，之前学过的课程都是针对确定信号，也就是有确定数学表达式的信号的。所以我们有必要讨论如何处理随机信号，这样才能讨论信号的传输过程。 随机信号没有确定的数学表达式，这并不意味着在这些信号面前无计可施。在这门课程中，一个极为重要的地方就是引入平稳随机过程的概念，基本思想就是虽然在某一时间点我们不能确定信号的表达式，但如果以时间差为自变量，就可以将某一类随机过程转变为确定的函数表达式进行讨论了。这类随机过程，就是平稳随机过程。 讨论平稳随机过程引入了相关函数的概念，从物理意义上来看，这是两个信号表达式的乘积，因此在变换域中不能像以前那样用幅度谱来讨论了，在此引入了功率谱。 把要讨论的主角介绍完毕之后，就是就此引出的几个相关概念，其中最为挥之不去的就是加性高斯白噪声和匹配滤波器这两个牛鬼蛇神了。 通信原理有了前面一系列的铺垫，各种概念定义表达式粉墨登场之后，终于迎来了这个专业基础课的最终“BOSS”，有多重要？之前的几乎所有课程都只讨论了“信”的来龙去脉，这门课着重在“信”的基础上研究“如何通”，讨论了所有情形之下的信息传输过程，把之前涉及的几乎所有相关知识串联起来，打通天地线，实现真正的通信大业。 因为学习这门课的时候，学院已经把前三章大部分内容抽离到随机信号分析课程了，所以很快就进入了对传输的讨论当中。首先是模拟信号的传输，在讨论中引入了调制和解调的概念，本质上就是实现信号在频域上的搬移，也为以后的讨论打下基调。 讨论完模拟信号的传输之后，就来到这整本书的重点，数字信号的传输。数字信号的传输包括了基带传输和频带传输。跟模拟信号不同的是，数字信号在基带和频带传输中都要进行调制的。因为理想的数字信号是冲激信号的线性组合，频带带宽无限带，根本没法直接传输，要所以进行脉冲编码调制，将其绝大部分能量集中在受限的带宽（成为“主瓣”）中，使传输成为可能。既然是传输，自然会受到噪声的影响，这里终于轮到“加性高斯白噪声”登场了。这种噪声特殊的地方就是在所有频段有相同的取值（就像Gundam里面GN粒子产生全频段电磁波干扰一样。。。）。这种噪声可以非常好的模拟信道传输过程中受到的“热噪声”等的特性，所以将会是整个讨论信号传输过程中的半个“主角”，在讨论信噪比时都默认收到的噪声是加性高斯白噪声。 另外就是匹配滤波器的概念。通过匹配滤波器，将接收信号的高斯噪声限值在传输带宽所覆盖的频域之内，使接收信噪比能够达到最大。 基带传输讨论完毕之后，就是数字信号的频带传输，具体的调制过程和模拟信号的调制过程有异曲同工之妙。真正特别的地方，就是为了提高信道利用效率而引入M进制调制的概念。 之后，就是在本学期学到通原2中学到的关于信息编码处理和信道编码等内容，由于刚开始学习，所以暂且不表。 END原本以为可以简要介绍，但不知不觉就来了废话一堆，能够把一个专业的核心问题说清楚真的不是什么轻而易举的事情，能够整理下来发现大学两年多也并非一无所获。等有时间了继续把其他光怪陆离的课程整理一下，也是对本科四年的一个交代罢了。 纰漏之处，还希望留言指正:-)","tags":[{"name":"Communication","slug":"Communication","permalink":"http://antarx.com/tags/Communication/"}]},{"title":"“软狗”的2015学习总结","date":"2015-12-26T06:09:48.000Z","path":"2015/12/26/2015/","text":"背景2015年转眼间来到了最后一周。大四考研的周末，在宿舍阅读了知乎上一些关于编程学习的文章，深觉自己也应该写下这一年来自己学习上碰到的坑和经验教训，也列举自己看过的一些书，供以后回顾时参考。 絮絮叨叨的一些一言蔽之，2015年是我自己在各方面都大胆探索尝试的一年。年初受知乎上萧大编程入门指南的启发,加上换上了新电脑的推动,开始了自己在编程学习上的系统探索,有人指路总比2014年“盲人摸象”般的窘迫境况好了不少。 编程语言随着学习的深入，我逐渐觉得，活跃在很多程序员社区上的所谓编程语言的争论，所谓”***才是最好的语言”的言辞，纯属奇谈怪论。计算机领域门派众多，不同领域会有不同的开发需要，不同的语言配合不同的开发工具在不同的领域自有自己的独到之处。如果还没接触某个领域，对该领域的编程语言，是没有任何质疑的权力的。入门学习编程时，选择一门看上去最讨喜的，又能体现计算机程序开发的精要的语言，学下去变是了。经历过小白阶段之后，更应该先定下自己感兴趣的领域（诸如人工智能，ML，DM，游戏开发，前端，移动开发，嵌入式等等等等），再根据领域的需要学习相应的语言。 我自己2015年在编程语言上学习的收获，在于以下两门语言的深入学习： C# 作为一名自称的“软狗”，不学习微软技术大系.NET Framework是不行的。（逃 C#作为整个庞大的.NET技术平台的顶梁柱，再配合上自家VS2015的有力驱动，还有MSDN堪称逆天般完善的知识库的支持，自然是入门微软技术学习的首选。在2015年1月就订好了C#的学习计划之后，中间磕磕碰碰，到年末，终于可以说自己基本上是入门了。期间用C#完成了必修课大作业（在此特别感谢上学期教我程序设计实践课程的吴铭老师，让我有摆脱枯燥落后而无聊的MFC的束缚，选择自己喜欢的编程语言完成课程作业的机会），让我对图形界面应用程序的开发有了初步的认知和体会。 C#带给我的收获，不仅仅是那些语言语法逻辑，背后更是一大类带自动内存管理的”面向对象“语言所共有的知识体系。学习了C#语言之后，对待诸如值类型和引用类型，“引用”的概念，“代码托管”，“虚拟机”，“字节码”，”运行时“等等看起来庞杂的概念，有了基本的认识。这些知识，不仅仅对C#学习有极大的帮助，在其他类似语言诸如Python，哪怕是C#的“死对头”Java语言的学习中，也是会起到不可或缺的重要作用的。考虑到这门语言的学习难度，将其作为”面向对象”语言体系的入门语言来学习，是一个非常明智的选择。 Python 从去年年底就嚷嚷着想学的语言，在今年年底，终于可以说自己有所进步了。 对于C++的学习者来说，Python以四空格划分代码区块的“诡异”语法，是初学者在学习上极大的雷区，一不小心就会带来诸多莫名其妙的报错，连”Hello World“都写不出来。在微软俱乐部里面，”学习Python语言需要游标卡尺“这个老梗，也时常成为大家的笑谈。然而，一旦找到一个好看耐“艹”（比如代码高亮，智能提示，自动缩进，PEP 8 代码规范提示…)的IDE辅助学习之后,无论从学习过程还是成就感上，都会有质的飞跃。经过种种的摸索踩坑，庆幸自己终于找到了这个工具——JetBrains-Pycharm Python是一门很活，很活的语言，无论从语法形式上，还是运行调试上，都是如此。在学习Python过程中感触最深的一点，就是很多函数的用法，我都是在Python交互环境中“试”出来的。Python交互环境是我最喜欢Python的一个地方，在这里你可以像Linux Shell那样，输入一条Python指令，就可以获得输出，通过输出可以学习到很多函数的用法，查看某个变量的具体类型等等工作，为后续的编程开发，省了不少力。 Python最具魔力的地方，是那一堆堆用不完的第三方库。这堆库让Python语言在时下最火的领域——人工智能，机器学习，数据分析，数据挖掘，“你老婆”等有一展拳脚的机会。 领域方向2015年我还是挺迷惘的，哪门编程语言都想学，，哪个方向都想尝试，但又怕学而无用，或者碰到了不适合自己的深坑，误了时光。总结下来，自己这一年好像在很多领域都有所接触，但都没深究，近乎一事无成罢了。开荒的领域，在这里还是要提一下的，希望在来年能从中找到一两个自己喜欢的领域深挖下去吧。 UWP应用开发 UWP，微软在Win10平台上的通用应用，基于C#写后台逻辑，XAML写前台界面。XAML简单易懂的语法可以为初学者带来极大的满足感，然而真正想开发出精美绝伦的通用应用，还是需要深入学习和领悟的。WPF这个庞大、特性丰富的界面框架和C#丰富的高级语言特性的学习，是在这方面成为高手的必经之路。 Python开发Web网页应用 在这里特指Flask和Django框架相关的开发。 Android应用的开发 是的没错，一个软狗也有过考虑开发Android应用的时候，主要还是“揾食艰难”，想找一些来钱快的领域学学，找点外快什么的。然而到最后不了了之。 计算机视觉 缘起大二小学期时候的创新实验。当初用OpenCV库搞了个所谓之”人脸识别”的项目，开发过程也不可谓不艰辛，在配置开发环境的时候就走了不少“弯路”，也要摸索很多之前毫无概念的方法。回想起来那段时间其实是自己今年收获最丰富的其中一段时间了。迫使自己重拾了荒废半年的C++，重温了很多基本概念，学习了计算机图像处理的一下核心思想方法。另外，人脸识别也把我带进了模式识别、机器学习的坑。 机器学习 由“人脸识别”带来的坑，然而学的很皮毛，暂且不表。 魔法书 总的来说，这年开的坑确实有点多，但又学的很不深入。到年末才渐渐意识到自己之前的心态之浮躁，不禁为之惭愧不已。到年末想投个实习简历，却发现自己近乎空白的项目经历，甚为汗颜orz。 致那个一直想跳未跳的坑——Gawain Open Sources Project（GOSP）从高三毕业开始就有想做一个属于自己的Android ROM给自己的手机用。然而前两年收到电脑硬件和移动设备的限制（大一是魅族MX2这个万年锁BL的混蛋，大二时信仰挚爱Lumia930）毫无进展。这年年末在电脑硬件和移动设备都能满足的时候，却在漫长坑多的下载源码和编译时间上打了个退堂鼓。或许真的能发布的时候，已经“猴年马月”之后了。 Achieve？今年如果真的有什么建设的话，就是这个博客了。在这方面幸好没有太大的犹豫，Hexo+ GayHub的部署方式，50美刀五年买到了最喜欢的域名，部署过程还顺路入门了Gayhub和Markdown，之后开发过程上也开始积累写下自己的遇到的问题和解决方法。这里感谢微软MSP项目给予我的动力。微软大法好哦耶！ 一些教训 在学习过程中永远不应该害怕走弯路。编程学习本身就是不断在碰坑中修正的过程。事实上，因为害怕走弯路而盲目模仿前人的所谓”经验”,”捷径”的过程，才最弯的弯路。 切忌浮躁，切忌浮躁，切忌浮躁。重要的事情说三遍！ 实践，永远是检验真理的唯一标准。 开发工具这个必须提的。工欲善其事，必先利其器。 一个完整好用的工具链可以省去很多功夫。之前经历过一系列的摸索，从写C++时候的Dev C++，到后来学Python时碰过Vim，敲过Emacs，尝试Eclipse+DevPy，倒腾VS2015+Pytools，还折腾过Sublime，Atom，VSCode编辑器之流。现在总算得到一系列比较完善的开发工具体系。 操作系统上，一直对MacOS的华丽界面和好用到爆炸的终端心向往之，无奈受阻于高昂的价格。尝试过Ubuntu，却无论如何都未能称心如意。到最后躁动的心皈依Windows 10，用Cygwin + Cmder 打造了界面和灵活性不输水果的终端。也算满足了日常使用的基本需要。 现在将自己目前觉得最顺眼的工具链列举记录，供以后重装系统换电脑之后快速配置参考。 操作系统：Windows 10 TH2 Build 10586 终端：Cygwin+Cmder C#开发：宇宙第一IDE VS2015 Community Python开发IDE：Pycharm。强推Monokai配色+Consolas字体 Python交互窗口：使用Cygwin下基于GCC的独立Python环境并独立安装pip。 编辑器SublimeText3。 博客写作Atom + MarkdownPad 今年看过的书絮絮叨叨说了这么多，到最后应该是整理一下今年看过的几本让我“醍醐灌顶”的著作。 《编码的奥秘——隐匿在计算机背后的硬件语言》 上学期学习数字电路与逻辑设计课程，一开始被一大堆的逻辑门电路弄的一头雾水，后来找到了这本“神作”，从最开始的电筒闪亮传输信息的情节开始，循序渐进，以汇编语言收尾，讲述了计算机硬件的编码逻辑的来龙去脉，扫清了学习的迷雾和烦恼。 《程序是怎样跑起来的》 日本人写的一本小书，补充了很多计算机的基础知识，讲解了诸如Windows分页文件等系统级别的“冷”知识，也涉及了CPU，内存等“硬”功夫。 《数学之美》 吴军老师结合自己在项目研发上的实际经验撰写的一本讲述了目前最火的几个领域上用到的数学知识原理。言简意赅，毫不沉闷。 最后的最后写在最后的也不算是对未来的展望了。2016年希望不要摔在同样的坑上。还有就是能成为正式MSP继续传教233333333","tags":[{"name":"Life","slug":"Life","permalink":"http://antarx.com/tags/Life/"},{"name":"编程","slug":"编程","permalink":"http://antarx.com/tags/编程/"}]},{"title":"Cygwin安装独立的pip环境","date":"2015-12-25T10:37:31.000Z","path":"2015/12/25/cygpy/","text":"前言在Windows下配置python的虚拟环境时常常会遇到各种各样的问题。所幸Windows平台下有Cygwin这个虚拟Linux的环境。在cygwin下安装了独立的Python环境后，再安装pip，即可通过pip install virtualenv命令安装Python虚拟环境，之后通过虚拟环境安装Flask，Django等网络开发环境就可以一气呵成了。 安装步骤 首先，安装Cygwin并在软件包选择页面选择安装Python软件包。 前往Get Pip下载get-pip.py文件到cygwin的home目录. 在Cygwin命令行环境下进行pip的安装。执行python get-pip.py命令即可。 安装完毕之后，关闭Cygwin交互环境再打开，就可以进行虚拟环境的安装了。pip安装成功的标志注意: 直接输入pip命令没有提示command not found并不能说明pip被成功安装在cygwin的python运行环境下。如果Windows下也存在Python和pip的话，在Cygwin命令行输入pip会直接调用Windows平台下的pip命令。 可行的判断方法如下：（以下命令均在Cygwin交互环境下输入） 命令行输入which pip返回的结果为’/usr/bin/pip’ 命令行输入pip -V返回的结果为pip 1.5.6 from /usr/lib/python2.7/site-packages (python 2.7) 至此，Cygwin下独立的pip环境已经配置完毕，之后就可以安装Linux下配置Flask，Pyramid或者Django环境的办法愉快的玩耍了。","tags":[{"name":"Python","slug":"Python","permalink":"http://antarx.com/tags/Python/"}]},{"title":"numpy学习笔记（1）--ndarray类型常用属性","date":"2015-12-23T14:39:36.000Z","path":"2015/12/23/numpy/","text":"前言NumPy是python中用于机器学习和科学计算的常用库。opencv for python中cv2.imread(&#39;image.jpg&#39;)命令读取图像返回的数据类型也是ndarray。今天将ndarray的一些常用属性记录下来，以便以后学习时进行参考。 ndarray常用属性 size: 表示array中拥有的总元素数量。 shape: 元组类型。该属性描述了ndarray的“形状”信息。shape[0]为行信息，shape[1]为列信息。 strides: 元组数据类型该属性返回每一个维度上元素的数量。 ndim: 表示这个ndarray的维度。也可以理解为shape属性返回的元组的数量。 T:表示ndarray矩阵的转置。 今天使用opencv做简单的图像处理时接触到的ndarray的相关属性主要就是以上5个。以后再学习过程中遇到的更多有用的属性时会及时做补充。","tags":[]},{"title":"使用动态规划求解字符串编辑距离问题(C#实现）","date":"2015-12-07T14:41:52.000Z","path":"2015/12/07/dp/","text":"前言上次提到会在后续通过实际例子更加深入的谈谈对解释四种四种基本算法设计模式的理解。今天说到的,是利用动态规划思想求解两个字符串的编辑距离。 正文问题背景 我们将两个字符串的相似度定义为：将一个字符串转换为另一个字符串时需要付出的代价。转换方法包括插入，删除和替换三种编辑方式。使用对字符串的编辑次数定义为转换的代价。最小的字符串编辑次数就是字符串的编辑距离。 –《算法的乐趣》 问题分析要使用动态规划思想解决这个问题，首先我们需要对问题进行阶段划分，确定边界条件，定义无后效性的几个子状态并且确定状态之间的转移关系，才能在每个子状态中寻找最优解最后得到原问题的解。 寻找子问题：在本问题中，假设原字符串为source，长度为m，目的字符串为target，长度为n。则问题可以描述为求解source[1..m]转换为target[1..n]所需要的最小编辑次数。注意到，当source的前i个字符和target的前j个字符之间的编辑距离确定之后，不会在后续求解中发生改变，因此此问题的子问题即可定义为求解source的前i个字符和target的前j个字符之间的编辑距离。 边界条件的确定：当source字符串长度为0时，编辑长度为target的字符串长度n（插入n个字符串）。当target的字符串长度为0时，编辑长度为source的字符串长度（删去m个字符串）。 关于“备忘录”：动态规划问题的一个特点是使用类似”备忘录“的”表“记录每个状态的相关信息。本问题中用d[i,j]定义为source的前i个字符和target的前j个字符之间的编辑距离，作为每个状态的标志。 状态之间的转换：以d[i-1,j]+1为删除字符时转移的状态,d[i,j-1]+1为插入字符时转移额状态，d[i-1,j-1]+1为替换字符串时转移的状态。 子问题的最优解：字符串之间的转换方式并不是唯一的，通过操作若干次添加字符，删除字符，替换字符操作都可以实现字符串转换，每次转换状态时，将三种操作方式中的距离的最小值作为d[i,j]，可以保证每个子问题的解都是最优的，从而保证整个问题的解是最优解。 具体代码使用C#语言实现。 using System; namespace EditDistance { class Program { public static int MAX_STR_LEN = 100;//initialize the max length of string static void Main(string[] args) { //test code Console.WriteLine(&quot;Please input Source string:&quot;); String src = Console.ReadLine(); Console.WriteLine(&quot;Please input Target string:&quot;); String dist = Console.ReadLine(); Console.WriteLine(EditDistance(src, dist)); } private static int EditDistance(string src, string dist) { int i, j; int[,] d = new int[MAX_STR_LEN,MAX_STR_LEN]; //initialize the margin condition for (i = 0; i &lt;= src.Length; i++) d[i, 0] = i; for (j = 0; j &lt;= dist.Length; j++) d[0, j] = j; for(i = 1;i&lt;=src.Length;i++) { for(j=1;j&lt;=dist.Length;j++) { if(src[i-1]==dist[j-1]) { d[i, j] = d[i - 1, j - 1]; } else { int edIns = d[i, j - 1] + 1; int edDel = d[i - 1, j] + 1; int edRep = d[i - 1, j - 1] + 1; d[i,j]=Math.Min(Math.Min(edIns,edDel),edRep); } } } return d[src.Length, dist.Length]; } } } 运行结果： 后记求解字符串的编辑距离问题应该是动态规划的最典型案例，体现了动态规划问题的基本特点。适合用动态规划解决的问题，一般都是可以划分多多个子状态的，每个子状态之间存在状态转移关系，每个状态的解一旦确定，就会用类似“备忘录”的表储存起来。在后续求解时，将会直接使用该状态的解，而且，不会再回溯子状态的时候改变该状态的解。 另外，边界条件的确定是问题求解时的一个重要步骤。如果忽略了边界条件，或者在求解时没有正确初始化边界条件（比如在本题中对d[i,0]和d[0,j]需要初始化为i和j），将得不到正确的解。","tags":[{"name":"算法","slug":"算法","permalink":"http://antarx.com/tags/算法/"}]},{"title":"用diskpart打造Win 10安装U盘","date":"2015-11-27T09:54:26.000Z","path":"2015/11/27/Win-10/","text":"前言本文主要介绍通过diskpart命令行的方式制作Windows10引导U盘，制作完毕后，该U盘可以用于安装（包括全新安装和升级安装）Windows10操作系统，也可以在系统无法启动的时候使用该U盘进行修复操作。 正文需要的材料 Windows 10 Build 10586 安装镜像。（推荐从北邮人BT或者IT之家搜索相关的镜像。另外32位或者64位的系统镜像均适用本教程。） 容量大于4GB的U盘一个。建议适用USB3.0的U盘以获得较快的安装速度。请提前备份好用户数据。 以管理员账号登录当前系统。制作步骤 启动当前系统进入桌面环境之后，将U盘插入电脑。在开始菜单中搜索cmd或命令提示符，并右键，选择以管理员身份运行。 在命令提示符窗口中输入diskpart，按回车。 弹出的UAC窗口中选择允许，进入diskpart程序。 在Diskpart程序中，输入list disk查看当前的磁盘列表。 根据容量查看自己的U盘对应的磁盘号。这里假定第一个磁盘为你的U盘。输入select disk 1选中你的U盘。 输入clean，清除U盘内容。 输入create part primary，用于在U盘中创建主分区。大小为U盘的容量大小。 输入format，格式化刚刚创建好的磁盘分区。磁盘格式默认是FAT32。 输入active，激活主分区。这步非常重要，如果忘记输入这条命令，制作的U盘将无法激活。 输入exit，退出程序。 用文件管理器打开下载好的Win10安装ISO镜像文件，将里面的内容全部复制到U盘中。 至此，一个可以在目前绝大部分新的笔记本电脑上启动的Windows10启动U盘已经制作完毕。在BIOS中选择用U盘启动即可进入亲切的Windows10安装界面了。后记虽然目前有很多工具可以制作启动U盘，但本文介绍的方式具有独特的优势，在你想更换别的版本的系统比如制作ubuntu启动盘（逃 的时候，只需要把U盘里面的内容全选删除，并且把ubuntu安装镜像的内容完整复制过去就可以了，不用借助任何其他工具再次制作。","tags":[{"name":"Win10","slug":"Win10","permalink":"http://antarx.com/tags/Win10/"}]},{"title":"四种基本的算法设计模式","date":"2015-11-16T15:15:01.000Z","path":"2015/11/16/四种基本的算法设计模式/","text":"前言最近在阅读一本有趣的算法书，书中作者列举了四种基本的算法设计模式，我总结摘录得到本文。今天先给出文字总结。随着阅读的深入，以后会给出四种设计模式的典型案例。 正文贪婪法- 核心思想： 将原问题划分为多个子情况考虑，在每一个子情况中寻求其局部最优解，然后将局部最优解按照一定的方式（这种方式通常与子问题的划分方式有关）堆叠得到原问题的解。 - 特点： 1. 这种方法不用考虑子问题之间的相互影响（这一点区别于动态规划方法），通俗的说，就是不用“瞻前顾后”。 2. 在每个子问题中都应用了局部最优原则，寻求该子问题的最优解。 - 一般思路： 定义最优解模型-&gt;划分子问题-&gt;定义子问题的最优解结构-&gt;确定局部最优解，并堆叠出全局最优解。 分治法- 核心思想： 将大问题划分为一系列子规模较小的相同问题（解结构相同，子问题之间相互独立），寻找子问题的解之后将结果合并得到原问题的解。 - 特点： 子问题的划分不一定只有一次，而且往往不止一次，划分的目的是使每一个子问题相互独立而且是容易求解和能够最后组合得到原问题的解。正因为这个特点，分治法与递归思想总是密不可分的。 - 难点： 子问题的划分方式和最后结果的合并。如果用递归去解决分治法问题时，难点就是寻找递归关系式和确定递归终止条件。 - 举例：N点离散傅里叶变换的快速计算 动态规划- 核心思想： 要解一个给定问题，我们需要解其不同部分，再合并子问题的解以得到原问题的解。 - 特点： 1. 动态规划在查找有很多重叠子问题的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间。 2. 适用于无后效性的问题。子问题的解一旦确定之后就不会改变，不受之后包含它的更大的问题的求解。 3. 适用于子问题相互重叠的情况。动态规划会创建一张“表”记录每个子问题的计算结果，当再次需要计算此问题时就可以通过查表快速得到结果，简化计算。 - 一般思路： 定义最有子问题-&gt;定义状态-&gt;定义决策和状态转换方程式-&gt;确定边界条件。 - 举例： 斐波那契数列的计算（在计算过程中保存每一步的f(n)）、0-1背包问题 穷举法- 核心思想： 在解空间之内穷举并测试每个可能的结果。 - 穷举策略： 1. 盲目搜索算法。 2. 启发式搜索（开始搜索时加入了一定的附加条件） 3. 剪枝策略：跳过一些明显不会是最优解的分支的搜索。 - 应用举例：很多NP问题的求解最后都是用了枚举法。 后记四种基本的设计模式并不是相互对立的。有时一个问题可以用一种或多种的设计模式去解决，而且，附加的条件不同时，应用的设计方法也不同。一个典型例子就是背包问题（多件体积不同，价值不同的物品放入体积一定的背包，求解价值最大的方案），既可以通过穷举所有情况解决，也可以引入价值密度的概念，用贪婪法设计解决(每次都放入价值密度最高的物品），还可以用动态规划解决（还没透彻理解QAQ）。上面的内容很多都是自己整理书中内容加上自己的一点想法写成的，感觉还是太抽象了，也难免有各种疏漏和错误，欢迎大家留意指正，多多交流。以后补充实际问题结合代码更加深入的分析每一个方法的奥妙。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://antarx.com/tags/读书笔记/"},{"name":"算法","slug":"算法","permalink":"http://antarx.com/tags/算法/"}]},{"title":".NET学习笔记（一）","date":"2015-10-21T08:28:40.000Z","path":"2015/10/21/NET学习笔记（一）/","text":"基础类型相关 .NET中所有内建类型都继承自System.Object,若同时继承自System.ValueType类则为值类型，否则为引用类型。 值类型和引用类型的区别如下： 赋值时，值类型变量会直接获得真实数据的一个副本，而引用类型只会将对象的引用赋值给变量，会造成多个对象指向同一个内存区块（对象实例）的情况。 内存分配时，引用类型对象会在堆上分配内存，而值类型变量会在堆栈上分配内存，运行效率比堆高很多。 装箱拆箱的概念 装箱，指的是CLR需要做额外工作把堆栈上的值类型移动到堆上。 拆箱，指的是把堆中的对象复制到堆栈中，返回其值。 应该注意的是，装箱和拆箱行为，都对应了堆栈上的一系列操作，会造成较大的性能代价。因此减少程装箱拆箱操作，是程序性能优化的一个重点。 避免装箱拆箱操作的思路，在于从两方面避免发生装箱拆箱行为的场合： 值类型的格式化输出。 System.Object类型的容器。对于这种情况，可以使用泛型技术来避免使用System.Object类型的容器。 原文链接.NET基础拾遗(1)类型语法基础和内存管理基础","tags":[{"name":"C#","slug":"C","permalink":"http://antarx.com/tags/C/"},{"name":".NET","slug":"NET","permalink":"http://antarx.com/tags/NET/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://antarx.com/tags/读书笔记/"}]},{"title":"Hello World","date":"2015-09-24T08:29:46.000Z","path":"2015/09/24/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://antarx.com/tags/Hexo/"}]}]